diff -crB ln12Mar/hv/channel.c hv-rhel7.x/hv/channel.c
*** ln12Mar/hv/channel.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/channel.c	2015-05-14 07:05:22.416084887 -0700
***************
*** 26,32 ****
  #include <linux/mm.h>
  #include <linux/slab.h>
  #include <linux/module.h>
! #include <linux/hyperv.h>
  #include <linux/uio.h>
  
  #include "hyperv_vmbus.h"
--- 26,32 ----
  #include <linux/mm.h>
  #include <linux/slab.h>
  #include <linux/module.h>
! #include "include/linux/hyperv.h"
  #include <linux/uio.h>
  
  #include "hyperv_vmbus.h"
diff -crB ln12Mar/hv/channel_mgmt.c hv-rhel7.x/hv/channel_mgmt.c
*** ln12Mar/hv/channel_mgmt.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/channel_mgmt.c	2015-05-14 07:05:22.416084887 -0700
***************
*** 28,34 ****
  #include <linux/list.h>
  #include <linux/module.h>
  #include <linux/completion.h>
! #include <linux/hyperv.h>
  
  #include "hyperv_vmbus.h"
  
--- 28,34 ----
  #include <linux/list.h>
  #include <linux/module.h>
  #include <linux/completion.h>
! #include "include/linux/hyperv.h"
  
  #include "hyperv_vmbus.h"
  
diff -crB ln12Mar/hv/connection.c hv-rhel7.x/hv/connection.c
*** ln12Mar/hv/connection.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/connection.c	2015-05-14 07:05:22.416084887 -0700
***************
*** 29,37 ****
  #include <linux/mm.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
! #include <linux/hyperv.h>
  #include <linux/export.h>
! #include <asm/hyperv.h>
  #include "hyperv_vmbus.h"
  
  
--- 29,37 ----
  #include <linux/mm.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
! #include "include/linux/hyperv.h"
  #include <linux/export.h>
! #include "include/asm/hyperv.h"
  #include "hyperv_vmbus.h"
  
  
***************
*** 420,425 ****
--- 420,426 ----
  	union hv_connection_id conn_id;
  	int ret = 0;
  	int retries = 0;
+ 	u32 msec = 1;
  
  	conn_id.asu32 = 0;
  	conn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;
***************
*** 429,435 ****
  	 * insufficient resources. Retry the operation a couple of
  	 * times before giving up.
  	 */
! 	while (retries < 10) {
  		ret = hv_post_message(conn_id, 1, buffer, buflen);
  
  		switch (ret) {
--- 430,436 ----
  	 * insufficient resources. Retry the operation a couple of
  	 * times before giving up.
  	 */
! 	while (retries < 20) {
  		ret = hv_post_message(conn_id, 1, buffer, buflen);
  
  		switch (ret) {
***************
*** 445,451 ****
  		}
  
  		retries++;
! 		msleep(100);
  	}
  	return ret;
  }
--- 446,455 ----
  		}
  
  		retries++;
! 		msleep(msec);
! 
! 		if (msec < 2048)
! 			msec *= 2;
  	}
  	return ret;
  }
diff -crB ln12Mar/hv/copy_files hv-rhel7.x/hv/copy_files
*** ln12Mar/hv/copy_files	2015-05-14 08:21:45.000000000 -0700
--- hv-rhel7.x/hv/copy_files	2015-05-14 07:05:22.416084887 -0700
***************
*** 21,27 ****
  cp ../../include/uapi/linux/uuid.h ./include/uapi/linux/
  cp ../../include/linux/rndis.h ./include/linux/
  cp ../../include/linux/atomic.h ./include/linux/
! #cp ../../include/linux/hv_compat.h ./include/linux/
  cp ../../include/uapi/linux/hyperv.h ./include/uapi/linux/
  
  cp ../../arch/x86/include/uapi/asm/hyperv.h ./include/asm/
--- 21,27 ----
  cp ../../include/uapi/linux/uuid.h ./include/uapi/linux/
  cp ../../include/linux/rndis.h ./include/linux/
  cp ../../include/linux/atomic.h ./include/linux/
! cp ../../include/linux/hv_compat.h ./include/linux/
  cp ../../include/uapi/linux/hyperv.h ./include/uapi/linux/
  
  cp ../../arch/x86/include/uapi/asm/hyperv.h ./include/asm/
diff -crB ln12Mar/hv/hid-core.c hv-rhel7.x/hv/hid-core.c
*** ln12Mar/hv/hid-core.c	2015-05-14 08:56:40.809989916 -0700
--- hv-rhel7.x/hv/hid-core.c	2015-05-14 07:05:22.417084932 -0700
***************
*** 4,10 ****
   *  Copyright (c) 1999 Andreas Gal
   *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
!  *  Copyright (c) 2006-2012 Jiri Kosina
   */
  
  /*
--- 4,10 ----
   *  Copyright (c) 1999 Andreas Gal
   *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
!  *  Copyright (c) 2006-2010 Jiri Kosina
   */
  
  /*
***************
*** 29,35 ****
  #include <linux/wait.h>
  #include <linux/vmalloc.h>
  #include <linux/sched.h>
! #include <linux/semaphore.h>
  
  #include <linux/hid.h>
  #include <linux/hiddev.h>
--- 29,35 ----
  #include <linux/wait.h>
  #include <linux/vmalloc.h>
  #include <linux/sched.h>
! #include <asm/semaphore.h>
  
  #include <linux/hid.h>
  #include <linux/hiddev.h>
***************
*** 52,58 ****
  
  static int hid_ignore_special_drivers = 0;
  module_param_named(ignore_special_drivers, hid_ignore_special_drivers, int, 0600);
! MODULE_PARM_DESC(ignore_special_drivers, "Ignore any special drivers and handle all devices by generic driver");
  
  /*
   * Register a new report for a device.
--- 52,58 ----
  
  static int hid_ignore_special_drivers = 0;
  module_param_named(ignore_special_drivers, hid_ignore_special_drivers, int, 0600);
! MODULE_PARM_DESC(debug, "Ignore any special drivers and handle all devices by generic driver");
  
  /*
   * Register a new report for a device.
***************
*** 63,70 ****
  	struct hid_report_enum *report_enum = device->report_enum + type;
  	struct hid_report *report;
  
- 	if (id >= HID_MAX_IDS)
- 		return NULL;
  	if (report_enum->report_id_hash[id])
  		return report_enum->report_id_hash[id];
  
--- 63,68 ----
***************
*** 128,134 ****
  
  	if (parser->collection_stack_ptr == HID_COLLECTION_STACK_SIZE) {
  		hid_err(parser->device, "collection stack overflow\n");
! 		return -EINVAL;
  	}
  
  	if (parser->device->maxcollection == parser->device->collection_size) {
--- 126,132 ----
  
  	if (parser->collection_stack_ptr == HID_COLLECTION_STACK_SIZE) {
  		hid_err(parser->device, "collection stack overflow\n");
! 		return -1;
  	}
  
  	if (parser->device->maxcollection == parser->device->collection_size) {
***************
*** 136,142 ****
  				parser->device->collection_size * 2, GFP_KERNEL);
  		if (collection == NULL) {
  			hid_err(parser->device, "failed to reallocate collection array\n");
! 			return -ENOMEM;
  		}
  		memcpy(collection, parser->device->collection,
  			sizeof(struct hid_collection) *
--- 134,140 ----
  				parser->device->collection_size * 2, GFP_KERNEL);
  		if (collection == NULL) {
  			hid_err(parser->device, "failed to reallocate collection array\n");
! 			return -1;
  		}
  		memcpy(collection, parser->device->collection,
  			sizeof(struct hid_collection) *
***************
*** 172,178 ****
  {
  	if (!parser->collection_stack_ptr) {
  		hid_err(parser->device, "collection stack underflow\n");
! 		return -EINVAL;
  	}
  	parser->collection_stack_ptr--;
  	return 0;
--- 170,176 ----
  {
  	if (!parser->collection_stack_ptr) {
  		hid_err(parser->device, "collection stack underflow\n");
! 		return -1;
  	}
  	parser->collection_stack_ptr--;
  	return 0;
***************
*** 222,230 ****
  {
  	struct hid_report *report;
  	struct hid_field *field;
! 	unsigned usages;
  	unsigned offset;
! 	unsigned i;
  
  	report = hid_register_report(parser->device, report_type, parser->global.report_id);
  	if (!report) {
--- 220,228 ----
  {
  	struct hid_report *report;
  	struct hid_field *field;
! 	int usages;
  	unsigned offset;
! 	int i;
  
  	report = hid_register_report(parser->device, report_type, parser->global.report_id);
  	if (!report) {
***************
*** 251,258 ****
  	if (!parser->local.usage_index) /* Ignore padding fields */
  		return 0;
  
! 	usages = max_t(unsigned, parser->local.usage_index,
! 				 parser->global.report_count);
  
  	field = hid_register_field(report, usages, parser->global.report_count);
  	if (!field)
--- 249,255 ----
  	if (!parser->local.usage_index) /* Ignore padding fields */
  		return 0;
  
! 	usages = max_t(int, parser->local.usage_index, parser->global.report_count);
  
  	field = hid_register_field(report, usages, parser->global.report_count);
  	if (!field)
***************
*** 263,276 ****
  	field->application = hid_lookup_collection(parser, HID_COLLECTION_APPLICATION);
  
  	for (i = 0; i < usages; i++) {
! 		unsigned j = i;
  		/* Duplicate the last usage we parsed if we have excess values */
  		if (i >= parser->local.usage_index)
  			j = parser->local.usage_index - 1;
  		field->usage[i].hid = parser->local.usage[j];
  		field->usage[i].collection_index =
  			parser->local.collection_index[j];
- 		field->usage[i].usage_index = i;
  	}
  
  	field->maxusage = usages;
--- 260,272 ----
  	field->application = hid_lookup_collection(parser, HID_COLLECTION_APPLICATION);
  
  	for (i = 0; i < usages; i++) {
! 		int j = i;
  		/* Duplicate the last usage we parsed if we have excess values */
  		if (i >= parser->local.usage_index)
  			j = parser->local.usage_index - 1;
  		field->usage[i].hid = parser->local.usage[j];
  		field->usage[i].collection_index =
  			parser->local.collection_index[j];
  	}
  
  	field->maxusage = usages;
***************
*** 319,325 ****
  
  static int hid_parser_global(struct hid_parser *parser, struct hid_item *item)
  {
- 	__s32 raw_value;
  	switch (item->tag) {
  	case HID_GLOBAL_ITEM_TAG_PUSH:
  
--- 315,320 ----
***************
*** 370,384 ****
  		return 0;
  
  	case HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:
! 		/* Many devices provide unit exponent as a two's complement
! 		 * nibble due to the common misunderstanding of HID
! 		 * specification 1.11, 6.2.2.7 Global Items. Attempt to handle
! 		 * both this and the standard encoding. */
! 		raw_value = item_sdata(item);
! 		if (!(raw_value & 0xfffffff0))
! 			parser->global.unit_exponent = hid_snto32(raw_value, 4);
! 		else
! 			parser->global.unit_exponent = raw_value;
  		return 0;
  
  	case HID_GLOBAL_ITEM_TAG_UNIT:
--- 365,371 ----
  		return 0;
  
  	case HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:
! 		parser->global.unit_exponent = item_sdata(item);
  		return 0;
  
  	case HID_GLOBAL_ITEM_TAG_UNIT:
***************
*** 387,393 ****
  
  	case HID_GLOBAL_ITEM_TAG_REPORT_SIZE:
  		parser->global.report_size = item_udata(item);
! 		if (parser->global.report_size > 128) {
  			hid_err(parser->device, "invalid report_size %d\n",
  					parser->global.report_size);
  			return -1;
--- 374,380 ----
  
  	case HID_GLOBAL_ITEM_TAG_REPORT_SIZE:
  		parser->global.report_size = item_udata(item);
! 		if (parser->global.report_size > 96) {
  			hid_err(parser->device, "invalid report_size %d\n",
  					parser->global.report_size);
  			return -1;
***************
*** 405,414 ****
  
  	case HID_GLOBAL_ITEM_TAG_REPORT_ID:
  		parser->global.report_id = item_udata(item);
! 		if (parser->global.report_id == 0 ||
! 		    parser->global.report_id >= HID_MAX_IDS) {
! 			hid_err(parser->device, "report_id %u is invalid\n",
! 				parser->global.report_id);
  			return -1;
  		}
  		return 0;
--- 392,399 ----
  
  	case HID_GLOBAL_ITEM_TAG_REPORT_ID:
  		parser->global.report_id = item_udata(item);
! 		if (parser->global.report_id == 0) {
! 			hid_err(parser->device, "report_id 0 is invalid\n");
  			return -1;
  		}
  		return 0;
***************
*** 453,459 ****
  			}
  			parser->local.delimiter_depth--;
  		}
! 		return 0;
  
  	case HID_LOCAL_ITEM_TAG_USAGE:
  
--- 438,444 ----
  			}
  			parser->local.delimiter_depth--;
  		}
! 		return 1;
  
  	case HID_LOCAL_ITEM_TAG_USAGE:
  
***************
*** 578,584 ****
  	for (i = 0; i < HID_REPORT_TYPES; i++) {
  		struct hid_report_enum *report_enum = device->report_enum + i;
  
! 		for (j = 0; j < HID_MAX_IDS; j++) {
  			struct hid_report *report = report_enum->report_id_hash[j];
  			if (report)
  				hid_free_report(report);
--- 563,569 ----
  	for (i = 0; i < HID_REPORT_TYPES; i++) {
  		struct hid_report_enum *report_enum = device->report_enum + i;
  
! 		for (j = 0; j < 256; j++) {
  			struct hid_report *report = report_enum->report_id_hash[j];
  			if (report)
  				hid_free_report(report);
***************
*** 680,756 ****
  	return NULL;
  }
  
! static void hid_scan_input_usage(struct hid_parser *parser, u32 usage)
! {
! 	struct hid_device *hid = parser->device;
! 
! 	if (usage == HID_DG_CONTACTID)
! 		hid->group = HID_GROUP_MULTITOUCH;
! }
! 
! static void hid_scan_feature_usage(struct hid_parser *parser, u32 usage)
  {
- 	if (usage == 0xff0000c5 && parser->global.report_count == 256 &&
- 	    parser->global.report_size == 8)
- 		parser->scan_flags |= HID_SCAN_FLAG_MT_WIN_8;
- }
- 
- static void hid_scan_collection(struct hid_parser *parser, unsigned type)
- {
- 	struct hid_device *hid = parser->device;
- 	int i;
- 
- 	if (((parser->global.usage_page << 16) == HID_UP_SENSOR) &&
- 	    type == HID_COLLECTION_PHYSICAL)
- 		hid->group = HID_GROUP_SENSOR_HUB;
- 
- 	if (hid->vendor == USB_VENDOR_ID_MICROSOFT &&
- 	    (hid->product == USB_DEVICE_ID_MS_TYPE_COVER_3 ||
- 	     hid->product == USB_DEVICE_ID_MS_TYPE_COVER_3_JP) &&
- 	    hid->group == HID_GROUP_MULTITOUCH)
- 		hid->group = HID_GROUP_GENERIC;
- 
- 	if ((parser->global.usage_page << 16) == HID_UP_GENDESK)
- 		for (i = 0; i < parser->local.usage_index; i++)
- 			if (parser->local.usage[i] == HID_GD_POINTER)
- 				parser->scan_flags |= HID_SCAN_FLAG_GD_POINTER;
- 
- 	if ((parser->global.usage_page << 16) >= HID_UP_MSVENDOR)
- 		parser->scan_flags |= HID_SCAN_FLAG_VENDOR_SPECIFIC;
- }
- 
- static int hid_scan_main(struct hid_parser *parser, struct hid_item *item)
- {
- 	__u32 data;
- 	int i;
- 
- 	data = item_udata(item);
- 
- 	switch (item->tag) {
- 	case HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:
- 		hid_scan_collection(parser, data & 0xff);
- 		break;
- 	case HID_MAIN_ITEM_TAG_END_COLLECTION:
- 		break;
- 	case HID_MAIN_ITEM_TAG_INPUT:
- 		/* ignore constant inputs, they will be ignored by hid-input */
- 		if (data & HID_MAIN_ITEM_CONSTANT)
- 			break;
- 		for (i = 0; i < parser->local.usage_index; i++)
- 			hid_scan_input_usage(parser, parser->local.usage[i]);
- 		break;
- 	case HID_MAIN_ITEM_TAG_OUTPUT:
- 		break;
- 	case HID_MAIN_ITEM_TAG_FEATURE:
- 		for (i = 0; i < parser->local.usage_index; i++)
- 			hid_scan_feature_usage(parser, parser->local.usage[i]);
- 		break;
- 	}
- 
- 	/* Reset the local parser environment */
- 	memset(&parser->local, 0, sizeof(parser->local));
- 
- 	return 0;
  }
  
  /*
--- 665,672 ----
  	return NULL;
  }
  
! static void hid_scan_usage(struct hid_device *hid, u32 usage)
  {
  }
  
  /*
***************
*** 760,819 ****
   */
  static int hid_scan_report(struct hid_device *hid)
  {
! 	struct hid_parser *parser;
! 	struct hid_item item;
  	__u8 *start = hid->dev_rdesc;
  	__u8 *end = start + hid->dev_rsize;
! 	static int (*dispatch_type[])(struct hid_parser *parser,
! 				      struct hid_item *item) = {
! 		hid_scan_main,
! 		hid_parser_global,
! 		hid_parser_local,
! 		hid_parser_reserved
! 	};
! 
! 	parser = vzalloc(sizeof(struct hid_parser));
! 	if (!parser)
! 		return -ENOMEM;
! 
! 	parser->device = hid;
! 	hid->group = HID_GROUP_GENERIC;
! 
! 	/*
! 	 * The parsing is simpler than the one in hid_open_report() as we should
! 	 * be robust against hid errors. Those errors will be raised by
! 	 * hid_open_report() anyway.
! 	 */
! 	while ((start = fetch_item(start, end, &item)) != NULL)
! 		dispatch_type[item.type](parser, &item);
! 
! 	/*
! 	 * Handle special flags set during scanning.
! 	 */
! 	if ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&
! 	    (hid->group == HID_GROUP_MULTITOUCH))
! 		hid->group = HID_GROUP_MULTITOUCH_WIN_8;
  
! 	/*
! 	 * Vendor specific handlings
! 	 */
! 	switch (hid->vendor) {
! 	case USB_VENDOR_ID_WACOM:
! 		hid->group = HID_GROUP_WACOM;
! 		break;
! 	case USB_VENDOR_ID_SYNAPTICS:
! 		if (hid->group == HID_GROUP_GENERIC)
! 			if ((parser->scan_flags & HID_SCAN_FLAG_VENDOR_SPECIFIC)
! 			    && (parser->scan_flags & HID_SCAN_FLAG_GD_POINTER))
! 				/*
! 				 * hid-rmi should take care of them,
! 				 * not hid-generic
! 				 */
! 				hid->group = HID_GROUP_RMI;
! 		break;
  	}
  
- 	vfree(parser);
  	return 0;
  }
  
--- 676,718 ----
   */
  static int hid_scan_report(struct hid_device *hid)
  {
! 	unsigned int page = 0, delim = 0;
  	__u8 *start = hid->dev_rdesc;
  	__u8 *end = start + hid->dev_rsize;
! 	unsigned int u, u_min = 0, u_max = 0;
! 	struct hid_item item;
  
! 	while ((start = fetch_item(start, end, &item)) != NULL) {
! 		if (item.format != HID_ITEM_FORMAT_SHORT)
! 			return -EINVAL;
! 		if (item.type == HID_ITEM_TYPE_GLOBAL) {
! 			if (item.tag == HID_GLOBAL_ITEM_TAG_USAGE_PAGE)
! 				page = item_udata(&item) << 16;
! 		} else if (item.type == HID_ITEM_TYPE_LOCAL) {
! 			if (delim > 1)
! 				break;
! 			u = item_udata(&item);
! 			if (item.size <= 2)
! 				u += page;
! 			switch (item.tag) {
! 			case HID_LOCAL_ITEM_TAG_DELIMITER:
! 				delim += !!u;
! 				break;
! 			case HID_LOCAL_ITEM_TAG_USAGE:
! 				hid_scan_usage(hid, u);
! 				break;
! 			case HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:
! 				u_min = u;
! 				break;
! 			case HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:
! 				u_max = u;
! 				for (u = u_min; u <= u_max; u++)
! 					hid_scan_usage(hid, u);
! 				break;
! 			}
! 		}
  	}
  
  	return 0;
  }
  
***************
*** 837,910 ****
  }
  EXPORT_SYMBOL_GPL(hid_parse_report);
  
- static const char * const hid_report_names[] = {
- 	"HID_INPUT_REPORT",
- 	"HID_OUTPUT_REPORT",
- 	"HID_FEATURE_REPORT",
- };
- /**
-  * hid_validate_values - validate existing device report's value indexes
-  *
-  * @device: hid device
-  * @type: which report type to examine
-  * @id: which report ID to examine (0 for first)
-  * @field_index: which report field to examine
-  * @report_counts: expected number of values
-  *
-  * Validate the number of values in a given field of a given report, after
-  * parsing.
-  */
- struct hid_report *hid_validate_values(struct hid_device *hid,
- 				       unsigned int type, unsigned int id,
- 				       unsigned int field_index,
- 				       unsigned int report_counts)
- {
- 	struct hid_report *report;
- 
- 	if (type > HID_FEATURE_REPORT) {
- 		hid_err(hid, "invalid HID report type %u\n", type);
- 		return NULL;
- 	}
- 
- 	if (id >= HID_MAX_IDS) {
- 		hid_err(hid, "invalid HID report id %u\n", id);
- 		return NULL;
- 	}
- 
- 	/*
- 	 * Explicitly not using hid_get_report() here since it depends on
- 	 * ->numbered being checked, which may not always be the case when
- 	 * drivers go to access report values.
- 	 */
- 	if (id == 0) {
- 		/*
- 		 * Validating on id 0 means we should examine the first
- 		 * report in the list.
- 		 */
- 		report = list_entry(
- 				hid->report_enum[type].report_list.next,
- 				struct hid_report, list);
- 	} else {
- 		report = hid->report_enum[type].report_id_hash[id];
- 	}
- 	if (!report) {
- 		hid_err(hid, "missing %s %u\n", hid_report_names[type], id);
- 		return NULL;
- 	}
- 	if (report->maxfield <= field_index) {
- 		hid_err(hid, "not enough fields in %s %u\n",
- 			hid_report_names[type], id);
- 		return NULL;
- 	}
- 	if (report->field[field_index]->report_count < report_counts) {
- 		hid_err(hid, "not enough values in %s %u field %u\n",
- 			hid_report_names[type], id, field_index);
- 		return NULL;
- 	}
- 	return report;
- }
- EXPORT_SYMBOL_GPL(hid_validate_values);
- 
  /**
   * hid_open_report - open a driver-specific device report
   *
--- 736,741 ----
***************
*** 923,929 ****
  	struct hid_item item;
  	unsigned int size;
  	__u8 *start;
- 	__u8 *buf;
  	__u8 *end;
  	int ret;
  	static int (*dispatch_type[])(struct hid_parser *parser,
--- 754,759 ----
***************
*** 942,962 ****
  		return -ENODEV;
  	size = device->dev_rsize;
  
- 	buf = kmemdup(start, size, GFP_KERNEL);
- 	if (buf == NULL)
- 		return -ENOMEM;
- 
  	if (device->driver->report_fixup)
! 		start = device->driver->report_fixup(device, buf, &size);
! 	else
! 		start = buf;
  
! 	start = kmemdup(start, size, GFP_KERNEL);
! 	kfree(buf);
! 	if (start == NULL)
  		return -ENOMEM;
- 
- 	device->rdesc = start;
  	device->rsize = size;
  
  	parser = vzalloc(sizeof(struct hid_parser));
--- 772,783 ----
  		return -ENODEV;
  	size = device->dev_rsize;
  
  	if (device->driver->report_fixup)
! 		start = device->driver->report_fixup(device, start, &size);
  
! 	device->rdesc = kmemdup(start, size, GFP_KERNEL);
! 	if (device->rdesc == NULL)
  		return -ENOMEM;
  	device->rsize = size;
  
  	parser = vzalloc(sizeof(struct hid_parser));
***************
*** 1031,1042 ****
  	return value & (1 << (n - 1)) ? value | (-1 << n) : value;
  }
  
- s32 hid_snto32(__u32 value, unsigned n)
- {
- 	return snto32(value, n);
- }
- EXPORT_SYMBOL_GPL(hid_snto32);
- 
  /*
   * Convert a signed 32-bit integer to a signed n-bit integer.
   */
--- 852,857 ----
***************
*** 1061,1067 ****
   * Search linux-kernel and linux-usb-devel archives for "hid-core extract".
   */
  
! static __u32 extract(const struct hid_device *hid, __u8 *report,
  		     unsigned offset, unsigned n)
  {
  	u64 x;
--- 876,882 ----
   * Search linux-kernel and linux-usb-devel archives for "hid-core extract".
   */
  
! static __u32 extract(struct hid_device *hid, __u8 *report,
  		     unsigned offset, unsigned n)
  {
  	u64 x;
***************
*** 1085,1091 ****
   * endianness of register values by considering a register
   * a "cached" copy of the little endiad bit stream.
   */
! static void implement(const struct hid_device *hid, __u8 *report,
  		      unsigned offset, unsigned n, __u32 value)
  {
  	u64 x;
--- 900,906 ----
   * endianness of register values by considering a register
   * a "cached" copy of the little endiad bit stream.
   */
! static void implement(struct hid_device *hid, __u8 *report,
  		      unsigned offset, unsigned n, __u32 value)
  {
  	u64 x;
***************
*** 1178,1185 ****
  	struct hid_driver *hdrv = hid->driver;
  	int ret;
  
! 	if (!list_empty(&hid->debug_list))
! 		hid_dump_input(hid, usage, value);
  
  	if (hdrv && hdrv->event && hid_match_usage(hid, usage)) {
  		ret = hdrv->event(hid, field, usage, value);
--- 993,999 ----
  	struct hid_driver *hdrv = hid->driver;
  	int ret;
  
! 	hid_dump_input(hid, usage, value);
  
  	if (hdrv && hdrv->event && hid_match_usage(hid, usage)) {
  		ret = hdrv->event(hid, field, usage, value);
***************
*** 1259,1265 ****
   * Output the field into the report.
   */
  
! static void hid_output_field(const struct hid_device *hid,
  			     struct hid_field *field, __u8 *data)
  {
  	unsigned count = field->report_count;
--- 1073,1079 ----
   * Output the field into the report.
   */
  
! static void hid_output_field(struct hid_device *hid,
  			     struct hid_field *field, __u8 *data)
  {
  	unsigned count = field->report_count;
***************
*** 1278,1285 ****
  }
  
  /*
!  * Create a report. 'data' has to be allocated using
!  * hid_alloc_report_buf() so that it has proper size.
   */
  
  void hid_output_report(struct hid_report *report, __u8 *data)
--- 1092,1098 ----
  }
  
  /*
!  * Create a report.
   */
  
  void hid_output_report(struct hid_report *report, __u8 *data)
***************
*** 1296,1317 ****
  EXPORT_SYMBOL_GPL(hid_output_report);
  
  /*
-  * Allocator for buffer that is going to be passed to hid_output_report()
-  */
- u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
- {
- 	/*
- 	 * 7 extra bytes are necessary to achieve proper functionality
- 	 * of implement() working on 8 byte chunks
- 	 */
- 
- 	int len = hid_report_len(report) + 7;
- 
- 	return kmalloc(len, flags);
- }
- EXPORT_SYMBOL_GPL(hid_alloc_report_buf);
- 
- /*
   * Set a field value. The report this field belongs to has to be
   * created and transferred to the device, to set this value in the
   * device.
--- 1109,1114 ----
***************
*** 1319,1330 ****
  
  int hid_set_field(struct hid_field *field, unsigned offset, __s32 value)
  {
! 	unsigned size;
! 
! 	if (!field)
! 		return -1;
! 
! 	size = field->report_size;
  
  	hid_dump_input(field->report->device, field->usage + offset, value);
  
--- 1116,1122 ----
  
  int hid_set_field(struct hid_field *field, unsigned offset, __s32 value)
  {
! 	unsigned size = field->report_size;
  
  	hid_dump_input(field->report->device, field->usage + offset, value);
  
***************
*** 1361,1407 ****
  	return report;
  }
  
- /*
-  * Implement a generic .request() callback, using .raw_request()
-  * DO NOT USE in hid drivers directly, but through hid_hw_request instead.
-  */
- void __hid_request(struct hid_device *hid, struct hid_report *report,
- 		int reqtype)
- {
- 	char *buf;
- 	int ret;
- 	int len;
- 
- 	buf = hid_alloc_report_buf(report, GFP_KERNEL);
- 	if (!buf)
- 		return;
- 
- 	len = hid_report_len(report);
- 
- 	if (reqtype == HID_REQ_SET_REPORT)
- 		hid_output_report(report, buf);
- 
- 	ret = hid->ll_driver->raw_request(hid, report->id, buf, len,
- 					  report->type, reqtype);
- 	if (ret < 0) {
- 		dbg_hid("unable to complete request: %d\n", ret);
- 		goto out;
- 	}
- 
- 	if (reqtype == HID_REQ_GET_REPORT)
- 		hid_input_report(hid, report->type, buf, ret, 0);
- 
- out:
- 	kfree(buf);
- }
- EXPORT_SYMBOL_GPL(__hid_request);
- 
  int hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,
  		int interrupt)
  {
  	struct hid_report_enum *report_enum = hid->report_enum + type;
  	struct hid_report *report;
- 	struct hid_driver *hdrv;
  	unsigned int a;
  	int rsize, csize = size;
  	u8 *cdata = data;
--- 1153,1163 ----
***************
*** 1435,1447 ****
  			goto out;
  	}
  
! 	if (hid->claimed != HID_CLAIMED_HIDRAW && report->maxfield) {
! 		for (a = 0; a < report->maxfield; a++)
! 			hid_input_field(hid, report->field[a], cdata, interrupt);
! 		hdrv = hid->driver;
! 		if (hdrv && hdrv->report)
! 			hdrv->report(hid, report);
! 	}
  
  	if (hid->claimed & HID_CLAIMED_INPUT)
  		hidinput_report_event(hid, report);
--- 1191,1198 ----
  			goto out;
  	}
  
! 	for (a = 0; a < report->maxfield; a++)
! 		hid_input_field(hid, report->field[a], cdata, interrupt);
  
  	if (hid->claimed & HID_CLAIMED_INPUT)
  		hidinput_report_event(hid, report);
***************
*** 1466,1477 ****
  	struct hid_report_enum *report_enum;
  	struct hid_driver *hdrv;
  	struct hid_report *report;
  	int ret = 0;
  
  	if (!hid)
  		return -ENODEV;
  
! 	if (down_trylock(&hid->driver_input_lock))
  		return -EBUSY;
  
  	if (!hid->driver) {
--- 1217,1230 ----
  	struct hid_report_enum *report_enum;
  	struct hid_driver *hdrv;
  	struct hid_report *report;
+ 	char *buf;
+ 	unsigned int i;
  	int ret = 0;
  
  	if (!hid)
  		return -ENODEV;
  
! 	if (down_trylock(&hid->driver_lock))
  		return -EBUSY;
  
  	if (!hid->driver) {
***************
*** 1487,1496 ****
  		goto unlock;
  	}
  
! 	/* Avoid unnecessary overhead if debugfs is disabled */
! 	if (!list_empty(&hid->debug_list))
! 		hid_dump_report(hid, type, data, size);
  
  	report = hid_get_report(report_enum, data);
  
  	if (!report) {
--- 1240,1264 ----
  		goto unlock;
  	}
  
! 	buf = kmalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_ATOMIC);
! 
! 	if (!buf)
! 		goto nomem;
! 
! 	/* dump the report */
! 	snprintf(buf, HID_DEBUG_BUFSIZE - 1,
! 			"\nreport (size %u) (%snumbered) = ", size, report_enum->numbered ? "" : "un");
! 	hid_debug_event(hid, buf);
! 
! 	for (i = 0; i < size; i++) {
! 		snprintf(buf, HID_DEBUG_BUFSIZE - 1,
! 				" %02x", data[i]);
! 		hid_debug_event(hid, buf);
! 	}
! 	hid_debug_event(hid, "\n");
! 	kfree(buf);
  
+ nomem:
  	report = hid_get_report(report_enum, data);
  
  	if (!report) {
***************
*** 1500,1513 ****
  
  	if (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {
  		ret = hdrv->raw_event(hid, report, data, size);
! 		if (ret < 0)
  			goto unlock;
  	}
  
  	ret = hid_report_raw_event(hid, type, data, size, interrupt);
  
  unlock:
! 	up(&hid->driver_input_lock);
  	return ret;
  }
  EXPORT_SYMBOL_GPL(hid_input_report);
--- 1268,1283 ----
  
  	if (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {
  		ret = hdrv->raw_event(hid, report, data, size);
! 		if (ret != 0) {
! 			ret = ret < 0 ? ret : 0;
  			goto unlock;
+ 		}
  	}
  
  	ret = hid_report_raw_event(hid, type, data, size, interrupt);
  
  unlock:
! 	up(&hid->driver_lock);
  	return ret;
  }
  EXPORT_SYMBOL_GPL(hid_input_report);
***************
*** 1516,1522 ****
  		const struct hid_device_id *id)
  {
  	return (id->bus == HID_BUS_ANY || id->bus == hdev->bus) &&
- 		(id->group == HID_GROUP_ANY || id->group == hdev->group) &&
  		(id->vendor == HID_ANY_ID || id->vendor == hdev->vendor) &&
  		(id->product == HID_ANY_ID || id->product == hdev->product);
  }
--- 1286,1291 ----
***************
*** 1543,1573 ****
  }
  
  
- static ssize_t
- read_report_descriptor(struct file *filp, struct kobject *kobj,
- 		struct bin_attribute *attr,
- 		char *buf, loff_t off, size_t count)
- {
- 	struct device *dev = container_of(kobj, struct device, kobj);
- 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
- 
- 	if (off >= hdev->rsize)
- 		return 0;
- 
- 	if (off + count > hdev->rsize)
- 		count = hdev->rsize - off;
- 
- 	memcpy(buf, hdev->rdesc + off, count);
- 
- 	return count;
- }
- 
- static struct bin_attribute dev_bin_attr_report_desc = {
- 	.attr = { .name = "report_descriptor", .mode = 0444 },
- 	.read = read_report_descriptor,
- 	.size = HID_MAX_DESCRIPTOR_SIZE,
- };
- 
  int hid_connect(struct hid_device *hdev, unsigned int connect_mask)
  {
  	static const char *types[] = { "Device", "Pointer", "Mouse", "Device",
--- 1312,1317 ----
***************
*** 1578,1584 ****
  	char buf[64];
  	unsigned int i;
  	int len;
- 	int ret;
  
  	if (hdev->quirks & HID_QUIRK_HIDDEV_FORCE)
  		connect_mask |= (HID_CONNECT_HIDDEV_FORCE | HID_CONNECT_HIDDEV);
--- 1322,1327 ----
***************
*** 1600,1612 ****
  	if ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))
  		hdev->claimed |= HID_CLAIMED_HIDRAW;
  
! 	if (connect_mask & HID_CONNECT_DRIVER)
! 		hdev->claimed |= HID_CLAIMED_DRIVER;
! 
! 	/* Drivers with the ->raw_event callback set are not required to connect
! 	 * to any other listener. */
! 	if (!hdev->claimed && !hdev->driver->raw_event) {
! 		hid_err(hdev, "device has no listeners, quitting\n");
  		return -ENODEV;
  	}
  
--- 1343,1350 ----
  	if ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))
  		hdev->claimed |= HID_CLAIMED_HIDRAW;
  
! 	if (!hdev->claimed) {
! 		hid_err(hdev, "claimed by neither input, hiddev nor hidraw\n");
  		return -ENODEV;
  	}
  
***************
*** 1646,1656 ****
  		bus = "<UNKNOWN>";
  	}
  
- 	ret = device_create_bin_file(&hdev->dev, &dev_bin_attr_report_desc);
- 	if (ret)
- 		hid_warn(hdev,
- 			 "can't create sysfs report descriptor attribute err: %d\n", ret);
- 
  	hid_info(hdev, "%s: %s HID v%x.%02x %s [%s] on %s\n",
  		 buf, bus, hdev->version >> 8, hdev->version & 0xff,
  		 type, hdev->name, hdev->phys);
--- 1384,1389 ----
***************
*** 1661,1695 ****
  
  void hid_disconnect(struct hid_device *hdev)
  {
- 	device_remove_bin_file(&hdev->dev, &dev_bin_attr_report_desc);
  	if (hdev->claimed & HID_CLAIMED_INPUT)
  		hidinput_disconnect(hdev);
  	if (hdev->claimed & HID_CLAIMED_HIDDEV)
  		hdev->hiddev_disconnect(hdev);
  	if (hdev->claimed & HID_CLAIMED_HIDRAW)
  		hidraw_disconnect(hdev);
- 	hdev->claimed = 0;
  }
  EXPORT_SYMBOL_GPL(hid_disconnect);
  
! /*
!  * A list of devices for which there is a specialized driver on HID bus.
!  *
!  * Please note that for multitouch devices (driven by hid-multitouch driver),
!  * there is a proper autodetection and autoloading in place (based on presence
!  * of HID_DG_CONTACTID), so those devices don't need to be added to this list,
!  * as we are doing the right thing in hid_scan_usage().
!  *
!  * Autodetection for (USB) HID sensor hubs exists too. If a collection of type
!  * physical is found inside a usage page of type sensor, hid-sensor-hub will be
!  * used as a driver. See hid_scan_report().
!  */
  static const struct hid_device_id hid_have_special_driver[] = {
  	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_RP_649) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0x0802) },
! 	{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0xf705) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD) },
--- 1394,1416 ----
  
  void hid_disconnect(struct hid_device *hdev)
  {
  	if (hdev->claimed & HID_CLAIMED_INPUT)
  		hidinput_disconnect(hdev);
  	if (hdev->claimed & HID_CLAIMED_HIDDEV)
  		hdev->hiddev_disconnect(hdev);
  	if (hdev->claimed & HID_CLAIMED_HIDRAW)
  		hidraw_disconnect(hdev);
  }
  EXPORT_SYMBOL_GPL(hid_disconnect);
  
! /* a list of devices for which there is a specialized driver on HID bus */
  static const struct hid_device_id hid_have_special_driver[] = {
  	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_RP_649) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ACRUX, 0x0802) },
! 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ATV_IRCONTROL) },
! 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL4) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD) },
***************
*** 1713,1723 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL3) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL4) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL5) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS) },
--- 1434,1439 ----
***************
*** 1751,1779 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_AUREAL, USB_DEVICE_ID_AUREAL_W01RN) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_BELKIN, USB_DEVICE_ID_FLIP_KVM) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185BFM, 0x2208) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185PC, 0x5506) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185V2PC, 0x1850) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_BETOP_2185V2BFM, 0x5500) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE_2) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION) },
--- 1467,1480 ----
***************
*** 1781,1799 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_TACTICAL_PAD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_AK1D) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_PRODIKEYS_PCMIDI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_1) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_2) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_3) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_4) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_MOUSE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0006) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, 0x0011) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ELECOM, USB_DEVICE_ID_ELECOM_BM084) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0009) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ELO, 0x0030) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_EMS, USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_EZKEY, USB_DEVICE_ID_BTC_8193) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GAMERON, USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR) },
--- 1482,1495 ----
***************
*** 1804,1842 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_2) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_3) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK, USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A04A) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A067) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A070) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A072) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HOLTEK_ALT, USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_HUION, USB_DEVICE_ID_HUION_TABLET) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_JESS2, USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_ION, USB_DEVICE_ID_ICADE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_KENSINGTON, USB_DEVICE_ID_KS_SLIMBLADE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_KEYTOUCH, USB_DEVICE_ID_KEYTOUCH_IEC) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_MANTICORE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_GENIUS_GX_IMPERATOR) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_ERGO_525V) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_EASYPEN_I405X) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_MOUSEPEN_I608X) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_MOUSEPEN_I608X_2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_EASYPEN_M610X) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LABTEC, USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LCPOWER, USB_DEVICE_ID_LCPOWER_LC1000 ) },
- #if IS_ENABLED(CONFIG_HID_LENOVO)
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_TPKBD) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CUSBKBD) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LENOVO, USB_DEVICE_ID_LENOVO_CBTKBD) },
- #endif
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_MX3000_RECEIVER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER_2) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RECEIVER) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_HARMONY_PS3) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_T651) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_DESKTOP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_EDGE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_MINI) },
--- 1500,1514 ----
***************
*** 1853,1867 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFP_WHEEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFGT_WHEEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G25_WHEEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G27_WHEEL) },
- #if IS_ENABLED(CONFIG_HID_LOGITECH_DJ)
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2) },
- #endif
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WII_WHEEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACETRAVELLER) },
--- 1525,1536 ----
***************
*** 1871,1887 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_MOUSE_4500) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_SIDEWINDER_GV) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K_JP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE7K) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_LK6K) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_USB) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_OFFICE_KB) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3_JP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MONTEREY, USB_DEVICE_ID_GENIUS_KB29E) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MSI, USB_DEVICE_ID_MSI_GT683R_LED_PANEL) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2) },
--- 1540,1550 ----
***************
*** 1903,1954 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_PKB1700) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_WKB2000) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_PENMOUNT, USB_DEVICE_ID_PENMOUNT_6000) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PETALYNX, USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_PLANTRONICS, HID_ANY_ID) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PRIMAX, USB_DEVICE_ID_PRIMAX_KEYBOARD) },
! #if IS_ENABLED(CONFIG_HID_ROCCAT)
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ARVO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKU) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKUFX) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPLUS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPURE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPURE_OPTICAL) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEXTD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KOVAPLUS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_LUA) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRED) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK_GLOW) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_RYOS_MK_PRO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_SAVU) },
- #endif
- #if IS_ENABLED(CONFIG_HID_SAITEK)
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_PS1000) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7_OLD) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_RAT7) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAITEK, USB_DEVICE_ID_SAITEK_MMO7) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_RAT9) },
- #endif
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SMK, USB_DEVICE_ID_SMK_PS3_BDREMOTE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_BUZZ_CONTROLLER) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_BDREMOTE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS4_CONTROLLER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_STEELSERIES, USB_DEVICE_ID_STEELSERIES_SRWS1) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SUNPLUS, USB_DEVICE_ID_SUNPLUS_WDESKTOP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_THINGM, USB_DEVICE_ID_BLINK1) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb300) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb304) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb323) },
--- 1566,1589 ----
  	{ HID_USB_DEVICE(USB_VENDOR_ID_NTRIG, USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_PKB1700) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ORTEK, USB_DEVICE_ID_ORTEK_WKB2000) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PETALYNX, USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PRIMAX, USB_DEVICE_ID_PRIMAX_KEYBOARD) },
! 	{ HID_USB_DEVICE(USB_VENDOR_ID_QUANTA, USB_DEVICE_ID_PIXART_IMAGING_INC_OPTICAL_TOUCH_SCREEN) },
! 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ARVO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_ISKU) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KONEPLUS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_KOVAPLUS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRED) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_SUNPLUS, USB_DEVICE_ID_SUNPLUS_WDESKTOP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb300) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb304) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_THRUSTMASTER, 0xb323) },
***************
*** 1968,1997 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP1062) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SMARTJOY_PLUS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SUPER_JOY_BOX_3) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_DUAL_USB_JOYPAD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_DUAL_BOX_PRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_Q_PAD) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_PID_0038) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_X_TENSIONS, USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0005) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0030) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },
  
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE) },
- 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_RAZER, USB_DEVICE_ID_RAZER_BLADE_14) },
  	{ }
  };
  
--- 1603,1627 ----
  	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_TABLET_WP1062) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_UCLOGIC, USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_SMARTJOY_PLUS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_DUAL_USB_JOYPAD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_DUAL_BOX_PRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP_LTD, USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO) },
+ 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH) },
+ 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_WACOM, USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_X_TENSIONS, USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0005) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0030) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },
  
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT) },
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_NINTENDO, USB_DEVICE_ID_NINTENDO_WIIMOTE) },
  	{ }
  };
  
***************
*** 2028,2034 ****
  		return -ENOMEM;
  
  	dynid->id.bus = bus;
- 	dynid->id.group = HID_GROUP_ANY;
  	dynid->id.vendor = vendor;
  	dynid->id.product = product;
  	dynid->id.driver_data = driver_data;
--- 1658,1663 ----
***************
*** 2037,2045 ****
  	list_add_tail(&dynid->list, &hdrv->dyn_list);
  	spin_unlock(&hdrv->dyn_lock);
  
! 	ret = driver_attach(&hdrv->driver);
  
! 	return ret ? : count;
  }
  static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
  
--- 1666,1674 ----
  	list_add_tail(&dynid->list, &hdrv->dyn_list);
  	spin_unlock(&hdrv->dyn_lock);
  
! 	driver_attach(&hdrv->driver);
  
! 	return count;
  }
  static DRIVER_ATTR(new_id, S_IWUSR, NULL, store_new_id);
  
***************
*** 2090,2100 ****
  
  	if (down_interruptible(&hdev->driver_lock))
  		return -EINTR;
- 	if (down_interruptible(&hdev->driver_input_lock)) {
- 		ret = -EINTR;
- 		goto unlock_driver_lock;
- 	}
- 	hdev->io_started = false;
  
  	if (!hdev->driver) {
  		id = hid_match_device(hdev, hdrv);
--- 1719,1724 ----
***************
*** 2117,2125 ****
  		}
  	}
  unlock:
- 	if (!hdev->io_started)
- 		up(&hdev->driver_input_lock);
- unlock_driver_lock:
  	up(&hdev->driver_lock);
  	return ret;
  }
--- 1741,1746 ----
***************
*** 2128,2142 ****
  {
  	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
  	struct hid_driver *hdrv;
- 	int ret = 0;
  
  	if (down_interruptible(&hdev->driver_lock))
  		return -EINTR;
- 	if (down_interruptible(&hdev->driver_input_lock)) {
- 		ret = -EINTR;
- 		goto unlock_driver_lock;
- 	}
- 	hdev->io_started = false;
  
  	hdrv = hdev->driver;
  	if (hdrv) {
--- 1749,1757 ----
***************
*** 2148,2206 ****
  		hdev->driver = NULL;
  	}
  
- 	if (!hdev->io_started)
- 		up(&hdev->driver_input_lock);
- unlock_driver_lock:
  	up(&hdev->driver_lock);
! 	return ret;
! }
! 
! static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
! 			     char *buf)
! {
! 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
! 	int len;
! 
! 	len = snprintf(buf, PAGE_SIZE, "hid:b%04Xg%04Xv%08Xp%08X\n",
! 		       hdev->bus, hdev->group, hdev->vendor, hdev->product);
! 
! 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
  }
- static DEVICE_ATTR_RO(modalias);
  
- static struct attribute *hid_dev_attrs[] = {
- 	&dev_attr_modalias.attr,
- 	NULL,
- };
- ATTRIBUTE_GROUPS(hid_dev);
  
! static int hid_uevent(struct device *dev, struct kobj_uevent_env *env)
  {
- 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
- 
- 	if (add_uevent_var(env, "HID_ID=%04X:%08X:%08X",
- 			hdev->bus, hdev->vendor, hdev->product))
- 		return -ENOMEM;
- 
- 	if (add_uevent_var(env, "HID_NAME=%s", hdev->name))
- 		return -ENOMEM;
- 
- 	if (add_uevent_var(env, "HID_PHYS=%s", hdev->phys))
- 		return -ENOMEM;
- 
- 	if (add_uevent_var(env, "HID_UNIQ=%s", hdev->uniq))
- 		return -ENOMEM;
- 
- 	if (add_uevent_var(env, "MODALIAS=hid:b%04Xg%04Xv%08Xp%08X",
- 			   hdev->bus, hdev->group, hdev->vendor, hdev->product))
- 		return -ENOMEM;
- 
  	return 0;
  }
  
  static struct bus_type hid_bus_type = {
  	.name		= "hid",
- 	.dev_groups	= hid_dev_groups,
  	.match		= hid_bus_match,
  	.probe		= hid_device_probe,
  	.remove		= hid_device_remove,
--- 1763,1780 ----
  		hdev->driver = NULL;
  	}
  
  	up(&hdev->driver_lock);
! 	return 0;
  }
  
  
! static int hid_uevent(struct device *dev, char **envp, int num_envp, char *buffer, int buffer_size)
  {
  	return 0;
  }
  
  static struct bus_type hid_bus_type = {
  	.name		= "hid",
  	.match		= hid_bus_match,
  	.probe		= hid_device_probe,
  	.remove		= hid_device_remove,
***************
*** 2224,2234 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_LCM)},
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_LCM2)},
  	{ HID_USB_DEVICE(USB_VENDOR_ID_AVERMEDIA, USB_DEVICE_ID_AVER_FM_MR800) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_AXENTIA, USB_DEVICE_ID_AXENTIA_FM_RADIO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_BERKSHIRE, USB_DEVICE_ID_BERKSHIRE_PCWD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CIDC, 0x0103) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI470X) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_RADIO_SI4713) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CMEDIA, USB_DEVICE_ID_CM109) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_HIDCOM) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_ULTRAMOUSE) },
--- 1798,1806 ----
***************
*** 2257,2263 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GRETAGMACBETH, USB_DEVICE_ID_GRETAGMACBETH_HUEY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_POWERMATE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_SOUNDKNOB) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_GRIFFIN, USB_DEVICE_ID_RADIOSHARK) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_90) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_100) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_101) },
--- 1829,1834 ----
***************
*** 2305,2313 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1006) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_GTCO, USB_DEVICE_ID_GTCO_1007) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_IMATION, USB_DEVICE_ID_DISC_STAKKA) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_SPEAK_410) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_SPEAK_510) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_JABRA, USB_DEVICE_ID_JABRA_GN9350E) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_KBGEAR, USB_DEVICE_ID_KBGEAR_JAMSTUDIO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_KWORLD, USB_DEVICE_ID_KWORLD_RADIO_FM700) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_GPEN_560) },
--- 1876,1881 ----
***************
*** 2344,2355 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MCT) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HYBRID) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HEATCONTROL) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MADCATZ, USB_DEVICE_ID_MADCATZ_BEATPAD) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MCC, USB_DEVICE_ID_MCC_PMD1024LS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MCC, USB_DEVICE_ID_MCC_PMD1208LS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICKIT1) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICKIT2) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICK16F1454) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR, USB_DEVICE_ID_N_S_HARMONY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_ONTRAK, USB_DEVICE_ID_ONTRAK_ADU100 + 20) },
--- 1912,1921 ----
***************
*** 2367,2392 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0004) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PHILIPS, USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_POWERCOM, USB_DEVICE_ID_POWERCOM_UPS) },
- #if defined(CONFIG_MOUSE_SYNAPTICS_USB) || defined(CONFIG_MOUSE_SYNAPTICS_USB_MODULE)
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_TP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_INT_TP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_CPAD) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_STICK) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_WP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_COMP_TP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_WTP) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },
- #endif
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_LABPRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_GOTEMP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_SKIP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_CYCLOPS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_LCSPEC) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_4_PHIDGETSERVO_20) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_1_PHIDGETSERVO_20) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_8_8_4_IF_KIT) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_RISO_KAGAKU, USB_DEVICE_ID_RI_KA_WEBMAIL) },
  	{ }
  };
  
--- 1933,1948 ----
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PANJIT, 0x0004) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_PHILIPS, USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_POWERCOM, USB_DEVICE_ID_POWERCOM_UPS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_LABPRO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_GOTEMP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_SKIP) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_CYCLOPS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_VERNIER, USB_DEVICE_ID_VERNIER_LCSPEC) },
+ 	{ HID_USB_DEVICE(USB_VENDOR_ID_WACOM, HID_ANY_ID) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_4_PHIDGETSERVO_20) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_1_PHIDGETSERVO_20) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_8_8_4_IF_KIT) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
  	{ }
  };
  
***************
*** 2440,2466 ****
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO) },
- 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
  	{ }
  };
  
! bool hid_ignore(struct hid_device *hdev)
  {
- 	if (hdev->quirks & HID_QUIRK_NO_IGNORE)
- 		return false;
- 	if (hdev->quirks & HID_QUIRK_IGNORE)
- 		return true;
- 
  	switch (hdev->vendor) {
  	case USB_VENDOR_ID_CODEMERCS:
  		/* ignore all Code Mercenaries IOWarrior devices */
--- 1996,2008 ----
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
  	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
  	{ }
  };
  
! static bool hid_ignore(struct hid_device *hdev)
  {
  	switch (hdev->vendor) {
  	case USB_VENDOR_ID_CODEMERCS:
  		/* ignore all Code Mercenaries IOWarrior devices */
***************
*** 2472,2487 ****
  		if (hdev->product >= USB_DEVICE_ID_LOGITECH_HARMONY_FIRST &&
  				hdev->product <= USB_DEVICE_ID_LOGITECH_HARMONY_LAST)
  			return true;
- 		/*
- 		 * The Keene FM transmitter USB device has the same USB ID as
- 		 * the Logitech AudioHub Speaker, but it should ignore the hid.
- 		 * Check if the name is that of the Keene device.
- 		 * For reference: the name of the AudioHub is
- 		 * "HOLTEK  AudioHub Speaker".
- 		 */
- 		if (hdev->product == USB_DEVICE_ID_LOGITECH_AUDIOHUB &&
- 			!strcmp(hdev->name, "HOLTEK  B-LINK USB Audio  "))
- 				return true;
  		break;
  	case USB_VENDOR_ID_SOUNDGRAPH:
  		if (hdev->product >= USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST &&
--- 2014,2019 ----
***************
*** 2497,2523 ****
  		if (hdev->product == USB_DEVICE_ID_JESS_YUREX &&
  				hdev->type == HID_TYPE_USBNONE)
  			return true;
! 		break;
! 	case USB_VENDOR_ID_VELLEMAN:
! 		/* These are not HID devices.  They are handled by comedi. */
! 		if ((hdev->product >= USB_DEVICE_ID_VELLEMAN_K8055_FIRST &&
! 		     hdev->product <= USB_DEVICE_ID_VELLEMAN_K8055_LAST) ||
! 		    (hdev->product >= USB_DEVICE_ID_VELLEMAN_K8061_FIRST &&
! 		     hdev->product <= USB_DEVICE_ID_VELLEMAN_K8061_LAST))
! 			return true;
! 		break;
! 	case USB_VENDOR_ID_ATMEL_V_USB:
! 		/* Masterkit MA901 usb radio based on Atmel tiny85 chip and
! 		 * it has the same USB ID as many Atmel V-USB devices. This
! 		 * usb radio is handled by radio-ma901.c driver so we want
! 		 * ignore the hid. Check the name, bus, product and ignore
! 		 * if we have MA901 usb radio.
! 		 */
! 		if (hdev->product == USB_DEVICE_ID_ATMEL_V_USB &&
! 			hdev->bus == BUS_USB &&
! 			strncmp(hdev->name, "www.masterkit.ru MA901", 22) == 0)
! 			return true;
! 		break;
  	}
  
  	if (hdev->type == HID_TYPE_USBMOUSE &&
--- 2029,2035 ----
  		if (hdev->product == USB_DEVICE_ID_JESS_YUREX &&
  				hdev->type == HID_TYPE_USBNONE)
  			return true;
! 	break;
  	}
  
  	if (hdev->type == HID_TYPE_USBMOUSE &&
***************
*** 2526,2532 ****
  
  	return !!hid_match_id(hdev, hid_ignore_list);
  }
- EXPORT_SYMBOL_GPL(hid_ignore);
  
  int hid_add_device(struct hid_device *hdev)
  {
--- 2038,2043 ----
***************
*** 2538,2555 ****
  
  	/* we need to kill them here, otherwise they will stay allocated to
  	 * wait for coming driver */
! 	if (hid_ignore(hdev))
  		return -ENODEV;
  
  	/*
- 	 * Check for the mandatory transport channel.
- 	 */
- 	 if (!hdev->ll_driver->raw_request) {
- 		hid_err(hdev, "transport driver missing .raw_request()\n");
- 		return -EINVAL;
- 	 }
- 
- 	/*
  	 * Read the device report descriptor once and use as template
  	 * for the driver-specific modifications.
  	 */
--- 2049,2059 ----
  
  	/* we need to kill them here, otherwise they will stay allocated to
  	 * wait for coming driver */
! 	if (!(hdev->quirks & HID_QUIRK_NO_IGNORE)
!             && (hid_ignore(hdev) || (hdev->quirks & HID_QUIRK_IGNORE)))
  		return -ENODEV;
  
  	/*
  	 * Read the device report descriptor once and use as template
  	 * for the driver-specific modifications.
  	 */
***************
*** 2563,2570 ****
  	 * Scan generic devices for group information
  	 */
  	if (hid_ignore_special_drivers ||
! 	    (!hdev->group &&
! 	     !hid_match_id(hdev, hid_have_special_driver))) {
  		ret = hid_scan_report(hdev);
  		if (ret)
  			hid_warn(hdev, "bad device descriptor (%d)\n", ret);
--- 2067,2073 ----
  	 * Scan generic devices for group information
  	 */
  	if (hid_ignore_special_drivers ||
! 	    !hid_match_id(hdev, hid_have_special_driver)) {
  		ret = hid_scan_report(hdev);
  		if (ret)
  			hid_warn(hdev, "bad device descriptor (%d)\n", ret);
***************
*** 2572,2579 ****
  
  	/* XXX hack, any other cleaner solution after the driver core
  	 * is converted to allow more than 20 bytes as the device name? */
! 	dev_set_name(&hdev->dev, "%04X:%04X:%04X.%04X", hdev->bus,
! 		     hdev->vendor, hdev->product, atomic_inc_return(&id));
  
  	hid_debug_register(hdev, dev_name(&hdev->dev));
  	ret = device_add(&hdev->dev);
--- 2075,2081 ----
  
  	/* XXX hack, any other cleaner solution after the driver core
  	 * is converted to allow more than 20 bytes as the device name? */
! 	dev_set_name(&hdev->dev, "hv_mouse%d", atomic_inc_return(&id));
  
  	hid_debug_register(hdev, dev_name(&hdev->dev));
  	ret = device_add(&hdev->dev);
***************
*** 2612,2620 ****
  
  	init_waitqueue_head(&hdev->debug_wait);
  	INIT_LIST_HEAD(&hdev->debug_list);
- 	spin_lock_init(&hdev->debug_list_lock);
  	sema_init(&hdev->driver_lock, 1);
- 	sema_init(&hdev->driver_input_lock, 1);
  
  	return hdev;
  }
--- 2114,2120 ----
***************
*** 2655,2661 ****
  	hdrv->driver.name = hdrv->name;
  	hdrv->driver.bus = &hid_bus_type;
  	hdrv->driver.owner = owner;
- 	hdrv->driver.mod_name = mod_name;
  
  	INIT_LIST_HEAD(&hdrv->dyn_list);
  	spin_lock_init(&hdrv->dyn_lock);
--- 2155,2160 ----
diff -crB ln12Mar/hv/hid-debug.c hv-rhel7.x/hv/hid-debug.c
*** ln12Mar/hv/hid-debug.c	2015-05-14 08:56:46.641249948 -0700
--- hv-rhel7.x/hv/hid-debug.c	2015-05-14 07:05:22.417084932 -0700
***************
*** 31,37 ****
  #include <linux/debugfs.h>
  #include <linux/seq_file.h>
  #include <linux/sched.h>
- #include <linux/export.h>
  #include <linux/slab.h>
  #include <linux/uaccess.h>
  #include <linux/poll.h>
--- 31,36 ----
***************
*** 165,172 ****
      {0, 0x53, "DeviceIndex"},
      {0, 0x54, "ContactCount"},
      {0, 0x55, "ContactMaximumNumber"},
-     {0, 0x5A, "SecondaryBarrelSwitch"},
-     {0, 0x5B, "TransducerSerialNumber"},
    { 15, 0, "PhysicalInterfaceDevice" },
      {0, 0x00, "Undefined"},
      {0, 0x01, "Physical_Interface_Device"},
--- 164,169 ----
***************
*** 274,358 ****
      {0, 0xAA, "Shared_Parameter_Blocks"},
      {0, 0xAB, "Create_New_Effect_Report"},
      {0, 0xAC, "RAM_Pool_Available"},
-   {  0x20, 0, "Sensor" },
-     { 0x20, 0x01, "Sensor" },
-     { 0x20, 0x10, "Biometric" },
-       { 0x20, 0x11, "BiometricHumanPresence" },
-       { 0x20, 0x12, "BiometricHumanProximity" },
-       { 0x20, 0x13, "BiometricHumanTouch" },
-     { 0x20, 0x20, "Electrical" },
-       { 0x20, 0x21, "ElectricalCapacitance" },
-       { 0x20, 0x22, "ElectricalCurrent" },
-       { 0x20, 0x23, "ElectricalPower" },
-       { 0x20, 0x24, "ElectricalInductance" },
-       { 0x20, 0x25, "ElectricalResistance" },
-       { 0x20, 0x26, "ElectricalVoltage" },
-       { 0x20, 0x27, "ElectricalPoteniometer" },
-       { 0x20, 0x28, "ElectricalFrequency" },
-       { 0x20, 0x29, "ElectricalPeriod" },
-     { 0x20, 0x30, "Environmental" },
-       { 0x20, 0x31, "EnvironmentalAtmosphericPressure" },
-       { 0x20, 0x32, "EnvironmentalHumidity" },
-       { 0x20, 0x33, "EnvironmentalTemperature" },
-       { 0x20, 0x34, "EnvironmentalWindDirection" },
-       { 0x20, 0x35, "EnvironmentalWindSpeed" },
-     { 0x20, 0x40, "Light" },
-       { 0x20, 0x41, "LightAmbientLight" },
-       { 0x20, 0x42, "LightConsumerInfrared" },
-     { 0x20, 0x50, "Location" },
-       { 0x20, 0x51, "LocationBroadcast" },
-       { 0x20, 0x52, "LocationDeadReckoning" },
-       { 0x20, 0x53, "LocationGPS" },
-       { 0x20, 0x54, "LocationLookup" },
-       { 0x20, 0x55, "LocationOther" },
-       { 0x20, 0x56, "LocationStatic" },
-       { 0x20, 0x57, "LocationTriangulation" },
-     { 0x20, 0x60, "Mechanical" },
-       { 0x20, 0x61, "MechanicalBooleanSwitch" },
-       { 0x20, 0x62, "MechanicalBooleanSwitchArray" },
-       { 0x20, 0x63, "MechanicalMultivalueSwitch" },
-       { 0x20, 0x64, "MechanicalForce" },
-       { 0x20, 0x65, "MechanicalPressure" },
-       { 0x20, 0x66, "MechanicalStrain" },
-       { 0x20, 0x67, "MechanicalWeight" },
-       { 0x20, 0x68, "MechanicalHapticVibrator" },
-       { 0x20, 0x69, "MechanicalHallEffectSwitch" },
-     { 0x20, 0x70, "Motion" },
-       { 0x20, 0x71, "MotionAccelerometer1D" },
-       { 0x20, 0x72, "MotionAccelerometer2D" },
-       { 0x20, 0x73, "MotionAccelerometer3D" },
-       { 0x20, 0x74, "MotionGyrometer1D" },
-       { 0x20, 0x75, "MotionGyrometer2D" },
-       { 0x20, 0x76, "MotionGyrometer3D" },
-       { 0x20, 0x77, "MotionMotionDetector" },
-       { 0x20, 0x78, "MotionSpeedometer" },
-       { 0x20, 0x79, "MotionAccelerometer" },
-       { 0x20, 0x7A, "MotionGyrometer" },
-     { 0x20, 0x80, "Orientation" },
-       { 0x20, 0x81, "OrientationCompass1D" },
-       { 0x20, 0x82, "OrientationCompass2D" },
-       { 0x20, 0x83, "OrientationCompass3D" },
-       { 0x20, 0x84, "OrientationInclinometer1D" },
-       { 0x20, 0x85, "OrientationInclinometer2D" },
-       { 0x20, 0x86, "OrientationInclinometer3D" },
-       { 0x20, 0x87, "OrientationDistance1D" },
-       { 0x20, 0x88, "OrientationDistance2D" },
-       { 0x20, 0x89, "OrientationDistance3D" },
-       { 0x20, 0x8A, "OrientationDeviceOrientation" },
-       { 0x20, 0x8B, "OrientationCompass" },
-       { 0x20, 0x8C, "OrientationInclinometer" },
-       { 0x20, 0x8D, "OrientationDistance" },
-     { 0x20, 0x90, "Scanner" },
-       { 0x20, 0x91, "ScannerBarcode" },
-       { 0x20, 0x91, "ScannerRFID" },
-       { 0x20, 0x91, "ScannerNFC" },
-     { 0x20, 0xA0, "Time" },
-       { 0x20, 0xA1, "TimeAlarmTimer" },
-       { 0x20, 0xA2, "TimeRealTimeClock" },
-     { 0x20, 0xE0, "Other" },
-       { 0x20, 0xE1, "OtherCustom" },
-       { 0x20, 0xE2, "OtherGeneric" },
-       { 0x20, 0xE3, "OtherGenericEnumerator" },
    { 0x84, 0, "Power Device" },
      { 0x84, 0x02, "PresentStatus" },
      { 0x84, 0x03, "ChangeStatus" },
--- 271,276 ----
***************
*** 660,710 ****
  {
  	int i;
  	struct hid_debug_list *list;
- 	unsigned long flags;
  
- 	spin_lock_irqsave(&hdev->debug_list_lock, flags);
  	list_for_each_entry(list, &hdev->debug_list, node) {
  		for (i = 0; i < strlen(buf); i++)
  			list->hid_debug_buf[(list->tail + i) % HID_DEBUG_BUFSIZE] =
  				buf[i];
  		list->tail = (list->tail + i) % HID_DEBUG_BUFSIZE;
          }
- 	spin_unlock_irqrestore(&hdev->debug_list_lock, flags);
  
  	wake_up_interruptible(&hdev->debug_wait);
  }
  EXPORT_SYMBOL_GPL(hid_debug_event);
  
- void hid_dump_report(struct hid_device *hid, int type, u8 *data,
- 		int size)
- {
- 	struct hid_report_enum *report_enum;
- 	char *buf;
- 	unsigned int i;
- 
- 	buf = kmalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_ATOMIC);
- 
- 	if (!buf)
- 		return;
- 
- 	report_enum = hid->report_enum + type;
- 
- 	/* dump the report */
- 	snprintf(buf, HID_DEBUG_BUFSIZE - 1,
- 			"\nreport (size %u) (%snumbered) = ", size,
- 			report_enum->numbered ? "" : "un");
- 	hid_debug_event(hid, buf);
- 
- 	for (i = 0; i < size; i++) {
- 		snprintf(buf, HID_DEBUG_BUFSIZE - 1,
- 				" %02x", data[i]);
- 		hid_debug_event(hid, buf);
- 	}
- 	hid_debug_event(hid, "\n");
- 	kfree(buf);
- }
- EXPORT_SYMBOL_GPL(hid_dump_report);
- 
  void hid_dump_input(struct hid_device *hdev, struct hid_usage *usage, __s32 value)
  {
  	char *buf;
--- 578,595 ----
***************
*** 849,856 ****
  	[KEY_ALTERASE] = "AlternateErase",	[KEY_CANCEL] = "Cancel",
  	[KEY_BRIGHTNESSDOWN] = "BrightnessDown", [KEY_BRIGHTNESSUP] = "BrightnessUp",
  	[KEY_MEDIA] = "Media",			[KEY_UNKNOWN] = "Unknown",
- 	[BTN_DPAD_UP] = "BtnDPadUp",		[BTN_DPAD_DOWN] = "BtnDPadDown",
- 	[BTN_DPAD_LEFT] = "BtnDPadLeft",	[BTN_DPAD_RIGHT] = "BtnDPadRight",
  	[BTN_0] = "Btn0",			[BTN_1] = "Btn1",
  	[BTN_2] = "Btn2",			[BTN_3] = "Btn3",
  	[BTN_4] = "Btn4",			[BTN_5] = "Btn5",
--- 734,739 ----
***************
*** 880,887 ****
  	[BTN_TOOL_MOUSE] = "ToolMouse",		[BTN_TOOL_LENS] = "ToolLens",
  	[BTN_TOUCH] = "Touch",			[BTN_STYLUS] = "Stylus",
  	[BTN_STYLUS2] = "Stylus2",		[BTN_TOOL_DOUBLETAP] = "ToolDoubleTap",
! 	[BTN_TOOL_TRIPLETAP] = "ToolTripleTap",	[BTN_TOOL_QUADTAP] = "ToolQuadrupleTap",
! 	[BTN_GEAR_DOWN] = "WheelBtn",
  	[BTN_GEAR_UP] = "Gear up",		[KEY_OK] = "Ok",
  	[KEY_SELECT] = "Select",		[KEY_GOTO] = "Goto",
  	[KEY_CLEAR] = "Clear",			[KEY_POWER2] = "Power2",
--- 763,769 ----
  	[BTN_TOOL_MOUSE] = "ToolMouse",		[BTN_TOOL_LENS] = "ToolLens",
  	[BTN_TOUCH] = "Touch",			[BTN_STYLUS] = "Stylus",
  	[BTN_STYLUS2] = "Stylus2",		[BTN_TOOL_DOUBLETAP] = "ToolDoubleTap",
! 	[BTN_TOOL_TRIPLETAP] = "ToolTripleTap", [BTN_GEAR_DOWN] = "WheelBtn",
  	[BTN_GEAR_UP] = "Gear up",		[KEY_OK] = "Ok",
  	[KEY_SELECT] = "Select",		[KEY_GOTO] = "Goto",
  	[KEY_CLEAR] = "Clear",			[KEY_POWER2] = "Power2",
***************
*** 936,957 ****
  	[KEY_KBDILLUMDOWN] = "KbdIlluminationDown",
  	[KEY_KBDILLUMUP] = "KbdIlluminationUp",
  	[KEY_SWITCHVIDEOMODE] = "SwitchVideoMode",
- 	[KEY_BUTTONCONFIG] = "ButtonConfig",
- 	[KEY_TASKMANAGER] = "TaskManager",
- 	[KEY_JOURNAL] = "Journal",
- 	[KEY_CONTROLPANEL] = "ControlPanel",
- 	[KEY_APPSELECT] = "AppSelect",
- 	[KEY_SCREENSAVER] = "ScreenSaver",
- 	[KEY_VOICECOMMAND] = "VoiceCommand",
- 	[KEY_BRIGHTNESS_MIN] = "BrightnessMin",
- 	[KEY_BRIGHTNESS_MAX] = "BrightnessMax",
- 	[KEY_BRIGHTNESS_AUTO] = "BrightnessAuto",
- 	[KEY_KBDINPUTASSIST_PREV] = "KbdInputAssistPrev",
- 	[KEY_KBDINPUTASSIST_NEXT] = "KbdInputAssistNext",
- 	[KEY_KBDINPUTASSIST_PREVGROUP] = "KbdInputAssistPrevGroup",
- 	[KEY_KBDINPUTASSIST_NEXTGROUP] = "KbdInputAssistNextGroup",
- 	[KEY_KBDINPUTASSIST_ACCEPT] = "KbdInputAssistAccept",
- 	[KEY_KBDINPUTASSIST_CANCEL] = "KbdInputAssistCancel",
  };
  
  static const char *relatives[REL_MAX + 1] = {
--- 818,823 ----
***************
*** 1047,1064 ****
  static int hid_debug_rdesc_show(struct seq_file *f, void *p)
  {
  	struct hid_device *hdev = f->private;
- 	const __u8 *rdesc = hdev->rdesc;
- 	unsigned rsize = hdev->rsize;
  	int i;
  
- 	if (!rdesc) {
- 		rdesc = hdev->dev_rdesc;
- 		rsize = hdev->dev_rsize;
- 	}
- 
  	/* dump HID report descriptor */
! 	for (i = 0; i < rsize; i++)
! 		seq_printf(f, "%02x ", rdesc[i]);
  	seq_printf(f, "\n\n");
  
  	/* dump parsed data and input mappings */
--- 914,924 ----
  static int hid_debug_rdesc_show(struct seq_file *f, void *p)
  {
  	struct hid_device *hdev = f->private;
  	int i;
  
  	/* dump HID report descriptor */
! 	for (i = 0; i < hdev->rsize; i++)
! 		seq_printf(f, "%02x ", hdev->rdesc[i]);
  	seq_printf(f, "\n\n");
  
  	/* dump parsed data and input mappings */
***************
*** 1078,1084 ****
  {
  	int err = 0;
  	struct hid_debug_list *list;
- 	unsigned long flags;
  
  	if (!(list = kzalloc(sizeof(struct hid_debug_list), GFP_KERNEL))) {
  		err = -ENOMEM;
--- 938,943 ----
***************
*** 1094,1102 ****
  	file->private_data = list;
  	mutex_init(&list->read_mutex);
  
- 	spin_lock_irqsave(&list->hdev->debug_list_lock, flags);
  	list_add_tail(&list->node, &list->hdev->debug_list);
- 	spin_unlock_irqrestore(&list->hdev->debug_list_lock, flags);
  
  out:
  	return err;
--- 953,959 ----
***************
*** 1190,1200 ****
  static int hid_debug_events_release(struct inode *inode, struct file *file)
  {
  	struct hid_debug_list *list = file->private_data;
- 	unsigned long flags;
  
- 	spin_lock_irqsave(&list->hdev->debug_list_lock, flags);
  	list_del(&list->node);
- 	spin_unlock_irqrestore(&list->hdev->debug_list_lock, flags);
  	kfree(list->hid_debug_buf);
  	kfree(list);
  
--- 1047,1054 ----
***************
*** 1214,1220 ****
  	.read           = hid_debug_events_read,
  	.poll		= hid_debug_events_poll,
  	.release        = hid_debug_events_release,
- 	.llseek		= noop_llseek,
  };
  
  
--- 1068,1073 ----
***************
*** 1244,1249 ****
  
  void hid_debug_exit(void)
  {
! 	debugfs_remove_recursive(hid_debug_root);
  }
- 
--- 1097,1103 ----
  
  void hid_debug_exit(void)
  {
! 	/*
! 	 * TBD KYS
! 	 */
  }
diff -crB ln12Mar/hv/hid-hyperv.c hv-rhel7.x/hv/hid-hyperv.c
*** ln12Mar/hv/hid-hyperv.c	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/hid-hyperv.c	2015-05-14 07:05:22.417084932 -0700
***************
*** 19,25 ****
  #include <linux/input.h>
  #include <linux/hid.h>
  #include <linux/hiddev.h>
! #include <linux/hyperv.h>
  
  
  struct hv_input_dev_info {
--- 19,25 ----
  #include <linux/input.h>
  #include <linux/hid.h>
  #include <linux/hiddev.h>
! #include "include/linux/hyperv.h"
  
  
  struct hv_input_dev_info {
***************
*** 463,476 ****
  {
  }
  
! static int mousevsc_hid_raw_request(struct hid_device *hid,
! 				    unsigned char report_num,
! 				    __u8 *buf, size_t len,
! 				    unsigned char rtype,
! 				    int reqtype)
! {
! 	return 0;
! }
  
  static struct hid_ll_driver mousevsc_ll_driver = {
  	.parse = mousevsc_hid_parse,
--- 463,476 ----
  {
  }
  
! //static int mousevsc_hid_raw_request(struct hid_device *hid,
! //				    unsigned char report_num,
! //				    __u8 *buf, size_t len,
! //				    unsigned char rtype,
! //				    int reqtype)
! //{
! //	return 0;
! //}
  
  static struct hid_ll_driver mousevsc_ll_driver = {
  	.parse = mousevsc_hid_parse,
***************
*** 478,484 ****
  	.close = mousevsc_hid_close,
  	.start = mousevsc_hid_start,
  	.stop = mousevsc_hid_stop,
! 	.raw_request = mousevsc_hid_raw_request,
  };
  
  static struct hid_driver mousevsc_hid_driver;
--- 478,484 ----
  	.close = mousevsc_hid_close,
  	.start = mousevsc_hid_start,
  	.stop = mousevsc_hid_stop,
! 	//.raw_request = mousevsc_hid_raw_request,
  };
  
  static struct hid_driver mousevsc_hid_driver;
***************
*** 611,615 ****
--- 611,617 ----
  }
  
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
+ 
  module_init(mousevsc_init);
  module_exit(mousevsc_exit);
diff -crB ln12Mar/hv/hid-ids.h hv-rhel7.x/hv/hid-ids.h
*** ln12Mar/hv/hid-ids.h	2015-05-14 08:56:52.188497315 -0700
--- hv-rhel7.x/hv/hid-ids.h	2015-05-14 07:05:22.417084932 -0700
***************
*** 5,10 ****
--- 5,11 ----
   *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
   *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
   *  Copyright (c) 2006-2007 Jiri Kosina
+  *  Copyright (c) 2007 Paul Walmsley
   */
  
  /*
***************
*** 67,75 ****
  #define USB_VENDOR_ID_ALPS		0x0433
  #define USB_DEVICE_ID_IBM_GAMEPAD	0x1101
  
- #define USB_VENDOR_ID_ANTON		0x1130
- #define USB_DEVICE_ID_ANTON_TOUCH_PAD	0x3101
- 
  #define USB_VENDOR_ID_APPLE		0x05ac
  #define USB_DEVICE_ID_APPLE_MIGHTYMOUSE	0x0304
  #define USB_DEVICE_ID_APPLE_MAGICMOUSE	0x030d
--- 68,73 ----
***************
*** 121,154 ****
  #define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI	0x0252
  #define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO	0x0253
  #define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS	0x0254
- #define USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI	0x0259
- #define USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO	0x025a
- #define USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS	0x025b
  #define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI	0x0249
  #define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO	0x024a
  #define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS	0x024b
  #define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI	0x024c
  #define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO	0x024d
  #define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS	0x024e
- #define USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI	0x0262
- #define USB_DEVICE_ID_APPLE_WELLSPRING7_ISO	0x0263
- #define USB_DEVICE_ID_APPLE_WELLSPRING7_JIS	0x0264
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI  0x0255
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256
- #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS   0x0257
- #define USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI	0x0290
- #define USB_DEVICE_ID_APPLE_WELLSPRING8_ISO	0x0291
- #define USB_DEVICE_ID_APPLE_WELLSPRING8_JIS	0x0292
  #define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
  #define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
! #define USB_DEVICE_ID_APPLE_IRCONTROL	0x8240
! #define USB_DEVICE_ID_APPLE_IRCONTROL2	0x1440
! #define USB_DEVICE_ID_APPLE_IRCONTROL3	0x8241
  #define USB_DEVICE_ID_APPLE_IRCONTROL4	0x8242
- #define USB_DEVICE_ID_APPLE_IRCONTROL5	0x8243
  
  #define USB_VENDOR_ID_ASUS		0x0486
  #define USB_DEVICE_ID_ASUS_T91MT	0x0185
--- 119,139 ----
  #define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI	0x0252
  #define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO	0x0253
  #define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS	0x0254
  #define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI	0x0249
  #define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO	0x024a
  #define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS	0x024b
  #define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI	0x024c
  #define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO	0x024d
  #define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS	0x024e
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI  0x0255
  #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256
  #define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
  #define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
! #define USB_DEVICE_ID_APPLE_ATV_IRCONTROL	0x8241
  #define USB_DEVICE_ID_APPLE_IRCONTROL4	0x8242
  
  #define USB_VENDOR_ID_ASUS		0x0486
  #define USB_DEVICE_ID_ASUS_T91MT	0x0185
***************
*** 168,175 ****
  #define USB_VENDOR_ID_ATMEL		0x03eb
  #define USB_DEVICE_ID_ATMEL_MULTITOUCH	0x211c
  #define USB_DEVICE_ID_ATMEL_MXT_DIGITIZER	0x2118
- #define USB_VENDOR_ID_ATMEL_V_USB	0x16c0
- #define USB_DEVICE_ID_ATMEL_V_USB	0x05df
  
  #define USB_VENDOR_ID_AUREAL		0x0755
  #define USB_DEVICE_ID_AUREAL_W01RN	0x2626
--- 153,158 ----
***************
*** 177,185 ****
  #define USB_VENDOR_ID_AVERMEDIA		0x07ca
  #define USB_DEVICE_ID_AVER_FM_MR800	0xb800
  
- #define USB_VENDOR_ID_AXENTIA		0x12cf
- #define USB_DEVICE_ID_AXENTIA_FM_RADIO	0x7111
- 
  #define USB_VENDOR_ID_BAANTO		0x2453
  #define USB_DEVICE_ID_BAANTO_MT_190W2	0x0100
  
--- 160,165 ----
***************
*** 189,199 ****
  #define USB_VENDOR_ID_BERKSHIRE		0x0c98
  #define USB_DEVICE_ID_BERKSHIRE_PCWD	0x1140
  
- #define USB_VENDOR_ID_BETOP_2185BFM	0x11c2
- #define USB_VENDOR_ID_BETOP_2185PC	0x11c0
- #define USB_VENDOR_ID_BETOP_2185V2PC	0x8380
- #define USB_VENDOR_ID_BETOP_2185V2BFM	0x20bc
- 
  #define USB_VENDOR_ID_BTC		0x046e
  #define USB_DEVICE_ID_BTC_EMPREX_REMOTE	0x5578
  #define USB_DEVICE_ID_BTC_EMPREX_REMOTE_2	0x5577
--- 169,174 ----
***************
*** 227,233 ****
  #define USB_DEVICE_ID_CHICONY_MULTI_TOUCH	0xb19d
  #define USB_DEVICE_ID_CHICONY_WIRELESS	0x0618
  #define USB_DEVICE_ID_CHICONY_WIRELESS2	0x1123
- #define USB_DEVICE_ID_CHICONY_AK1D	0x1125
  
  #define USB_VENDOR_ID_CHUNGHWAT		0x2247
  #define USB_DEVICE_ID_CHUNGHWAT_MULTITOUCH	0x0001
--- 202,207 ----
***************
*** 249,258 ****
  
  #define USB_VENDOR_ID_CYGNAL		0x10c4
  #define USB_DEVICE_ID_CYGNAL_RADIO_SI470X	0x818a
- #define USB_DEVICE_ID_FOCALTECH_FTXXXX_MULTITOUCH	0x81b9
- #define USB_DEVICE_ID_CYGNAL_CP2112	0xea90
- 
- #define USB_DEVICE_ID_CYGNAL_RADIO_SI4713       0x8244
  
  #define USB_VENDOR_ID_CYPRESS		0x04b4
  #define USB_DEVICE_ID_CYPRESS_MOUSE	0x0001
--- 223,228 ----
***************
*** 261,272 ****
  #define USB_DEVICE_ID_CYPRESS_BARCODE_1	0xde61
  #define USB_DEVICE_ID_CYPRESS_BARCODE_2	0xde64
  #define USB_DEVICE_ID_CYPRESS_BARCODE_3	0xbca1
- #define USB_DEVICE_ID_CYPRESS_BARCODE_4	0xed81
  #define USB_DEVICE_ID_CYPRESS_TRUETOUCH	0xc001
  
- #define USB_VENDOR_ID_DATA_MODUL	0x7374
- #define USB_VENDOR_ID_DATA_MODUL_EASYMAXTOUCH	0x1201
- 
  #define USB_VENDOR_ID_DEALEXTREAME	0x10c5
  #define USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701	0x819a
  
--- 231,238 ----
***************
*** 281,287 ****
  
  #define USB_VENDOR_ID_DWAV		0x0eef
  #define USB_DEVICE_ID_EGALAX_TOUCHCONTROLLER	0x0001
- #define USB_DEVICE_ID_DWAV_TOUCHCONTROLLER	0x0002
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480D	0x480d
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480E	0x480e
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7207	0x7207
--- 247,252 ----
***************
*** 291,321 ****
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E	0x725e
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262	0x7262
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B	0x726b
- #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1	0x72a1
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA	0x72aa
! #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72C4	0x72c4
! #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72D0	0x72d0
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA	0x72fa
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302	0x7302
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349	0x7349
- #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_73F7	0x73f7
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001	0xa001
  
- #define USB_VENDOR_ID_ELAN		0x04f3
- #define USB_DEVICE_ID_ELAN_TOUCHSCREEN	0x0089
- #define USB_DEVICE_ID_ELAN_TOUCHSCREEN_009B	0x009b
- #define USB_DEVICE_ID_ELAN_TOUCHSCREEN_0103	0x0103
- #define USB_DEVICE_ID_ELAN_TOUCHSCREEN_010c	0x010c
- #define USB_DEVICE_ID_ELAN_TOUCHSCREEN_016F	0x016f
- 
  #define USB_VENDOR_ID_ELECOM		0x056e
  #define USB_DEVICE_ID_ELECOM_BM084	0x0061
  
  #define USB_VENDOR_ID_DREAM_CHEEKY	0x1d34
  
- #define USB_VENDOR_ID_ELITEGROUP	0x03fc
- #define USB_DEVICE_ID_ELITEGROUP_05D8	0x05d8
- 
  #define USB_VENDOR_ID_ELO		0x04E7
  #define USB_DEVICE_ID_ELO_TS2515	0x0022
  #define USB_DEVICE_ID_ELO_TS2700	0x0020
--- 256,273 ----
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E	0x725e
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262	0x7262
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B	0x726b
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA	0x72aa
! #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1	0x72a1
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA	0x72fa
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302	0x7302
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349	0x7349
  #define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001	0xa001
  
  #define USB_VENDOR_ID_ELECOM		0x056e
  #define USB_DEVICE_ID_ELECOM_BM084	0x0061
  
  #define USB_VENDOR_ID_DREAM_CHEEKY	0x1d34
  
  #define USB_VENDOR_ID_ELO		0x04E7
  #define USB_DEVICE_ID_ELO_TS2515	0x0022
  #define USB_DEVICE_ID_ELO_TS2700	0x0020
***************
*** 323,331 ****
  #define USB_VENDOR_ID_EMS		0x2006
  #define USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II 0x0118
  
- #define USB_VENDOR_ID_FLATFROG		0x25b5
- #define USB_DEVICE_ID_MULTITOUCH_3200	0x0002
- 
  #define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
  #define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
  
--- 275,280 ----
***************
*** 335,351 ****
  
  #define USB_VENDOR_ID_ETURBOTOUCH	0x22b9
  #define USB_DEVICE_ID_ETURBOTOUCH	0x0006
- #define USB_DEVICE_ID_ETURBOTOUCH_2968	0x2968
  
  #define USB_VENDOR_ID_EZKEY		0x0518
  #define USB_DEVICE_ID_BTC_8193		0x0002
  
- #define USB_VENDOR_ID_FORMOSA          0x147a
- #define USB_DEVICE_ID_FORMOSA_IR_RECEIVER      0xe03e
- 
- #define USB_VENDOR_ID_FREESCALE		0x15A2
- #define USB_DEVICE_ID_FREESCALE_MX28	0x004F
- 
  #define USB_VENDOR_ID_FRUCTEL	0x25B6
  #define USB_DEVICE_ID_GAMETEL_MT_MODE	0x0002
  
--- 284,293 ----
***************
*** 355,366 ****
  
  #define USB_VENDOR_ID_GENERAL_TOUCH	0x0dfc
  #define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0003
- #define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PWT_TENFINGERS 0x0100
- #define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0101 0x0101
- #define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0102 0x0102
- #define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0106 0x0106
- #define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_010A 0x010a
- #define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_E100 0xe100
  
  #define USB_VENDOR_ID_GLAB		0x06c2
  #define USB_DEVICE_ID_4_PHIDGETSERVO_30	0x0038
--- 297,302 ----
***************
*** 389,395 ****
  #define USB_VENDOR_ID_GRIFFIN		0x077d
  #define USB_DEVICE_ID_POWERMATE		0x0410
  #define USB_DEVICE_ID_SOUNDKNOB		0x04AA
- #define USB_DEVICE_ID_RADIOSHARK	0x627a
  
  #define USB_VENDOR_ID_GTCO		0x078c
  #define USB_DEVICE_ID_GTCO_90		0x0090
--- 325,330 ----
***************
*** 459,467 ****
  #define USB_DEVICE_ID_UGCI_FLYING	0x0020
  #define USB_DEVICE_ID_UGCI_FIGHTING	0x0030
  
- #define USB_VENDOR_ID_HUION		0x256c
- #define USB_DEVICE_ID_HUION_TABLET	0x006e
- 
  #define USB_VENDOR_ID_IDEACOM		0x1cb6
  #define USB_DEVICE_ID_IDEACOM_IDC6650	0x6650
  #define USB_DEVICE_ID_IDEACOM_IDC6651	0x6651
--- 394,399 ----
***************
*** 469,516 ****
  #define USB_VENDOR_ID_ILITEK		0x222a
  #define USB_DEVICE_ID_ILITEK_MULTITOUCH	0x0001
  
- #define USB_VENDOR_ID_INTEL_0		0x8086
- #define USB_VENDOR_ID_INTEL_1		0x8087
- #define USB_DEVICE_ID_INTEL_HID_SENSOR_0	0x09fa
- #define USB_DEVICE_ID_INTEL_HID_SENSOR_1	0x0a04
- 
- #define USB_VENDOR_ID_STM_0             0x0483
- #define USB_DEVICE_ID_STM_HID_SENSOR    0x91d1
- #define USB_DEVICE_ID_STM_HID_SENSOR_1  0x9100
- 
- #define USB_VENDOR_ID_ION		0x15e4
- #define USB_DEVICE_ID_ICADE		0x0132
- 
  #define USB_VENDOR_ID_HOLTEK		0x1241
  #define USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP	0x5015
  
- #define USB_VENDOR_ID_HOLTEK_ALT		0x04d9
- #define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD	0xa055
- #define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A04A	0xa04a
- #define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A067	0xa067
- #define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A070	0xa070
- #define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A072	0xa072
- #define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081	0xa081
- #define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2	0xa0c2
- #define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD_A096	0xa096
- 
  #define USB_VENDOR_ID_IMATION		0x0718
  #define USB_DEVICE_ID_DISC_STAKKA	0xd000
  
  #define USB_VENDOR_ID_IRTOUCHSYSTEMS	0x6615
  #define USB_DEVICE_ID_IRTOUCH_INFRARED_USB	0x0070
  
- #define USB_VENDOR_ID_JABRA		0x0b0e
- #define USB_DEVICE_ID_JABRA_SPEAK_410	0x0412
- #define USB_DEVICE_ID_JABRA_SPEAK_510	0x0420
- #define USB_DEVICE_ID_JABRA_GN9350E	0x9350
- 
  #define USB_VENDOR_ID_JESS		0x0c45
  #define USB_DEVICE_ID_JESS_YUREX	0x1010
  
- #define USB_VENDOR_ID_JESS2		0x0f30
- #define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111
- 
  #define USB_VENDOR_ID_KBGEAR		0x084e
  #define USB_DEVICE_ID_KBGEAR_JAMSTUDIO	0x1001
  
--- 401,418 ----
***************
*** 525,537 ****
  
  #define USB_VENDOR_ID_KYE		0x0458
  #define USB_DEVICE_ID_KYE_ERGO_525V	0x0087
- #define USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE	0x0138
- #define USB_DEVICE_ID_GENIUS_MANTICORE	0x0153
- #define USB_DEVICE_ID_GENIUS_GX_IMPERATOR	0x4018
  #define USB_DEVICE_ID_KYE_GPEN_560	0x5003
  #define USB_DEVICE_ID_KYE_EASYPEN_I405X	0x5010
  #define USB_DEVICE_ID_KYE_MOUSEPEN_I608X	0x5011
- #define USB_DEVICE_ID_KYE_MOUSEPEN_I608X_2	0x501a
  #define USB_DEVICE_ID_KYE_EASYPEN_M610X	0x5013
  
  #define USB_VENDOR_ID_LABTEC		0x1020
--- 427,435 ----
***************
*** 575,606 ****
  #define USB_DEVICE_ID_LD_HYBRID		0x2090
  #define USB_DEVICE_ID_LD_HEATCONTROL	0x20A0
  
- #define USB_VENDOR_ID_LENOVO		0x17ef
- #define USB_DEVICE_ID_LENOVO_TPKBD	0x6009
- #define USB_DEVICE_ID_LENOVO_CUSBKBD	0x6047
- #define USB_DEVICE_ID_LENOVO_CBTKBD	0x6048
- 
  #define USB_VENDOR_ID_LG		0x1fd2
  #define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
  
  #define USB_VENDOR_ID_LOGITECH		0x046d
  #define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
- #define USB_DEVICE_ID_LOGITECH_T651	0xb00c
  #define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
  #define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
  #define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
- #define USB_DEVICE_ID_LOGITECH_HARMONY_PS3 0x0306
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD	0xc20a
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD	0xc211
  #define USB_DEVICE_ID_LOGITECH_EXTREME_3D	0xc215
- #define USB_DEVICE_ID_LOGITECH_DUAL_ACTION	0xc216
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2	0xc218
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2	0xc219
  #define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D	0xc283
  #define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO	0xc286
  #define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940	0xc287
- #define USB_DEVICE_ID_LOGITECH_WINGMAN_FFG	0xc293
  #define USB_DEVICE_ID_LOGITECH_WHEEL	0xc294
  #define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL	0xc295
  #define USB_DEVICE_ID_LOGITECH_DFP_WHEEL	0xc298
  #define USB_DEVICE_ID_LOGITECH_G25_WHEEL	0xc299
--- 473,496 ----
  #define USB_DEVICE_ID_LD_HYBRID		0x2090
  #define USB_DEVICE_ID_LD_HEATCONTROL	0x20A0
  
  #define USB_VENDOR_ID_LG		0x1fd2
  #define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
  
  #define USB_VENDOR_ID_LOGITECH		0x046d
  #define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
  #define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
  #define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
  #define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD	0xc20a
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD	0xc211
  #define USB_DEVICE_ID_LOGITECH_EXTREME_3D	0xc215
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2	0xc218
  #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2	0xc219
  #define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D	0xc283
  #define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO	0xc286
  #define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940	0xc287
  #define USB_DEVICE_ID_LOGITECH_WHEEL	0xc294
+ #define USB_DEVICE_ID_LOGITECH_WINGMAN_FFG	0xc293
  #define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL	0xc295
  #define USB_DEVICE_ID_LOGITECH_DFP_WHEEL	0xc298
  #define USB_DEVICE_ID_LOGITECH_G25_WHEEL	0xc299
***************
*** 620,635 ****
  #define USB_DEVICE_ID_DINOVO_EDGE	0xc714
  #define USB_DEVICE_ID_DINOVO_MINI	0xc71f
  #define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2	0xca03
- #define USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL	0xca04
  
  #define USB_VENDOR_ID_LUMIO		0x202e
  #define USB_DEVICE_ID_CRYSTALTOUCH	0x0006
  #define USB_DEVICE_ID_CRYSTALTOUCH_DUAL	0x0007
  
- #define USB_VENDOR_ID_MADCATZ		0x0738
- #define USB_DEVICE_ID_MADCATZ_BEATPAD	0x4540
- #define USB_DEVICE_ID_MADCATZ_RAT9	0x1709
- 
  #define USB_VENDOR_ID_MCC		0x09db
  #define USB_DEVICE_ID_MCC_PMD1024LS	0x0076
  #define USB_DEVICE_ID_MCC_PMD1208LS	0x007a
--- 510,520 ----
***************
*** 643,667 ****
  #define USB_DEVICE_ID_PICKIT2		0x0033
  #define USB_DEVICE_ID_PICOLCD		0xc002
  #define USB_DEVICE_ID_PICOLCD_BOOTLOADER	0xf002
- #define USB_DEVICE_ID_PICK16F1454	0x0042
  
  #define USB_VENDOR_ID_MICROSOFT		0x045e
  #define USB_DEVICE_ID_SIDEWINDER_GV	0x003b
- #define USB_DEVICE_ID_MS_OFFICE_KB	0x0048
  #define USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0 0x009d
  #define USB_DEVICE_ID_MS_NE4K		0x00db
- #define USB_DEVICE_ID_MS_NE4K_JP	0x00dc
  #define USB_DEVICE_ID_MS_LK6K		0x00f9
  #define USB_DEVICE_ID_MS_PRESENTER_8K_BT	0x0701
  #define USB_DEVICE_ID_MS_PRESENTER_8K_USB	0x0713
- #define USB_DEVICE_ID_MS_NE7K		0x071d
  #define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K	0x0730
  #define USB_DEVICE_ID_MS_COMFORT_MOUSE_4500	0x076c
- #define USB_DEVICE_ID_MS_SURFACE_PRO_2   0x0799
- #define USB_DEVICE_ID_MS_TOUCH_COVER_2   0x07a7
- #define USB_DEVICE_ID_MS_TYPE_COVER_2    0x07a9
- #define USB_DEVICE_ID_MS_TYPE_COVER_3    0x07dc
- #define USB_DEVICE_ID_MS_TYPE_COVER_3_JP 0x07dd
  
  #define USB_VENDOR_ID_MOJO		0x8282
  #define USB_DEVICE_ID_RETRO_ADAPTER	0x3201
--- 528,543 ----
***************
*** 669,677 ****
  #define USB_VENDOR_ID_MONTEREY		0x0566
  #define USB_DEVICE_ID_GENIUS_KB29E	0x3004
  
- #define USB_VENDOR_ID_MSI		0x1770
- #define USB_DEVICE_ID_MSI_GT683R_LED_PANEL 0xff00
- 
  #define USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR 0x0400
  #define USB_DEVICE_ID_N_S_HARMONY	0xc359
  
--- 545,550 ----
***************
*** 685,704 ****
  #define USB_VENDOR_ID_NEC		0x073e
  #define USB_DEVICE_ID_NEC_USB_GAME_PAD	0x0301
  
- #define USB_VENDOR_ID_NEXIO		0x1870
- #define USB_DEVICE_ID_NEXIO_MULTITOUCH_420	0x010d
- #define USB_DEVICE_ID_NEXIO_MULTITOUCH_PTI0750	0x0110
- 
  #define USB_VENDOR_ID_NEXTWINDOW	0x1926
  #define USB_DEVICE_ID_NEXTWINDOW_TOUCHSCREEN	0x0003
  
  #define USB_VENDOR_ID_NINTENDO		0x057e
  #define USB_DEVICE_ID_NINTENDO_WIIMOTE	0x0306
- #define USB_DEVICE_ID_NINTENDO_WIIMOTE2	0x0330
- 
- #define USB_VENDOR_ID_NOVATEK		0x0603
- #define USB_DEVICE_ID_NOVATEK_PCT	0x0600
- #define USB_DEVICE_ID_NOVATEK_MOUSE	0x1602
  
  #define USB_VENDOR_ID_NTRIG		0x1b96
  #define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN   0x0001
--- 558,568 ----
***************
*** 720,726 ****
  #define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16   0x0012
  #define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17   0x0013
  #define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18   0x0014
- #define USB_DEVICE_ID_NTRIG_DUOSENSE 0x1500
  
  #define USB_VENDOR_ID_ONTRAK		0x0a07
  #define USB_DEVICE_ID_ONTRAK_ADU100	0x0064
--- 584,589 ----
***************
*** 729,736 ****
  #define USB_DEVICE_ID_ORTEK_PKB1700	0x1700
  #define USB_DEVICE_ID_ORTEK_WKB2000	0x2000
  
- #define USB_VENDOR_ID_PLANTRONICS	0x047f
- 
  #define USB_VENDOR_ID_PANASONIC		0x04da
  #define USB_DEVICE_ID_PANABOARD_UBT780	0x1044
  #define USB_DEVICE_ID_PANABOARD_UBT880	0x104d
--- 592,597 ----
***************
*** 742,750 ****
  
  #define USB_VENDOR_ID_PENMOUNT		0x14e1
  #define USB_DEVICE_ID_PENMOUNT_PCI	0x3500
- #define USB_DEVICE_ID_PENMOUNT_1610	0x1610
- #define USB_DEVICE_ID_PENMOUNT_1640	0x1640
- #define USB_DEVICE_ID_PENMOUNT_6000	0x6000
  
  #define USB_VENDOR_ID_PETALYNX		0x18b1
  #define USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE	0x0037
--- 603,608 ----
***************
*** 756,763 ****
  #define USB_DEVICE_ID_PI_ENGINEERING_VEC_USB_FOOTPEDAL	0xff
  
  #define USB_VENDOR_ID_PIXART				0x093a
- #define USB_DEVICE_ID_PIXART_USB_OPTICAL_MOUSE_ID2	0x0137
- #define USB_DEVICE_ID_PIXART_USB_OPTICAL_MOUSE		0x2510
  #define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN	0x8001
  #define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1	0x8002
  #define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2	0x8003
--- 614,619 ----
***************
*** 775,849 ****
  #define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH		0x3000
  #define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001		0x3001
  #define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008		0x3008
! 
! #define USB_VENDOR_ID_RAZER            0x1532
! #define USB_DEVICE_ID_RAZER_BLADE_14   0x011D
! 
! #define USB_VENDOR_ID_REALTEK		0x0bda
! #define USB_DEVICE_ID_REALTEK_READER	0x0152
  
  #define USB_VENDOR_ID_ROCCAT		0x1e7d
  #define USB_DEVICE_ID_ROCCAT_ARVO	0x30d4
  #define USB_DEVICE_ID_ROCCAT_ISKU	0x319c
- #define USB_DEVICE_ID_ROCCAT_ISKUFX	0x3264
  #define USB_DEVICE_ID_ROCCAT_KONE	0x2ced
  #define USB_DEVICE_ID_ROCCAT_KONEPLUS	0x2d51
- #define USB_DEVICE_ID_ROCCAT_KONEPURE	0x2dbe
- #define USB_DEVICE_ID_ROCCAT_KONEPURE_OPTICAL	0x2db4
- #define USB_DEVICE_ID_ROCCAT_KONEXTD	0x2e22
  #define USB_DEVICE_ID_ROCCAT_KOVAPLUS	0x2d50
- #define USB_DEVICE_ID_ROCCAT_LUA	0x2c2e
  #define USB_DEVICE_ID_ROCCAT_PYRA_WIRED	0x2c24
  #define USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS	0x2cf6
- #define USB_DEVICE_ID_ROCCAT_RYOS_MK	0x3138
- #define USB_DEVICE_ID_ROCCAT_RYOS_MK_GLOW	0x31ce
- #define USB_DEVICE_ID_ROCCAT_RYOS_MK_PRO	0x3232
- #define USB_DEVICE_ID_ROCCAT_SAVU	0x2d5a
  
  #define USB_VENDOR_ID_SAITEK		0x06a3
  #define USB_DEVICE_ID_SAITEK_RUMBLEPAD	0xff17
  #define USB_DEVICE_ID_SAITEK_PS1000	0x0621
- #define USB_DEVICE_ID_SAITEK_RAT7_OLD	0x0ccb
- #define USB_DEVICE_ID_SAITEK_RAT7	0x0cd7
- #define USB_DEVICE_ID_SAITEK_MMO7	0x0cd0
  
  #define USB_VENDOR_ID_SAMSUNG		0x0419
  #define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
  #define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
  
- #define USB_VENDOR_ID_SEMICO			0x1a2c
- #define USB_DEVICE_ID_SEMICO_USB_KEYKOARD	0x0023
- 
- #define USB_VENDOR_ID_SENNHEISER	0x1395
- #define USB_DEVICE_ID_SENNHEISER_BTD500USB	0x002c
- 
  #define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
  #define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD	0x0002
  
- #define USB_VENDOR_ID_SIGMATEL		0x066F
- #define USB_DEVICE_ID_SIGMATEL_STMP3780	0x3780
- 
- #define USB_VENDOR_ID_SIS_TOUCH		0x0457
- #define USB_DEVICE_ID_SIS9200_TOUCH	0x9200
- #define USB_DEVICE_ID_SIS817_TOUCH	0x0817
- #define USB_DEVICE_ID_SIS_TS		0x1013
- #define USB_DEVICE_ID_SIS1030_TOUCH	0x1030
- 
  #define USB_VENDOR_ID_SKYCABLE			0x1223
  #define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
  
- #define USB_VENDOR_ID_SMK		0x0609
- #define USB_DEVICE_ID_SMK_PS3_BDREMOTE	0x0306
- 
  #define USB_VENDOR_ID_SONY			0x054c
  #define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
- #define USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE	0x0374
- #define USB_DEVICE_ID_SONY_PS3_BDREMOTE		0x0306
  #define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
- #define USB_DEVICE_ID_SONY_PS4_CONTROLLER	0x05c4
  #define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER	0x042f
- #define USB_DEVICE_ID_SONY_BUZZ_CONTROLLER		0x0002
- #define USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER	0x1000
  
  #define USB_VENDOR_ID_SOUNDGRAPH	0x15c2
  #define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST	0x0034
--- 631,665 ----
  #define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH		0x3000
  #define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001		0x3001
  #define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008		0x3008
! #define USB_DEVICE_ID_PIXART_IMAGING_INC_OPTICAL_TOUCH_SCREEN	0x3001
  
  #define USB_VENDOR_ID_ROCCAT		0x1e7d
  #define USB_DEVICE_ID_ROCCAT_ARVO	0x30d4
  #define USB_DEVICE_ID_ROCCAT_ISKU	0x319c
  #define USB_DEVICE_ID_ROCCAT_KONE	0x2ced
  #define USB_DEVICE_ID_ROCCAT_KONEPLUS	0x2d51
  #define USB_DEVICE_ID_ROCCAT_KOVAPLUS	0x2d50
  #define USB_DEVICE_ID_ROCCAT_PYRA_WIRED	0x2c24
  #define USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS	0x2cf6
  
  #define USB_VENDOR_ID_SAITEK		0x06a3
  #define USB_DEVICE_ID_SAITEK_RUMBLEPAD	0xff17
  #define USB_DEVICE_ID_SAITEK_PS1000	0x0621
  
  #define USB_VENDOR_ID_SAMSUNG		0x0419
  #define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
  #define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
  
  #define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
  #define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD	0x0002
  
  #define USB_VENDOR_ID_SKYCABLE			0x1223
  #define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
  
  #define USB_VENDOR_ID_SONY			0x054c
  #define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
  #define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
  #define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER	0x042f
  
  #define USB_VENDOR_ID_SOUNDGRAPH	0x15c2
  #define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST	0x0034
***************
*** 858,866 ****
  #define USB_VENDOR_ID_STANTUM_SITRONIX		0x1403
  #define USB_DEVICE_ID_MTP_SITRONIX		0x5001
  
- #define USB_VENDOR_ID_STEELSERIES	0x1038
- #define USB_DEVICE_ID_STEELSERIES_SRWS1	0x1410
- 
  #define USB_VENDOR_ID_SUN		0x0430
  #define USB_DEVICE_ID_RARITAN_KVM_DONGLE	0xcdab
  
--- 674,679 ----
***************
*** 881,897 ****
  #define USB_DEVICE_ID_SYNAPTICS_COMP_TP	0x0009
  #define USB_DEVICE_ID_SYNAPTICS_WTP	0x0010
  #define USB_DEVICE_ID_SYNAPTICS_DPAD	0x0013
- #define USB_DEVICE_ID_SYNAPTICS_LTS1	0x0af8
- #define USB_DEVICE_ID_SYNAPTICS_LTS2	0x1d10
- #define USB_DEVICE_ID_SYNAPTICS_HD	0x0ac3
- #define USB_DEVICE_ID_SYNAPTICS_QUAD_HD	0x1ac3
- #define USB_DEVICE_ID_SYNAPTICS_TP_V103	0x5710
- 
- #define USB_VENDOR_ID_TEXAS_INSTRUMENTS	0x2047
- #define USB_DEVICE_ID_TEXAS_INSTRUMENTS_LENOVO_YOGA	0x0855
- 
- #define USB_VENDOR_ID_THINGM		0x27b8
- #define USB_DEVICE_ID_BLINK1		0x01ed
  
  #define USB_VENDOR_ID_THRUSTMASTER	0x044f
  
--- 694,699 ----
***************
*** 915,923 ****
  #define USB_VENDOR_ID_TOUCHPACK		0x1bfd
  #define USB_DEVICE_ID_TOUCHPACK_RTS	0x1688
  
- #define USB_VENDOR_ID_TPV		0x25aa
- #define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN	0x8883
- 
  #define USB_VENDOR_ID_TURBOX		0x062a
  #define USB_DEVICE_ID_TURBOX_KEYBOARD	0x0201
  #define USB_DEVICE_ID_TURBOX_TOUCHSCREEN_MOSART	0x7100
--- 717,722 ----
***************
*** 934,951 ****
  #define USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U	0x0005
  #define USB_DEVICE_ID_UCLOGIC_TABLET_WP1062	0x0064
  #define USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850	0x0522
- #define USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60	0x0781
  
  #define USB_VENDOR_ID_UNITEC	0x227d
  #define USB_DEVICE_ID_UNITEC_USB_TOUCH_0709	0x0709
  #define USB_DEVICE_ID_UNITEC_USB_TOUCH_0A19	0x0a19
  
- #define USB_VENDOR_ID_VELLEMAN		0x10cf
- #define USB_DEVICE_ID_VELLEMAN_K8055_FIRST	0x5500
- #define USB_DEVICE_ID_VELLEMAN_K8055_LAST	0x5503
- #define USB_DEVICE_ID_VELLEMAN_K8061_FIRST	0x8061
- #define USB_DEVICE_ID_VELLEMAN_K8061_LAST	0x8068
- 
  #define USB_VENDOR_ID_VERNIER		0x08f7
  #define USB_DEVICE_ID_VERNIER_LABPRO	0x0001
  #define USB_DEVICE_ID_VERNIER_GOTEMP	0x0002
--- 733,743 ----
***************
*** 953,961 ****
  #define USB_DEVICE_ID_VERNIER_CYCLOPS	0x0004
  #define USB_DEVICE_ID_VERNIER_LCSPEC	0x0006
  
- #define USB_VENDOR_ID_VTL		0x0306
- #define USB_DEVICE_ID_VTL_MULTITOUCH_FF3F	0xff3f
- 
  #define USB_VENDOR_ID_WACOM		0x056a
  #define USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH	0x81
  #define USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH   0x00BD
--- 745,750 ----
***************
*** 985,1002 ****
  #define USB_DEVICE_ID_SUPER_DUAL_BOX_PRO 0x8802
  #define USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO 0x8804
  
- #define USB_VENDOR_ID_WISTRON		0x0fb8
- #define USB_DEVICE_ID_WISTRON_OPTICAL_TOUCH		0x1109
- 
  #define USB_VENDOR_ID_X_TENSIONS               0x1ae7
  #define USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE    0x9001
  
  #define USB_VENDOR_ID_XAT	0x2505
  #define USB_DEVICE_ID_XAT_CSR	0x0220
  
- #define USB_VENDOR_ID_XIN_MO			0x16c0
- #define USB_DEVICE_ID_XIN_MO_DUAL_ARCADE	0x05e1
- 
  #define USB_VENDOR_ID_XIROKU		0x1477
  #define USB_DEVICE_ID_XIROKU_SPX	0x1006
  #define USB_DEVICE_ID_XIROKU_MPX	0x1007
--- 774,785 ----
***************
*** 1016,1029 ****
  #define USB_VENDOR_ID_ZYDACRON	0x13EC
  #define USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL	0x0006
  
- #define USB_VENDOR_ID_ZYTRONIC		0x14c8
- #define USB_DEVICE_ID_ZYTRONIC_ZXY100	0x0005
- 
  #define USB_VENDOR_ID_PRIMAX	0x0461
  #define USB_DEVICE_ID_PRIMAX_KEYBOARD	0x4e05
  
- 
- #define USB_VENDOR_ID_RISO_KAGAKU	0x1294	/* Riso Kagaku Corp. */
- #define USB_DEVICE_ID_RI_KA_WEBMAIL	0x1320	/* Webmail Notifier */
- 
  #endif
--- 799,805 ----
diff -crB ln12Mar/hv/hid-input.c hv-rhel7.x/hv/hid-input.c
*** ln12Mar/hv/hid-input.c	2015-05-14 08:56:57.938753735 -0700
--- hv-rhel7.x/hv/hid-input.c	2015-05-14 07:05:22.417084932 -0700
***************
*** 70,295 ****
  #define map_key_clear(c)	hid_map_usage_clear(hidinput, usage, &bit, \
  		&max, EV_KEY, (c))
  
- static bool match_scancode(struct hid_usage *usage,
- 			   unsigned int cur_idx, unsigned int scancode)
- {
- 	return (usage->hid & (HID_USAGE_PAGE | HID_USAGE)) == scancode;
- }
- 
- static bool match_keycode(struct hid_usage *usage,
- 			  unsigned int cur_idx, unsigned int keycode)
- {
- 	/*
- 	 * We should exclude unmapped usages when doing lookup by keycode.
- 	 */
- 	return (usage->type == EV_KEY && usage->code == keycode);
- }
- 
- static bool match_index(struct hid_usage *usage,
- 			unsigned int cur_idx, unsigned int idx)
- {
- 	return cur_idx == idx;
- }
  
  typedef bool (*hid_usage_cmp_t)(struct hid_usage *usage,
  				unsigned int cur_idx, unsigned int val);
  
- static struct hid_usage *hidinput_find_key(struct hid_device *hid,
- 					   hid_usage_cmp_t match,
- 					   unsigned int value,
- 					   unsigned int *usage_idx)
- {
- 	unsigned int i, j, k, cur_idx = 0;
- 	struct hid_report *report;
- 	struct hid_usage *usage;
- 
- 	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
- 		list_for_each_entry(report, &hid->report_enum[k].report_list, list) {
- 			for (i = 0; i < report->maxfield; i++) {
- 				for (j = 0; j < report->field[i]->maxusage; j++) {
- 					usage = report->field[i]->usage + j;
- 					if (usage->type == EV_KEY || usage->type == 0) {
- 						if (match(usage, cur_idx, value)) {
- 							if (usage_idx)
- 								*usage_idx = cur_idx;
- 							return usage;
- 						}
- 						cur_idx++;
- 					}
- 				}
- 			}
- 		}
- 	}
- 	return NULL;
- }
- 
- static struct hid_usage *hidinput_locate_usage(struct hid_device *hid,
- 					const struct input_keymap_entry *ke,
- 					unsigned int *index)
- {
- 	struct hid_usage *usage;
- 	unsigned int scancode;
- 
- 	if (ke->flags & INPUT_KEYMAP_BY_INDEX)
- 		usage = hidinput_find_key(hid, match_index, ke->index, index);
- 	else if (input_scancode_to_scalar(ke, &scancode) == 0)
- 		usage = hidinput_find_key(hid, match_scancode, scancode, index);
- 	else
- 		usage = NULL;
- 
- 	return usage;
- }
- 
- static int hidinput_getkeycode(struct input_dev *dev,
- 			       struct input_keymap_entry *ke)
- {
- 	struct hid_device *hid = input_get_drvdata(dev);
- 	struct hid_usage *usage;
- 	unsigned int scancode, index;
- 
- 	usage = hidinput_locate_usage(hid, ke, &index);
- 	if (usage) {
- 		ke->keycode = usage->type == EV_KEY ?
- 				usage->code : KEY_RESERVED;
- 		ke->index = index;
- 		scancode = usage->hid & (HID_USAGE_PAGE | HID_USAGE);
- 		ke->len = sizeof(scancode);
- 		memcpy(ke->scancode, &scancode, sizeof(scancode));
- 		return 0;
- 	}
- 
- 	return -EINVAL;
- }
- 
- static int hidinput_setkeycode(struct input_dev *dev,
- 			       const struct input_keymap_entry *ke,
- 			       unsigned int *old_keycode)
- {
- 	struct hid_device *hid = input_get_drvdata(dev);
- 	struct hid_usage *usage;
- 
- 	usage = hidinput_locate_usage(hid, ke, NULL);
- 	if (usage) {
- 		*old_keycode = usage->type == EV_KEY ?
- 				usage->code : KEY_RESERVED;
- 		usage->code = ke->keycode;
- 
- 		clear_bit(*old_keycode, dev->keybit);
- 		set_bit(usage->code, dev->keybit);
- 		dbg_hid("Assigned keycode %d to HID usage code %x\n",
- 			usage->code, usage->hid);
- 
- 		/*
- 		 * Set the keybit for the old keycode if the old keycode is used
- 		 * by another key
- 		 */
- 		if (hidinput_find_key(hid, match_keycode, *old_keycode, NULL))
- 			set_bit(*old_keycode, dev->keybit);
- 
- 		return 0;
- 	}
- 
- 	return -EINVAL;
- }
- 
- 
- /**
-  * hidinput_calc_abs_res - calculate an absolute axis resolution
-  * @field: the HID report field to calculate resolution for
-  * @code: axis code
-  *
-  * The formula is:
-  *                         (logical_maximum - logical_minimum)
-  * resolution = ----------------------------------------------------------
-  *              (physical_maximum - physical_minimum) * 10 ^ unit_exponent
-  *
-  * as seen in the HID specification v1.11 6.2.2.7 Global Items.
-  *
-  * Only exponent 1 length units are processed. Centimeters and inches are
-  * converted to millimeters. Degrees are converted to radians.
-  */
- __s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)
- {
- 	__s32 unit_exponent = field->unit_exponent;
- 	__s32 logical_extents = field->logical_maximum -
- 					field->logical_minimum;
- 	__s32 physical_extents = field->physical_maximum -
- 					field->physical_minimum;
- 	__s32 prev;
- 
- 	/* Check if the extents are sane */
- 	if (logical_extents <= 0 || physical_extents <= 0)
- 		return 0;
- 
- 	/*
- 	 * Verify and convert units.
- 	 * See HID specification v1.11 6.2.2.7 Global Items for unit decoding
- 	 */
- 	switch (code) {
- 	case ABS_X:
- 	case ABS_Y:
- 	case ABS_Z:
- 	case ABS_MT_POSITION_X:
- 	case ABS_MT_POSITION_Y:
- 	case ABS_MT_TOOL_X:
- 	case ABS_MT_TOOL_Y:
- 	case ABS_MT_TOUCH_MAJOR:
- 	case ABS_MT_TOUCH_MINOR:
- 		if (field->unit == 0x11) {		/* If centimeters */
- 			/* Convert to millimeters */
- 			unit_exponent += 1;
- 		} else if (field->unit == 0x13) {	/* If inches */
- 			/* Convert to millimeters */
- 			prev = physical_extents;
- 			physical_extents *= 254;
- 			if (physical_extents < prev)
- 				return 0;
- 			unit_exponent -= 1;
- 		} else {
- 			return 0;
- 		}
- 		break;
- 
- 	case ABS_RX:
- 	case ABS_RY:
- 	case ABS_RZ:
- 	case ABS_TILT_X:
- 	case ABS_TILT_Y:
- 		if (field->unit == 0x14) {		/* If degrees */
- 			/* Convert to radians */
- 			prev = logical_extents;
- 			logical_extents *= 573;
- 			if (logical_extents < prev)
- 				return 0;
- 			unit_exponent += 1;
- 		} else if (field->unit != 0x12) {	/* If not radians */
- 			return 0;
- 		}
- 		break;
- 
- 	default:
- 		return 0;
- 	}
- 
- 	/* Apply negative unit exponent */
- 	for (; unit_exponent < 0; unit_exponent++) {
- 		prev = logical_extents;
- 		logical_extents *= 10;
- 		if (logical_extents < prev)
- 			return 0;
- 	}
- 	/* Apply positive unit exponent */
- 	for (; unit_exponent > 0; unit_exponent--) {
- 		prev = physical_extents;
- 		physical_extents *= 10;
- 		if (physical_extents < prev)
- 			return 0;
- 	}
- 
- 	/* Calculate resolution */
- 	return DIV_ROUND_CLOSEST(logical_extents, physical_extents);
- }
- EXPORT_SYMBOL_GPL(hidinput_calc_abs_res);
  
  #ifdef CONFIG_HID_BATTERY_STRENGTH
  static enum power_supply_property hidinput_battery_props[] = {
--- 70,79 ----
***************
*** 306,324 ****
  
  static const struct hid_device_id hid_battery_quirks[] = {
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
! 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
! 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
! 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
! 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI),
! 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
! 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
! 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
! 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
! 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
! 			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO),
! 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
! 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
! 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),
  	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
  	{}
  };
--- 90,96 ----
  
  static const struct hid_device_id hid_battery_quirks[] = {
  	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
! 			       USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),
  	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
  	{}
  };
***************
*** 341,347 ****
  {
  	struct hid_device *dev = container_of(psy, struct hid_device, battery);
  	int ret = 0;
! 	__u8 *buf;
  
  	switch (prop) {
  	case POWER_SUPPLY_PROP_PRESENT:
--- 113,119 ----
  {
  	struct hid_device *dev = container_of(psy, struct hid_device, battery);
  	int ret = 0;
! 	__u8 buf[2] = {};
  
  	switch (prop) {
  	case POWER_SUPPLY_PROP_PRESENT:
***************
*** 350,378 ****
  		break;
  
  	case POWER_SUPPLY_PROP_CAPACITY:
! 
! 		buf = kmalloc(2 * sizeof(__u8), GFP_KERNEL);
! 		if (!buf) {
! 			ret = -ENOMEM;
! 			break;
! 		}
! 		ret = hid_hw_raw_request(dev, dev->battery_report_id, buf, 2,
! 					 dev->battery_report_type,
! 					 HID_REQ_GET_REPORT);
  
  		if (ret != 2) {
! 			ret = -ENODATA;
! 			kfree(buf);
  			break;
  		}
- 		ret = 0;
  
  		if (dev->battery_min < dev->battery_max &&
  		    buf[1] >= dev->battery_min &&
  		    buf[1] <= dev->battery_max)
  			val->intval = (100 * (buf[1] - dev->battery_min)) /
  				(dev->battery_max - dev->battery_min);
- 		kfree(buf);
  		break;
  
  	case POWER_SUPPLY_PROP_MODEL_NAME:
--- 122,142 ----
  		break;
  
  	case POWER_SUPPLY_PROP_CAPACITY:
! 		ret = dev->hid_get_raw_report(dev, dev->battery_report_id,
! 					      buf, sizeof(buf),
! 					      dev->battery_report_type);
  
  		if (ret != 2) {
! 			if (ret >= 0)
! 				ret = -EINVAL;
  			break;
  		}
  
  		if (dev->battery_min < dev->battery_max &&
  		    buf[1] >= dev->battery_min &&
  		    buf[1] <= dev->battery_max)
  			val->intval = (100 * (buf[1] - dev->battery_min)) /
  				(dev->battery_max - dev->battery_min);
  		break;
  
  	case POWER_SUPPLY_PROP_MODEL_NAME:
***************
*** 486,495 ****
  	if (field->flags & HID_MAIN_ITEM_CONSTANT)
  		goto ignore;
  
- 	/* Ignore if report count is out of bounds. */
- 	if (field->report_count < 1)
- 		goto ignore;
- 
  	/* only LED usages are supported in output fields */
  	if (field->report_type == HID_OUTPUT_REPORT &&
  			(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {
--- 250,255 ----
***************
*** 530,543 ****
  				if (code <= 0xf)
  					code += BTN_JOYSTICK;
  				else
! 					code += BTN_TRIGGER_HAPPY - 0x10;
! 				break;
! 		case HID_GD_GAMEPAD:
! 				if (code <= 0xf)
! 					code += BTN_GAMEPAD;
! 				else
! 					code += BTN_TRIGGER_HAPPY - 0x10;
  				break;
  		default:
  			switch (field->physical) {
  			case HID_GD_MOUSE:
--- 290,298 ----
  				if (code <= 0xf)
  					code += BTN_JOYSTICK;
  				else
! 					code += BTN_TRIGGER_HAPPY;
  				break;
+ 		case HID_GD_GAMEPAD:  code += BTN_GAMEPAD; break;
  		default:
  			switch (field->physical) {
  			case HID_GD_MOUSE:
***************
*** 605,616 ****
  		/* These usage IDs map directly to the usage codes. */
  		case HID_GD_X: case HID_GD_Y: case HID_GD_Z:
  		case HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:
- 			if (field->flags & HID_MAIN_ITEM_RELATIVE)
- 				map_rel(usage->hid & 0xf);
- 			else
- 				map_abs_clear(usage->hid & 0xf);
- 			break;
- 
  		case HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:
  			if (field->flags & HID_MAIN_ITEM_RELATIVE)
  				map_rel(usage->hid & 0xf);
--- 360,365 ----
***************
*** 696,712 ****
  			break;
  
  		case 0x46: /* TabletPick */
- 		case 0x5a: /* SecondaryBarrelSwitch */
  			map_key_clear(BTN_STYLUS2);
  			break;
  
- 		case 0x5b: /* TransducerSerialNumber */
- 			usage->type = EV_MSC;
- 			usage->code = MSC_SERIAL;
- 			bit = input->mscbit;
- 			max = MSC_MAX;
- 			break;
- 
  		default:  goto unknown;
  		}
  		break;
--- 445,453 ----
***************
*** 741,753 ****
  		case 0x06c: map_key_clear(KEY_YELLOW);		break;
  		case 0x06d: map_key_clear(KEY_ZOOM);		break;
  
- 		case 0x06f: map_key_clear(KEY_BRIGHTNESSUP);		break;
- 		case 0x070: map_key_clear(KEY_BRIGHTNESSDOWN);		break;
- 		case 0x072: map_key_clear(KEY_BRIGHTNESS_TOGGLE);	break;
- 		case 0x073: map_key_clear(KEY_BRIGHTNESS_MIN);		break;
- 		case 0x074: map_key_clear(KEY_BRIGHTNESS_MAX);		break;
- 		case 0x075: map_key_clear(KEY_BRIGHTNESS_AUTO);		break;
- 
  		case 0x082: map_key_clear(KEY_VIDEO_NEXT);	break;
  		case 0x083: map_key_clear(KEY_LAST);		break;
  		case 0x084: map_key_clear(KEY_ENTER);		break;
--- 482,487 ----
***************
*** 788,794 ****
  		case 0x0bf: map_key_clear(KEY_SLOW);		break;
  
  		case 0x0cd: map_key_clear(KEY_PLAYPAUSE);	break;
- 		case 0x0cf: map_key_clear(KEY_VOICECOMMAND);	break;
  		case 0x0e0: map_abs_clear(ABS_VOLUME);		break;
  		case 0x0e2: map_key_clear(KEY_MUTE);		break;
  		case 0x0e5: map_key_clear(KEY_BASSBOOST);	break;
--- 522,527 ----
***************
*** 796,802 ****
  		case 0x0ea: map_key_clear(KEY_VOLUMEDOWN);	break;
  		case 0x0f5: map_key_clear(KEY_SLOW);		break;
  
- 		case 0x181: map_key_clear(KEY_BUTTONCONFIG);	break;
  		case 0x182: map_key_clear(KEY_BOOKMARKS);	break;
  		case 0x183: map_key_clear(KEY_CONFIG);		break;
  		case 0x184: map_key_clear(KEY_WORDPROCESSOR);	break;
--- 529,534 ----
***************
*** 810,817 ****
  		case 0x18c: map_key_clear(KEY_VOICEMAIL);	break;
  		case 0x18d: map_key_clear(KEY_ADDRESSBOOK);	break;
  		case 0x18e: map_key_clear(KEY_CALENDAR);	break;
- 		case 0x18f: map_key_clear(KEY_TASKMANAGER);	break;
- 		case 0x190: map_key_clear(KEY_JOURNAL);		break;
  		case 0x191: map_key_clear(KEY_FINANCE);		break;
  		case 0x192: map_key_clear(KEY_CALC);		break;
  		case 0x193: map_key_clear(KEY_PLAYER);		break;
--- 542,547 ----
***************
*** 820,835 ****
  		case 0x199: map_key_clear(KEY_CHAT);		break;
  		case 0x19c: map_key_clear(KEY_LOGOFF);		break;
  		case 0x19e: map_key_clear(KEY_COFFEE);		break;
- 		case 0x19f: map_key_clear(KEY_CONTROLPANEL);		break;
- 		case 0x1a2: map_key_clear(KEY_APPSELECT);		break;
- 		case 0x1a3: map_key_clear(KEY_NEXT);		break;
- 		case 0x1a4: map_key_clear(KEY_PREVIOUS);	break;
  		case 0x1a6: map_key_clear(KEY_HELP);		break;
  		case 0x1a7: map_key_clear(KEY_DOCUMENTS);	break;
  		case 0x1ab: map_key_clear(KEY_SPELLCHECK);	break;
  		case 0x1ae: map_key_clear(KEY_KEYBOARD);	break;
- 		case 0x1b1: map_key_clear(KEY_SCREENSAVER);		break;
- 		case 0x1b4: map_key_clear(KEY_FILE);		break;
  		case 0x1b6: map_key_clear(KEY_IMAGES);		break;
  		case 0x1b7: map_key_clear(KEY_AUDIO);		break;
  		case 0x1b8: map_key_clear(KEY_VIDEO);		break;
--- 550,559 ----
***************
*** 871,884 ****
  		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
  		case 0x28c: map_key_clear(KEY_SEND);		break;
  
! 		case 0x2c7: map_key_clear(KEY_KBDINPUTASSIST_PREV);		break;
! 		case 0x2c8: map_key_clear(KEY_KBDINPUTASSIST_NEXT);		break;
! 		case 0x2c9: map_key_clear(KEY_KBDINPUTASSIST_PREVGROUP);		break;
! 		case 0x2ca: map_key_clear(KEY_KBDINPUTASSIST_NEXTGROUP);		break;
! 		case 0x2cb: map_key_clear(KEY_KBDINPUTASSIST_ACCEPT);	break;
! 		case 0x2cc: map_key_clear(KEY_KBDINPUTASSIST_CANCEL);	break;
! 
! 		default: map_key_clear(KEY_UNKNOWN);
  		}
  		break;
  
--- 595,601 ----
  		case 0x28b: map_key_clear(KEY_FORWARDMAIL);	break;
  		case 0x28c: map_key_clear(KEY_SEND);		break;
  
! 		default:    goto ignore;
  		}
  		break;
  
***************
*** 908,922 ****
  		}
  		break;
  
- 	case HID_UP_HPVENDOR2:
- 		set_bit(EV_REP, input->evbit);
- 		switch (usage->hid & HID_USAGE) {
- 		case 0x003: map_key_clear(KEY_BRIGHTNESSDOWN);	break;
- 		case 0x004: map_key_clear(KEY_BRIGHTNESSUP);	break;
- 		default:    goto ignore;
- 		}
- 		break;
- 
  	case HID_UP_MSVENDOR:
  		goto ignore;
  
--- 625,630 ----
***************
*** 980,1002 ****
  			input_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);
  		else	input_set_abs_params(input, usage->code, a, b, 0, 0);
  
- 		input_abs_set_res(input, usage->code,
- 				  hidinput_calc_abs_res(field, usage->code));
- 
- 		/* use a larger default input buffer for MT devices */
- 		if (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)
- 			input_set_events_per_packet(input, 60);
- 	}
- 
- 	if (usage->type == EV_ABS &&
- 	    (usage->hat_min < usage->hat_max || usage->hat_dir)) {
- 		int i;
- 		for (i = usage->code; i < usage->code + 2 && i <= max; i++) {
- 			input_set_abs_params(input, i, -1, 1, 0, 0);
- 			set_bit(i, input->absbit);
- 		}
- 		if (usage->hat_dir && !field->dpad)
- 			field->dpad = usage->code;
  	}
  
  	/* for those devices which produce Consumer volume usage as relative,
--- 688,693 ----
***************
*** 1093,1129 ****
  
  	/*
  	 * Ignore out-of-range values as per HID specification,
! 	 * section 5.10 and 6.2.25.
! 	 *
! 	 * The logical_minimum < logical_maximum check is done so that we
! 	 * don't unintentionally discard values sent by devices which
! 	 * don't specify logical min and max.
  	 */
  	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
- 	    (field->logical_minimum < field->logical_maximum) &&
  	    (value < field->logical_minimum ||
  	     value > field->logical_maximum)) {
  		dbg_hid("Ignoring out-of-range value %x\n", value);
  		return;
  	}
  
- 	/*
- 	 * Ignore reports for absolute data if the data didn't change. This is
- 	 * not only an optimization but also fixes 'dead' key reports. Some
- 	 * RollOver implementations for localized keys (like BACKSLASH/PIPE; HID
- 	 * 0x31 and 0x32) report multiple keys, even though a localized keyboard
- 	 * can only have one of them physically available. The 'dead' keys
- 	 * report constant 0. As all map to the same keycode, they'd confuse
- 	 * the input layer. If we filter the 'dead' keys on the HID level, we
- 	 * skip the keycode translation and only forward real events.
- 	 */
- 	if (!(field->flags & (HID_MAIN_ITEM_RELATIVE |
- 	                      HID_MAIN_ITEM_BUFFERED_BYTE)) &&
- 			      (field->flags & HID_MAIN_ITEM_VARIABLE) &&
- 	    usage->usage_index < field->maxusage &&
- 	    value == field->value[usage->usage_index])
- 		return;
- 
  	/* report the usage code as scancode if the key status has changed */
  	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
  		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
--- 784,798 ----
  
  	/*
  	 * Ignore out-of-range values as per HID specification,
! 	 * section 5.10 and 6.2.25
  	 */
  	if ((field->flags & HID_MAIN_ITEM_VARIABLE) &&
  	    (value < field->logical_minimum ||
  	     value > field->logical_maximum)) {
  		dbg_hid("Ignoring out-of-range value %x\n", value);
  		return;
  	}
  
  	/* report the usage code as scancode if the key status has changed */
  	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
  		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
***************
*** 1205,1281 ****
  }
  EXPORT_SYMBOL_GPL(hidinput_count_leds);
  
- static void hidinput_led_worker(struct work_struct *work)
- {
- 	struct hid_device *hid = container_of(work, struct hid_device,
- 					      led_work);
- 	struct hid_field *field;
- 	struct hid_report *report;
- 	int len, ret;
- 	__u8 *buf;
- 
- 	field = hidinput_get_led_field(hid);
- 	if (!field)
- 		return;
- 
- 	/*
- 	 * field->report is accessed unlocked regarding HID core. So there might
- 	 * be another incoming SET-LED request from user-space, which changes
- 	 * the LED state while we assemble our outgoing buffer. However, this
- 	 * doesn't matter as hid_output_report() correctly converts it into a
- 	 * boolean value no matter what information is currently set on the LED
- 	 * field (even garbage). So the remote device will always get a valid
- 	 * request.
- 	 * And in case we send a wrong value, a next led worker is spawned
- 	 * for every SET-LED request so the following worker will send the
- 	 * correct value, guaranteed!
- 	 */
- 
- 	report = field->report;
- 
- 	/* use custom SET_REPORT request if possible (asynchronous) */
- 	if (hid->ll_driver->request)
- 		return hid->ll_driver->request(hid, report, HID_REQ_SET_REPORT);
- 
- 	/* fall back to generic raw-output-report */
- 	len = hid_report_len(report);
- 	buf = hid_alloc_report_buf(report, GFP_KERNEL);
- 	if (!buf)
- 		return;
- 
- 	hid_output_report(report, buf);
- 	/* synchronous output report */
- 	ret = hid_hw_output_report(hid, buf, len);
- 	if (ret == -ENOSYS)
- 		hid_hw_raw_request(hid, report->id, buf, len, HID_OUTPUT_REPORT,
- 				HID_REQ_SET_REPORT);
- 	kfree(buf);
- }
- 
- static int hidinput_input_event(struct input_dev *dev, unsigned int type,
- 				unsigned int code, int value)
- {
- 	struct hid_device *hid = input_get_drvdata(dev);
- 	struct hid_field *field;
- 	int offset;
- 
- 	if (type == EV_FF)
- 		return input_ff_event(dev, type, code, value);
- 
- 	if (type != EV_LED)
- 		return -1;
- 
- 	if ((offset = hidinput_find_field(hid, type, code, &field)) == -1) {
- 		hid_warn(dev, "event field not found\n");
- 		return -1;
- 	}
- 
- 	hid_set_field(field, offset, value);
- 
- 	schedule_work(&hid->led_work);
- 	return 0;
- }
- 
  static int hidinput_open(struct input_dev *dev)
  {
  	struct hid_device *hid = input_get_drvdata(dev);
--- 874,879 ----
***************
*** 1299,1309 ****
  
  	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
  	list_for_each_entry(rep, &rep_enum->report_list, list)
! 		for (i = 0; i < rep->maxfield; i++) {
! 			/* Ignore if report count is out of bounds. */
! 			if (rep->field[i]->report_count < 1)
! 				continue;
! 
  			for (j = 0; j < rep->field[i]->maxusage; j++) {
  				/* Verify if Battery Strength feature is available */
  				hidinput_setup_battery(hid, HID_FEATURE_REPORT, rep->field[i]);
--- 897,903 ----
  
  	rep_enum = &hid->report_enum[HID_FEATURE_REPORT];
  	list_for_each_entry(rep, &rep_enum->report_list, list)
! 		for (i = 0; i < rep->maxfield; i++)
  			for (j = 0; j < rep->field[i]->maxusage; j++) {
  				/* Verify if Battery Strength feature is available */
  				hidinput_setup_battery(hid, HID_FEATURE_REPORT, rep->field[i]);
***************
*** 1312,1411 ****
  					drv->feature_mapping(hid, rep->field[i],
  							     rep->field[i]->usage + j);
  			}
- 		}
- }
- 
- static struct hid_input *hidinput_allocate(struct hid_device *hid)
- {
- 	struct hid_input *hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
- 	struct input_dev *input_dev = input_allocate_device();
- 	if (!hidinput || !input_dev) {
- 		kfree(hidinput);
- 		input_free_device(input_dev);
- 		hid_err(hid, "Out of memory during hid input probe\n");
- 		return NULL;
- 	}
- 
- 	input_set_drvdata(input_dev, hid);
- 	input_dev->event = hidinput_input_event;
- 	input_dev->open = hidinput_open;
- 	input_dev->close = hidinput_close;
- 	input_dev->setkeycode = hidinput_setkeycode;
- 	input_dev->getkeycode = hidinput_getkeycode;
- 
- 	input_dev->name = hid->name;
- 	input_dev->phys = hid->phys;
- 	input_dev->uniq = hid->uniq;
- 	input_dev->id.bustype = hid->bus;
- 	input_dev->id.vendor  = hid->vendor;
- 	input_dev->id.product = hid->product;
- 	input_dev->id.version = hid->version;
- 	input_dev->dev.parent = &hid->dev;
- 	hidinput->input = input_dev;
- 	list_add_tail(&hidinput->list, &hid->inputs);
- 
- 	return hidinput;
- }
- 
- static bool hidinput_has_been_populated(struct hid_input *hidinput)
- {
- 	int i;
- 	unsigned long r = 0;
- 
- 	for (i = 0; i < BITS_TO_LONGS(EV_CNT); i++)
- 		r |= hidinput->input->evbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(KEY_CNT); i++)
- 		r |= hidinput->input->keybit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(REL_CNT); i++)
- 		r |= hidinput->input->relbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(ABS_CNT); i++)
- 		r |= hidinput->input->absbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(MSC_CNT); i++)
- 		r |= hidinput->input->mscbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(LED_CNT); i++)
- 		r |= hidinput->input->ledbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(SND_CNT); i++)
- 		r |= hidinput->input->sndbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(FF_CNT); i++)
- 		r |= hidinput->input->ffbit[i];
- 
- 	for (i = 0; i < BITS_TO_LONGS(SW_CNT); i++)
- 		r |= hidinput->input->swbit[i];
- 
- 	return !!r;
- }
- 
- static void hidinput_cleanup_hidinput(struct hid_device *hid,
- 		struct hid_input *hidinput)
- {
- 	struct hid_report *report;
- 	int i, k;
- 
- 	list_del(&hidinput->list);
- 	input_free_device(hidinput->input);
- 
- 	for (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {
- 		if (k == HID_OUTPUT_REPORT &&
- 			hid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)
- 			continue;
- 
- 		list_for_each_entry(report, &hid->report_enum[k].report_list,
- 				    list) {
- 
- 			for (i = 0; i < report->maxfield; i++)
- 				if (report->field[i]->hidinput == hidinput)
- 					report->field[i]->hidinput = NULL;
- 		}
- 	}
- 
- 	kfree(hidinput);
  }
  
  /*
--- 906,911 ----
***************
*** 1416,1428 ****
  
  int hidinput_connect(struct hid_device *hid, unsigned int force)
  {
- 	struct hid_driver *drv = hid->driver;
  	struct hid_report *report;
  	struct hid_input *hidinput = NULL;
  	int i, j, k;
  
  	INIT_LIST_HEAD(&hid->inputs);
- 	INIT_WORK(&hid->led_work, hidinput_led_worker);
  
  	if (!force) {
  		for (i = 0; i < hid->maxcollection; i++) {
--- 916,928 ----
  
  int hidinput_connect(struct hid_device *hid, unsigned int force)
  {
  	struct hid_report *report;
  	struct hid_input *hidinput = NULL;
+ 	struct input_dev *input_dev;
  	int i, j, k;
  
+ 
  	INIT_LIST_HEAD(&hid->inputs);
  
  	if (!force) {
  		for (i = 0; i < hid->maxcollection; i++) {
***************
*** 1450,1458 ****
  				continue;
  
  			if (!hidinput) {
! 				hidinput = hidinput_allocate(hid);
! 				if (!hidinput)
  					goto out_unwind;
  			}
  
  			for (i = 0; i < report->maxfield; i++)
--- 950,979 ----
  				continue;
  
  			if (!hidinput) {
! 				hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);
! 				input_dev = input_allocate_device();
! 				if (!hidinput || !input_dev) {
! 					kfree(hidinput);
! 					input_free_device(input_dev);
! 					hid_err(hid, "Out of memory during hid input probe\n");
  					goto out_unwind;
+ 				}
+ 
+ 				input_set_drvdata(input_dev, hid);
+ 				input_dev->event =
+ 					hid->ll_driver->hidinput_input_event;
+ 				input_dev->open = hidinput_open;
+ 				input_dev->close = hidinput_close;
+ 
+ 				input_dev->name = hid->name;
+ 				input_dev->phys = hid->phys;
+ 				input_dev->uniq = hid->uniq;
+ 				input_dev->id.bustype = hid->bus;
+ 				input_dev->id.vendor  = hid->vendor;
+ 				input_dev->id.product = hid->product;
+ 				input_dev->id.version = hid->version;
+ 				hidinput->input = input_dev;
+ 				list_add_tail(&hidinput->list, &hid->inputs);
  			}
  
  			for (i = 0; i < report->maxfield; i++)
***************
*** 1460,1469 ****
  					hidinput_configure_usage(hidinput, report->field[i],
  								 report->field[i]->usage + j);
  
- 			if ((hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
- 			    !hidinput_has_been_populated(hidinput))
- 				continue;
- 
  			if (hid->quirks & HID_QUIRK_MULTI_INPUT) {
  				/* This will leave hidinput NULL, so that it
  				 * allocates another one if we have more inputs on
--- 981,986 ----
***************
*** 1471,1478 ****
  				 * UGCI) cram a lot of unrelated inputs into the
  				 * same interface. */
  				hidinput->report = report;
- 				if (drv->input_configured)
- 					drv->input_configured(hid, hidinput);
  				if (input_register_device(hidinput->input))
  					goto out_cleanup;
  				hidinput = NULL;
--- 988,993 ----
***************
*** 1480,1503 ****
  		}
  	}
  
! 	if (hidinput && (hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&
! 	    !hidinput_has_been_populated(hidinput)) {
! 		/* no need to register an input device not populated */
! 		hidinput_cleanup_hidinput(hid, hidinput);
! 		hidinput = NULL;
! 	}
! 
! 	if (list_empty(&hid->inputs)) {
! 		hid_err(hid, "No inputs registered, leaving\n");
! 		goto out_unwind;
! 	}
! 
! 	if (hidinput) {
! 		if (drv->input_configured)
! 			drv->input_configured(hid, hidinput);
! 		if (input_register_device(hidinput->input))
! 			goto out_cleanup;
! 	}
  
  	return 0;
  
--- 995,1002 ----
  		}
  	}
  
! 	if (hidinput && input_register_device(hidinput->input))
! 		goto out_cleanup;
  
  	return 0;
  
***************
*** 1524,1535 ****
  		input_unregister_device(hidinput->input);
  		kfree(hidinput);
  	}
- 
- 	/* led_work is spawned by input_dev callbacks, but doesn't access the
- 	 * parent input_dev at all. Once all input devices are removed, we
- 	 * know that led_work will never get restarted, so we can cancel it
- 	 * synchronously and are safe. */
- 	cancel_work_sync(&hid->led_work);
  }
  EXPORT_SYMBOL_GPL(hidinput_disconnect);
  
--- 1023,1028 ----
diff -crB ln12Mar/hv/hv_balloon.c hv-rhel7.x/hv/hv_balloon.c
*** ln12Mar/hv/hv_balloon.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/hv_balloon.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 32,38 ****
  #include <linux/notifier.h>
  #include <linux/percpu_counter.h>
  
! #include <linux/hyperv.h>
  
  /*
   * We begin with definitions supporting the Dynamic Memory protocol
--- 32,38 ----
  #include <linux/notifier.h>
  #include <linux/percpu_counter.h>
  
! #include "./include/linux/hyperv.h"
  
  /*
   * We begin with definitions supporting the Dynamic Memory protocol
***************
*** 428,441 ****
   * currently hot added. We hot add in multiples of 128M
   * chunks; it is possible that we may not be able to bring
   * online all the pages in the region. The range
!  * covered_start_pfn : covered_end_pfn defines the pages that can
   * be brough online.
   */
  
  struct hv_hotadd_state {
  	struct list_head list;
  	unsigned long start_pfn;
- 	unsigned long covered_start_pfn;
  	unsigned long covered_end_pfn;
  	unsigned long ha_end_pfn;
  	unsigned long end_pfn;
--- 428,440 ----
   * currently hot added. We hot add in multiples of 128M
   * chunks; it is possible that we may not be able to bring
   * online all the pages in the region. The range
!  * covered_end_pfn defines the pages that can
   * be brough online.
   */
  
  struct hv_hotadd_state {
  	struct list_head list;
  	unsigned long start_pfn;
  	unsigned long covered_end_pfn;
  	unsigned long ha_end_pfn;
  	unsigned long end_pfn;
***************
*** 503,508 ****
--- 502,509 ----
  	 * Number of pages we have currently ballooned out.
  	 */
  	unsigned int num_pages_ballooned;
+ 	unsigned int num_pages_onlined;
+ 	unsigned int num_pages_added;
  
  	/*
  	 * State to manage the ballooning (up) operation.
***************
*** 534,540 ****
  	struct task_struct *thread;
  
  	struct mutex ha_region_mutex;
- 	struct completion waiter_event;
  
  	/*
  	 * A list of hot-add regions.
--- 535,540 ----
***************
*** 554,599 ****
  static void post_status(struct hv_dynmem_device *dm);
  
  #ifdef CONFIG_MEMORY_HOTPLUG
- static void acquire_region_mutex(bool trylock)
- {
- 	if (trylock) {
- 		reinit_completion(&dm_device.waiter_event);
- 		while (!mutex_trylock(&dm_device.ha_region_mutex))
- 			wait_for_completion(&dm_device.waiter_event);
- 	} else {
- 		mutex_lock(&dm_device.ha_region_mutex);
- 	}
- }
- 
- static void release_region_mutex(bool trylock)
- {
- 	if (trylock) {
- 		mutex_unlock(&dm_device.ha_region_mutex);
- 	} else {
- 		mutex_unlock(&dm_device.ha_region_mutex);
- 		complete(&dm_device.waiter_event);
- 	}
- }
- 
  static int hv_memory_notifier(struct notifier_block *nb, unsigned long val,
  			      void *v)
  {
  	switch (val) {
  	case MEM_GOING_ONLINE:
! 		acquire_region_mutex(true);
  		break;
  
  	case MEM_ONLINE:
  	case MEM_CANCEL_ONLINE:
! 		release_region_mutex(true);
  		if (dm_device.ha_waiting) {
  			dm_device.ha_waiting = false;
  			complete(&dm_device.ol_waitevent);
  		}
  		break;
  
- 	case MEM_GOING_OFFLINE:
  	case MEM_OFFLINE:
  	case MEM_CANCEL_OFFLINE:
  		break;
  	}
--- 554,585 ----
  static void post_status(struct hv_dynmem_device *dm);
  
  #ifdef CONFIG_MEMORY_HOTPLUG
  static int hv_memory_notifier(struct notifier_block *nb, unsigned long val,
  			      void *v)
  {
+ 	struct memory_notify *mem = (struct memory_notify *)v;
+ 
  	switch (val) {
  	case MEM_GOING_ONLINE:
! 		mutex_lock(&dm_device.ha_region_mutex);
  		break;
  
  	case MEM_ONLINE:
+ 		dm_device.num_pages_onlined += mem->nr_pages;
  	case MEM_CANCEL_ONLINE:
! 		mutex_unlock(&dm_device.ha_region_mutex);
  		if (dm_device.ha_waiting) {
  			dm_device.ha_waiting = false;
  			complete(&dm_device.ol_waitevent);
  		}
  		break;
  
  	case MEM_OFFLINE:
+ 		mutex_lock(&dm_device.ha_region_mutex);
+ 		dm_device.num_pages_onlined -= mem->nr_pages;
+ 		mutex_unlock(&dm_device.ha_region_mutex);
+ 		break;
+ 	case MEM_GOING_OFFLINE:
  	case MEM_CANCEL_OFFLINE:
  		break;
  	}
***************
*** 646,652 ****
  		init_completion(&dm_device.ol_waitevent);
  		dm_device.ha_waiting = true;
  
! 		release_region_mutex(false);
  		nid = memory_add_physaddr_to_nid(PFN_PHYS(start_pfn));
  		ret = add_memory(nid, PFN_PHYS((start_pfn)),
  				(HA_CHUNK << PAGE_SHIFT));
--- 632,638 ----
  		init_completion(&dm_device.ol_waitevent);
  		dm_device.ha_waiting = true;
  
! 		mutex_unlock(&dm_device.ha_region_mutex);
  		nid = memory_add_physaddr_to_nid(PFN_PHYS(start_pfn));
  		ret = add_memory(nid, PFN_PHYS((start_pfn)),
  				(HA_CHUNK << PAGE_SHIFT));
***************
*** 665,670 ****
--- 651,657 ----
  			}
  			has->ha_end_pfn -= HA_CHUNK;
  			has->covered_end_pfn -=  processed_pfn;
+ 			mutex_lock(&dm_device.ha_region_mutex);
  			break;
  		}
  
***************
*** 675,681 ****
  		 * have not been "onlined" within the allowed time.
  		 */
  		wait_for_completion_timeout(&dm_device.ol_waitevent, 5*HZ);
! 		acquire_region_mutex(false);
  		post_status(&dm_device);
  	}
  
--- 662,668 ----
  		 * have not been "onlined" within the allowed time.
  		 */
  		wait_for_completion_timeout(&dm_device.ol_waitevent, 5*HZ);
! 		mutex_lock(&dm_device.ha_region_mutex);
  		post_status(&dm_device);
  	}
  
***************
*** 691,698 ****
  
  	list_for_each(cur, &dm_device.ha_region_list) {
  		has = list_entry(cur, struct hv_hotadd_state, list);
! 		cur_start_pgp = (unsigned long)
! 				pfn_to_page(has->covered_start_pfn);
  		cur_end_pgp = (unsigned long)pfn_to_page(has->covered_end_pfn);
  
  		if (((unsigned long)pg >= cur_start_pgp) &&
--- 678,684 ----
  
  	list_for_each(cur, &dm_device.ha_region_list) {
  		has = list_entry(cur, struct hv_hotadd_state, list);
! 		cur_start_pgp = (unsigned long)pfn_to_page(has->start_pfn);
  		cur_end_pgp = (unsigned long)pfn_to_page(has->covered_end_pfn);
  
  		if (((unsigned long)pg >= cur_start_pgp) &&
***************
*** 704,710 ****
  			__online_page_set_limits(pg);
  			__online_page_increment_counters(pg);
  			__online_page_free(pg);
- 			has->covered_start_pfn++;
  		}
  	}
  }
--- 690,695 ----
***************
*** 748,757 ****
  		 * is, update it.
  		 */
  
! 		if (has->covered_end_pfn != start_pfn) {
  			has->covered_end_pfn = start_pfn;
! 			has->covered_start_pfn = start_pfn;
! 		}
  		return true;
  
  	}
--- 733,741 ----
  		 * is, update it.
  		 */
  
! 		if (has->covered_end_pfn != start_pfn)
  			has->covered_end_pfn = start_pfn;
! 
  		return true;
  
  	}
***************
*** 794,802 ****
  			pgs_ol = has->ha_end_pfn - start_pfn;
  			if (pgs_ol > pfn_cnt)
  				pgs_ol = pfn_cnt;
! 			hv_bring_pgs_online(start_pfn, pgs_ol);
  			has->covered_end_pfn +=  pgs_ol;
- 			has->covered_start_pfn +=  pgs_ol;
  			pfn_cnt -= pgs_ol;
  		}
  
--- 778,795 ----
  			pgs_ol = has->ha_end_pfn - start_pfn;
  			if (pgs_ol > pfn_cnt)
  				pgs_ol = pfn_cnt;
! 
! 			/*
! 			 * Check if the corresponding memory block is already
! 			 * online by checking its last previously backed page.
! 			 * In case it is we need to bring rest (which was not
! 			 * backed previously) online too.
! 			 */
! 			if (start_pfn > has->start_pfn &&
! 			    !PageReserved(pfn_to_page(start_pfn - 1)))
! 				hv_bring_pgs_online(start_pfn, pgs_ol);
! 
  			has->covered_end_pfn +=  pgs_ol;
  			pfn_cnt -= pgs_ol;
  		}
  
***************
*** 857,863 ****
  		list_add_tail(&ha_region->list, &dm_device.ha_region_list);
  		ha_region->start_pfn = rg_start;
  		ha_region->ha_end_pfn = rg_start;
- 		ha_region->covered_start_pfn = pg_start;
  		ha_region->covered_end_pfn = pg_start;
  		ha_region->end_pfn = rg_start + rg_size;
  	}
--- 850,855 ----
***************
*** 886,892 ****
  	resp.hdr.size = sizeof(struct dm_hot_add_response);
  
  #ifdef CONFIG_MEMORY_HOTPLUG
! 	acquire_region_mutex(false);
  	pg_start = dm->ha_wrk.ha_page_range.finfo.start_page;
  	pfn_cnt = dm->ha_wrk.ha_page_range.finfo.page_cnt;
  
--- 878,884 ----
  	resp.hdr.size = sizeof(struct dm_hot_add_response);
  
  #ifdef CONFIG_MEMORY_HOTPLUG
! 	mutex_lock(&dm_device.ha_region_mutex);
  	pg_start = dm->ha_wrk.ha_page_range.finfo.start_page;
  	pfn_cnt = dm->ha_wrk.ha_page_range.finfo.page_cnt;
  
***************
*** 918,924 ****
  	if (do_hot_add)
  		resp.page_count = process_hot_add(pg_start, pfn_cnt,
  						rg_start, rg_sz);
! 	release_region_mutex(false);
  #endif
  	/*
  	 * The result field of the response structure has the
--- 910,918 ----
  	if (do_hot_add)
  		resp.page_count = process_hot_add(pg_start, pfn_cnt,
  						rg_start, rg_sz);
! 
! 	dm->num_pages_added += resp.page_count;
! 	mutex_unlock(&dm_device.ha_region_mutex);
  #endif
  	/*
  	 * The result field of the response structure has the
***************
*** 982,989 ****
  	 *     128        72    (1/2)
  	 *     512       168    (1/4)
  	 *    2048       360    (1/8)
! 	 *    8192       768    (1/16)
! 	 *   32768      1536	(1/32)
  	 */
  	if (totalram_pages < MB2PAGES(128))
  		min_pages = MB2PAGES(8) + (totalram_pages >> 1);
--- 976,983 ----
  	 *     128        72    (1/2)
  	 *     512       168    (1/4)
  	 *    2048       360    (1/8)
! 	 *    8192       744    (1/16)
! 	 *   32768      1512	(1/32)
  	 */
  	if (totalram_pages < MB2PAGES(128))
  		min_pages = MB2PAGES(8) + (totalram_pages >> 1);
***************
*** 992,1000 ****
  	else if (totalram_pages < MB2PAGES(2048))
  		min_pages = MB2PAGES(104) + (totalram_pages >> 3);
  	else if (totalram_pages < MB2PAGES(8192))
! 		min_pages = MB2PAGES(256) + (totalram_pages >> 4);
  	else
! 		min_pages = MB2PAGES(512) + (totalram_pages >> 5);
  #undef MB2PAGES
  	return min_pages;
  }
--- 986,994 ----
  	else if (totalram_pages < MB2PAGES(2048))
  		min_pages = MB2PAGES(104) + (totalram_pages >> 3);
  	else if (totalram_pages < MB2PAGES(8192))
! 		min_pages = MB2PAGES(232) + (totalram_pages >> 4);
  	else
! 		min_pages = MB2PAGES(488) + (totalram_pages >> 5);
  #undef MB2PAGES
  	return min_pages;
  }
***************
*** 1031,1047 ****
  	status.hdr.trans_id = atomic_inc_return(&trans_id);
  
  	/*
! 	 * The host expects the guest to report free memory.
! 	 * Further, the host expects the pressure information to
! 	 * include the ballooned out pages.
! 	 * For a given amount of memory that we are managing, we
! 	 * need to compute a floor below which we should not balloon.
! 	 * Compute this and add it to the pressure report.
  	 */
  	status.num_avail = val.freeram;
! 	status.num_committed = vm_memory_committed() +
! 				dm->num_pages_ballooned +
! 				compute_balloon_floor();
  
  	/*
  	 * If our transaction ID is no longer current, just don't
--- 1025,1045 ----
  	status.hdr.trans_id = atomic_inc_return(&trans_id);
  
  	/*
! 	 * The host expects the guest to report free and committed memory.
! 	 * Furthermore, the host expects the pressure information to include
! 	 * the ballooned out pages. For a given amount of memory that we are
! 	 * managing we need to compute a floor below which we should not
! 	 * balloon. Compute this and add it to the pressure report.
! 	 * We also need to report all offline pages (num_pages_added -
! 	 * num_pages_onlined) as committed to the host, otherwise it can try
! 	 * asking us to balloon them out.
  	 */
  	status.num_avail = val.freeram;
! 	status.num_committed = (val.totalram - val.freeram) +
! 		dm->num_pages_ballooned +
! 		(dm->num_pages_added > dm->num_pages_onlined ?
! 		 dm->num_pages_added - dm->num_pages_onlined : 0) +
! 		compute_balloon_floor();
  
  	/*
  	 * If our transaction ID is no longer current, just don't
***************
*** 1083,1093 ****
  
  
  
! static int  alloc_balloon_pages(struct hv_dynmem_device *dm, int num_pages,
! 			 struct dm_balloon_response *bl_resp, int alloc_unit,
! 			 bool *alloc_error)
  {
! 	int i = 0;
  	struct page *pg;
  
  	if (num_pages < alloc_unit)
--- 1081,1092 ----
  
  
  
! static unsigned int alloc_balloon_pages(struct hv_dynmem_device *dm,
! 					unsigned int num_pages,
! 					struct dm_balloon_response *bl_resp,
! 					int alloc_unit)
  {
! 	unsigned int i = 0;
  	struct page *pg;
  
  	if (num_pages < alloc_unit)
***************
*** 1106,1116 ****
  				__GFP_NOMEMALLOC | __GFP_NOWARN,
  				get_order(alloc_unit << PAGE_SHIFT));
  
! 		if (!pg) {
! 			*alloc_error = true;
  			return i * alloc_unit;
- 		}
- 
  
  		dm->num_pages_ballooned += alloc_unit;
  
--- 1105,1112 ----
  				__GFP_NOMEMALLOC | __GFP_NOWARN,
  				get_order(alloc_unit << PAGE_SHIFT));
  
! 		if (!pg)
  			return i * alloc_unit;
  
  		dm->num_pages_ballooned += alloc_unit;
  
***************
*** 1119,1126 ****
--- 1115,1124 ----
  		 * can free them in any order we get.
  		 */
  
+ #if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1540)
  		if (alloc_unit != 1)
  			split_page(pg, get_order(alloc_unit << PAGE_SHIFT));
+ #endif
  
  		bl_resp->range_count++;
  		bl_resp->range_array[i].finfo.start_page =
***************
*** 1137,1150 ****
  
  static void balloon_up(struct work_struct *dummy)
  {
! 	int num_pages = dm_device.balloon_wrk.num_pages;
! 	int num_ballooned = 0;
  	struct dm_balloon_response *bl_resp;
  	int alloc_unit;
  	int ret;
- 	bool alloc_error;
  	bool done = false;
  	int i;
  
  	/* The host balloons pages in 2M granularity. */
  	WARN_ON_ONCE(num_pages % PAGES_IN_2M != 0);
--- 1135,1149 ----
  
  static void balloon_up(struct work_struct *dummy)
  {
! 	unsigned int num_pages = dm_device.balloon_wrk.num_pages;
! 	unsigned int num_ballooned = 0;
  	struct dm_balloon_response *bl_resp;
  	int alloc_unit;
  	int ret;
  	bool done = false;
  	int i;
+ 	struct sysinfo val;
+ 	unsigned long floor;
  
  	/* The host balloons pages in 2M granularity. */
  	WARN_ON_ONCE(num_pages % PAGES_IN_2M != 0);
***************
*** 1153,1159 ****
--- 1152,1171 ----
  	 * We will attempt 2M allocations. However, if we fail to
  	 * allocate 2M chunks, we will go back to 4k allocations.
  	 */
+ #if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1540)
  	alloc_unit = 512;
+ #else
+ 	alloc_unit = 1;
+ #endif
+ 
+ 	si_meminfo(&val);
+ 	floor = compute_balloon_floor();
+ 
+ 	/* Refuse to balloon below the floor, keep the 2M granularity. */
+ 	if (val.freeram < num_pages || val.freeram - num_pages < floor) {
+ 		num_pages = val.freeram > floor ? (val.freeram - floor) : 0;
+ 		num_pages -= num_pages % PAGES_IN_2M;
+ 	}
  
  	while (!done) {
  		bl_resp = (struct dm_balloon_response *)send_buffer;
***************
*** 1164,1181 ****
  
  
  		num_pages -= num_ballooned;
- 		alloc_error = false;
  		num_ballooned = alloc_balloon_pages(&dm_device, num_pages,
! 						bl_resp, alloc_unit,
! 						 &alloc_error);
  
  		if (alloc_unit != 1 && num_ballooned == 0) {
  			alloc_unit = 1;
  			continue;
  		}
  
! 		if ((alloc_unit == 1 && alloc_error) ||
! 			(num_ballooned == num_pages)) {
  			bl_resp->more_pages = 0;
  			done = true;
  			dm_device.state = DM_INITIALIZED;
--- 1176,1190 ----
  
  
  		num_pages -= num_ballooned;
  		num_ballooned = alloc_balloon_pages(&dm_device, num_pages,
! 						    bl_resp, alloc_unit);
  
  		if (alloc_unit != 1 && num_ballooned == 0) {
  			alloc_unit = 1;
  			continue;
  		}
  
! 		if (num_ballooned == 0 || num_ballooned == num_pages) {
  			bl_resp->more_pages = 0;
  			done = true;
  			dm_device.state = DM_INITIALIZED;
***************
*** 1258,1264 ****
  		 * The host expects us to post information on the memory
  		 * pressure every second.
  		 */
! 		reinit_completion(&dm_device.config_event);
  		post_status(dm);
  	}
  
--- 1267,1274 ----
  		 * The host expects us to post information on the memory
  		 * pressure every second.
  		 */
! 		//KYSreinit_completion(&dm_device.config_event);
! 		dm_device.config_event.done = 0;
  		post_status(dm);
  	}
  
***************
*** 1414,1425 ****
  static int balloon_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
  {
! 	int ret, t;
  	struct dm_version_request version_req;
  	struct dm_capabilities cap_msg;
  
  	do_hot_add = hot_add;
  
  	/*
  	 * First allocate a send buffer.
  	 */
--- 1424,1438 ----
  static int balloon_probe(struct hv_device *dev,
  			const struct hv_vmbus_device_id *dev_id)
  {
! 	int ret;
! 	unsigned long t;
  	struct dm_version_request version_req;
  	struct dm_capabilities cap_msg;
  
  	do_hot_add = hot_add;
  
+ 	last_post_time = jiffies;
+ 
  	/*
  	 * First allocate a send buffer.
  	 */
***************
*** 1439,1445 ****
  	dm_device.next_version = DYNMEM_PROTOCOL_VERSION_WIN7;
  	init_completion(&dm_device.host_event);
  	init_completion(&dm_device.config_event);
- 	init_completion(&dm_device.waiter_event);
  	INIT_LIST_HEAD(&dm_device.ha_region_list);
  	mutex_init(&dm_device.ha_region_mutex);
  	INIT_WORK(&dm_device.balloon_wrk.wrk, balloon_up);
--- 1452,1457 ----
***************
*** 1611,1613 ****
--- 1623,1627 ----
  
  MODULE_DESCRIPTION("Hyper-V Balloon");
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
+ MODULE_ALIAS("vmbus:dc7450528589e2468057a307dc18a502");
diff -crB ln12Mar/hv/hv.c hv-rhel7.x/hv/hv.c
*** ln12Mar/hv/hv.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/hv.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 25,36 ****
  #include <linux/mm.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
! #include <linux/hyperv.h>
  #include <linux/version.h>
  #include <linux/interrupt.h>
  #include <linux/clockchips.h>
! #include <asm/hyperv.h>
! #include <asm/mshyperv.h>
  #include "hyperv_vmbus.h"
  
  /* The one and only */
--- 25,36 ----
  #include <linux/mm.h>
  #include <linux/slab.h>
  #include <linux/vmalloc.h>
! #include "include/linux/hyperv.h"
  #include <linux/version.h>
  #include <linux/interrupt.h>
  #include <linux/clockchips.h>
! #include "include/asm/hyperv.h"
! #include "include/asm/mshyperv.h"
  #include "hyperv_vmbus.h"
  
  /* The one and only */
***************
*** 458,463 ****
--- 458,464 ----
  
  	INIT_LIST_HEAD(&hv_context.percpu_list[cpu]);
  
+ #ifdef NOTYET
  	/*
  	 * Register the per-cpu clockevent source.
  	 */
***************
*** 466,471 ****
--- 467,473 ----
  						HV_TIMER_FREQUENCY,
  						HV_MIN_DELTA_TICKS,
  						HV_MAX_MAX_DELTA_TICKS);
+ #endif
  	return;
  }
  
Only in hv-rhel7.x/hv/: hv_compat.c
diff -crB ln12Mar/hv/hv_fcopy.c hv-rhel7.x/hv/hv_fcopy.c
*** ln12Mar/hv/hv_fcopy.c	2015-05-14 07:07:08.000000000 -0700
--- hv-rhel7.x/hv/hv_fcopy.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 24,30 ****
  #include <linux/nls.h>
  #include <linux/workqueue.h>
  #include <linux/cdev.h>
! #include <linux/hyperv.h>
  #include <linux/sched.h>
  #include <linux/uaccess.h>
  #include <linux/miscdevice.h>
--- 24,30 ----
  #include <linux/nls.h>
  #include <linux/workqueue.h>
  #include <linux/cdev.h>
! #include "include/linux/hyperv.h"
  #include <linux/sched.h>
  #include <linux/uaccess.h>
  #include <linux/miscdevice.h>
diff -crB ln12Mar/hv/hv_kvp.c hv-rhel7.x/hv/hv_kvp.c
*** ln12Mar/hv/hv_kvp.c	2015-05-14 07:07:08.000000000 -0700
--- hv-rhel7.x/hv/hv_kvp.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 26,32 ****
  #include <linux/nls.h>
  #include <linux/connector.h>
  #include <linux/workqueue.h>
! #include <linux/hyperv.h>
  
  
  /*
--- 26,32 ----
  #include <linux/nls.h>
  #include <linux/connector.h>
  #include <linux/workqueue.h>
! #include "include/linux/hyperv.h"
  
  
  /*
***************
*** 92,98 ****
   * As part of this registration, pass the LIC version number.
   * This number has no meaning, it satisfies the registration protocol.
   */
! #define HV_DRV_VERSION           "3.1"
  
  static void
  kvp_register(int reg_value)
--- 92,98 ----
   * As part of this registration, pass the LIC version number.
   * This number has no meaning, it satisfies the registration protocol.
   */
! //#define HV_DRV_VERSION           "3.1"
  
  static void
  kvp_register(int reg_value)
***************
*** 113,119 ****
  		kvp_msg->kvp_hdr.operation = reg_value;
  		strcpy(version, HV_DRV_VERSION);
  		msg->len = sizeof(struct hv_kvp_msg);
! 		cn_netlink_send(msg, 0, 0, GFP_ATOMIC);
  		kfree(msg);
  	}
  }
--- 113,119 ----
  		kvp_msg->kvp_hdr.operation = reg_value;
  		strcpy(version, HV_DRV_VERSION);
  		msg->len = sizeof(struct hv_kvp_msg);
! 		cn_netlink_send(msg, 0, GFP_ATOMIC);
  		kfree(msg);
  	}
  }
***************
*** 447,453 ****
  	}
  
  	msg->len = sizeof(struct hv_kvp_msg);
! 	rc = cn_netlink_send(msg, 0, 0, GFP_ATOMIC);
  	if (rc) {
  		pr_debug("KVP: failed to communicate to the daemon: %d\n", rc);
  		if (cancel_delayed_work_sync(&kvp_work))
--- 447,453 ----
  	}
  
  	msg->len = sizeof(struct hv_kvp_msg);
! 	rc = cn_netlink_send(msg, 0, GFP_ATOMIC);
  	if (rc) {
  		pr_debug("KVP: failed to communicate to the daemon: %d\n", rc);
  		if (cancel_delayed_work_sync(&kvp_work))
diff -crB ln12Mar/hv/hv_snapshot.c hv-rhel7.x/hv/hv_snapshot.c
*** ln12Mar/hv/hv_snapshot.c	2015-05-14 07:07:08.000000000 -0700
--- hv-rhel7.x/hv/hv_snapshot.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 22,28 ****
  #include <linux/nls.h>
  #include <linux/connector.h>
  #include <linux/workqueue.h>
! #include <linux/hyperv.h>
  
  #define VSS_MAJOR  5
  #define VSS_MINOR  0
--- 22,28 ----
  #include <linux/nls.h>
  #include <linux/connector.h>
  #include <linux/workqueue.h>
! #include "include/linux/hyperv.h"
  
  #define VSS_MAJOR  5
  #define VSS_MINOR  0
***************
*** 112,118 ****
  	vss_msg->vss_hdr.operation = op;
  	msg->len = sizeof(struct hv_vss_msg);
  
! 	rc = cn_netlink_send(msg, 0, 0, GFP_ATOMIC);
  	if (rc) {
  		pr_warn("VSS: failed to communicate to the daemon: %d\n", rc);
  		if (cancel_delayed_work_sync(&vss_timeout_work))
--- 112,118 ----
  	vss_msg->vss_hdr.operation = op;
  	msg->len = sizeof(struct hv_vss_msg);
  
! 	rc = cn_netlink_send(msg, 0, GFP_ATOMIC);
  	if (rc) {
  		pr_warn("VSS: failed to communicate to the daemon: %d\n", rc);
  		if (cancel_delayed_work_sync(&vss_timeout_work))
Only in hv-rhel7.x/hv/: hv_timesource.c
diff -crB ln12Mar/hv/hv_util.c hv-rhel7.x/hv/hv_util.c
*** ln12Mar/hv/hv_util.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/hv_util.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 26,32 ****
  #include <linux/slab.h>
  #include <linux/sysctl.h>
  #include <linux/reboot.h>
! #include <linux/hyperv.h>
  
  #include "hyperv_vmbus.h"
  
--- 26,32 ----
  #include <linux/slab.h>
  #include <linux/sysctl.h>
  #include <linux/reboot.h>
! #include "include/linux/hyperv.h"
  
  #include "hyperv_vmbus.h"
  
***************
*** 444,446 ****
--- 444,447 ----
  
  MODULE_DESCRIPTION("Hyper-V Utilities");
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
diff -crB ln12Mar/hv/hyperv_fb.c hv-rhel7.x/hv/hyperv_fb.c
*** ln12Mar/hv/hyperv_fb.c	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/hyperv_fb.c	2015-05-14 07:05:22.419085021 -0700
***************
*** 44,50 ****
  #include <linux/pci.h>
  #include <linux/efi.h>
  
! #include <linux/hyperv.h>
  
  
  /* Hyper-V Synthetic Video Protocol definitions and structures */
--- 44,50 ----
  #include <linux/pci.h>
  #include <linux/efi.h>
  
! #include "include/linux/hyperv.h"
  
  
  /* Hyper-V Synthetic Video Protocol definitions and structures */
***************
*** 960,963 ****
--- 960,964 ----
  module_exit(hvfb_drv_exit);
  
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
  MODULE_DESCRIPTION("Microsoft Hyper-V Synthetic Video Frame Buffer Driver");
diff -crB ln12Mar/hv/hyperv-keyboard.c hv-rhel7.x/hv/hyperv-keyboard.c
*** ln12Mar/hv/hyperv-keyboard.c	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/hyperv-keyboard.c	2015-05-14 07:05:22.418084977 -0700
***************
*** 15,21 ****
  #include <linux/module.h>
  #include <linux/device.h>
  #include <linux/completion.h>
! #include <linux/hyperv.h>
  #include <linux/serio.h>
  #include <linux/slab.h>
  
--- 15,21 ----
  #include <linux/module.h>
  #include <linux/device.h>
  #include <linux/completion.h>
! #include "include/linux/hyperv.h"
  #include <linux/serio.h>
  #include <linux/slab.h>
  
***************
*** 448,452 ****
--- 448,454 ----
  }
  
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
+ 
  module_init(hv_kbd_init);
  module_exit(hv_kbd_exit);
diff -crB ln12Mar/hv/hyperv_net.h hv-rhel7.x/hv/hyperv_net.h
*** ln12Mar/hv/hyperv_net.h	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/hyperv_net.h	2015-05-14 07:05:22.419085021 -0700
***************
*** 25,32 ****
  #define _HYPERV_NET_H
  
  #include <linux/list.h>
! #include <linux/hyperv.h>
! #include <linux/rndis.h>
  
  /* RSS related */
  #define OID_GEN_RECEIVE_SCALE_CAPABILITIES 0x00010203  /* query only */
--- 25,32 ----
  #define _HYPERV_NET_H
  
  #include <linux/list.h>
! #include "include/linux/hyperv.h"
! #include "include/linux/rndis.h"
  
  /* RSS related */
  #define OID_GEN_RECEIVE_SCALE_CAPABILITIES 0x00010203  /* query only */
diff -crB ln12Mar/hv/hyperv_vmbus.h hv-rhel7.x/hv/hyperv_vmbus.h
*** ln12Mar/hv/hyperv_vmbus.h	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/hyperv_vmbus.h	2015-05-14 07:05:22.419085021 -0700
***************
*** 28,34 ****
  #include <linux/list.h>
  #include <asm/sync_bitops.h>
  #include <linux/atomic.h>
! #include <linux/hyperv.h>
  
  /*
   * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
--- 28,34 ----
  #include <linux/list.h>
  #include <asm/sync_bitops.h>
  #include <linux/atomic.h>
! #include "include/linux/hyperv.h"
  
  /*
   * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
Only in ln12Mar/hv/include/asm: linux
diff -crB ln12Mar/hv/include/linux/atomic.h hv-rhel7.x/hv/include/linux/atomic.h
*** ln12Mar/hv/include/linux/atomic.h	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/include/linux/atomic.h	2015-05-14 07:05:22.419085021 -0700
***************
*** 1,7 ****
  /* Atomic operations usable in machine independent code */
  #ifndef _LINUX_ATOMIC_H
  #define _LINUX_ATOMIC_H
! #include <asm/atomic.h>
  
  /**
   * atomic_add_unless - add unless the number is already a given value
--- 1,7 ----
  /* Atomic operations usable in machine independent code */
  #ifndef _LINUX_ATOMIC_H
  #define _LINUX_ATOMIC_H
! #include <asm-generic/atomic.h>
  
  /**
   * atomic_add_unless - add unless the number is already a given value
Only in hv-rhel7.x/hv/include/linux: hid-debug.h
Only in hv-rhel7.x/hv/include/linux: hid.h
Only in hv-rhel7.x/hv/include/linux: hidraw.h
Only in hv-rhel7.x/hv/include/linux: hv_compat.h
diff -crB ln12Mar/hv/include/linux/hyperv.h hv-rhel7.x/hv/include/linux/hyperv.h
*** ln12Mar/hv/include/linux/hyperv.h	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/include/linux/hyperv.h	2015-05-14 07:05:22.420085066 -0700
***************
*** 25,31 ****
  #ifndef _HYPERV_H
  #define _HYPERV_H
  
! #include <uapi/linux/hyperv.h>
  
  #include <linux/types.h>
  #include <linux/scatterlist.h>
--- 25,31 ----
  #ifndef _HYPERV_H
  #define _HYPERV_H
  
! #include "../uapi/linux/hyperv.h"
  
  #include <linux/types.h>
  #include <linux/scatterlist.h>
diff -crB ln12Mar/hv/include/linux/uuid.h hv-rhel7.x/hv/include/linux/uuid.h
*** ln12Mar/hv/include/linux/uuid.h	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/include/linux/uuid.h	2015-05-14 07:05:22.421085111 -0700
***************
*** 20,26 ****
  #ifndef _LINUX_UUID_H_
  #define _LINUX_UUID_H_
  
! #include <uapi/linux/uuid.h>
  
  
  static inline int uuid_le_cmp(const uuid_le u1, const uuid_le u2)
--- 20,26 ----
  #ifndef _LINUX_UUID_H_
  #define _LINUX_UUID_H_
  
! #include "../uapi/linux/uuid.h"
  
  
  static inline int uuid_le_cmp(const uuid_le u1, const uuid_le u2)
diff -crB ln12Mar/hv/include/uapi/linux/hyperv.h hv-rhel7.x/hv/include/uapi/linux/hyperv.h
*** ln12Mar/hv/include/uapi/linux/hyperv.h	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/include/uapi/linux/hyperv.h	2015-05-14 07:05:22.421085111 -0700
***************
*** 27,32 ****
--- 27,37 ----
  
  #include <linux/uuid.h>
  
+ #include <linux/version.h>
+ #if LINUX_VERSION_CODE <= KERNEL_VERSION(3,10,0)
+ #include "../../linux/hv_compat.h"
+ #endif
+ 
  /*
   * Framework version for util services.
   */
diff -crB ln12Mar/hv/Makefile hv-rhel7.x/hv/Makefile
*** ln12Mar/hv/Makefile	2015-05-14 07:07:08.000000000 -0700
--- hv-rhel7.x/hv/Makefile	2015-05-14 07:05:22.415084843 -0700
***************
*** 1,8 ****
! obj-$(CONFIG_HYPERV)		+= hv_vmbus.o
! obj-$(CONFIG_HYPERV_UTILS)	+= hv_utils.o
! obj-$(CONFIG_HYPERV_BALLOON)	+= hv_balloon.o
  
  hv_vmbus-y := vmbus_drv.o \
  		 hv.o connection.o channel.o \
  		 channel_mgmt.o ring_buffer.o
  hv_utils-y := hv_util.o hv_kvp.o hv_snapshot.o hv_fcopy.o
--- 1,20 ----
! include $(M)/overrides.mk
! 
! obj-m	+= hv_vmbus.o
! obj-m	+= hv_storvsc.o
! obj-m	+= hv_netvsc.o
! obj-m	+= hv_utils.o
! obj-m	+= hid-hyperv.o
! obj-m	+= hyperv_fb.o
! obj-m	+= hv_balloon.o
! obj-m	+= hyperv-keyboard.o 
  
  hv_vmbus-y := vmbus_drv.o \
  		 hv.o connection.o channel.o \
  		 channel_mgmt.o ring_buffer.o
  hv_utils-y := hv_util.o hv_kvp.o hv_snapshot.o hv_fcopy.o
+ 
+ hv_storvsc-y := storvsc_drv.o
+ hv_netvsc-y := netvsc_drv.o netvsc.o rndis_filter.o
+ hyperv_keyboard-y := hyperv-keyboard.o
+ 
Only in hv-rhel7.x/hv/: mshyperv.c
diff -crB ln12Mar/hv/netvsc_drv.c hv-rhel7.x/hv/netvsc_drv.c
*** ln12Mar/hv/netvsc_drv.c	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/netvsc_drv.c	2015-05-14 07:05:22.422085155 -0700
***************
*** 188,201 ****
  	return ret;
  }
  
! static bool netvsc_set_hash(u32 *hash, struct sk_buff *skb)
  {
  	struct flow_keys flow;
  	int data_len;
  
! 	if (!skb_flow_dissect(skb, &flow) ||
! 	    !(flow.n_proto == htons(ETH_P_IP) ||
! 	      flow.n_proto == htons(ETH_P_IPV6)))
  		return false;
  
  	if (flow.ip_proto == IPPROTO_TCP)
--- 188,203 ----
  	return ret;
  }
  
! bool netvsc_set_hash(u32 *hash, struct sk_buff *skb)
  {
  	struct flow_keys flow;
  	int data_len;
  
! 	//if (!skb_flow_dissect(skb, &flow) ||
! 	//    !(flow.n_proto == htons(ETH_P_IP) ||
! 	//      flow.n_proto == htons(ETH_P_IPV6)))
! 	//	return false;
! 	if (!skb_flow_dissect(skb, &flow))
  		return false;
  
  	if (flow.ip_proto == IPPROTO_TCP)
***************
*** 208,215 ****
  	return true;
  }
  
! static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb,
! 			void *accel_priv, select_queue_fallback_t fallback)
  {
  	struct net_device_context *net_device_ctx = netdev_priv(ndev);
  	struct hv_device *hdev =  net_device_ctx->device_ctx;
--- 210,217 ----
  	return true;
  }
  
! static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb)  //,
! 			// void *accel_priv, select_queue_fallback_t fallback)
  {
  	struct net_device_context *net_device_ctx = netdev_priv(ndev);
  	struct hv_device *hdev =  net_device_ctx->device_ctx;
***************
*** 442,448 ****
  
  	rndis_msg_size = RNDIS_MESSAGE_SIZE(struct rndis_packet);
  
! 	hash = skb_get_hash_raw(skb);
  	if (hash != 0 && net->real_num_tx_queues > 1) {
  		rndis_msg_size += NDIS_HASH_PPI_SIZE;
  		ppi = init_ppi_data(rndis_msg, NDIS_HASH_PPI_SIZE,
--- 444,451 ----
  
  	rndis_msg_size = RNDIS_MESSAGE_SIZE(struct rndis_packet);
  
! 	//hash = skb_get_hash_raw(skb);
! 	hash = skb_get_hash(skb);
  	if (hash != 0 && net->real_num_tx_queues > 1) {
  		rndis_msg_size += NDIS_HASH_PPI_SIZE;
  		ppi = init_ppi_data(rndis_msg, NDIS_HASH_PPI_SIZE,
***************
*** 949,954 ****
--- 952,958 ----
  }
  
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
  MODULE_DESCRIPTION("Microsoft Hyper-V network driver");
  
  module_init(netvsc_drv_init);
diff -crB ln12Mar/hv/ring_buffer.c hv-rhel7.x/hv/ring_buffer.c
*** ln12Mar/hv/ring_buffer.c	2015-05-14 07:07:08.000000000 -0700
--- hv-rhel7.x/hv/ring_buffer.c	2015-05-14 07:05:22.423085200 -0700
***************
*** 25,31 ****
  
  #include <linux/kernel.h>
  #include <linux/mm.h>
! #include <linux/hyperv.h>
  #include <linux/uio.h>
  
  #include "hyperv_vmbus.h"
--- 25,31 ----
  
  #include <linux/kernel.h>
  #include <linux/mm.h>
! #include "include/linux/hyperv.h"
  #include <linux/uio.h>
  
  #include "hyperv_vmbus.h"
diff -crB ln12Mar/hv/rndis_filter.c hv-rhel7.x/hv/rndis_filter.c
*** ln12Mar/hv/rndis_filter.c	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/rndis_filter.c	2015-05-14 07:05:22.423085200 -0700
***************
*** 1135,1142 ****
  	net_device->num_chn = 1 +
  		init_packet->msg.v5_msg.subchn_comp.num_subchannels;
  
- 	vmbus_are_subchannels_present(dev->channel);
- 
  	ret = rndis_filter_set_rss_param(rndis_device, net_device->num_chn);
  
  out:
--- 1135,1140 ----
diff -crB ln12Mar/hv/storvsc_drv.c hv-rhel7.x/hv/storvsc_drv.c
*** ln12Mar/hv/storvsc_drv.c	2015-05-14 08:21:49.000000000 -0700
--- hv-rhel7.x/hv/storvsc_drv.c	2015-05-14 07:05:22.423085200 -0700
***************
*** 31,37 ****
  #include <linux/slab.h>
  #include <linux/module.h>
  #include <linux/device.h>
! #include <linux/hyperv.h>
  #include <linux/blkdev.h>
  #include <scsi/scsi.h>
  #include <scsi/scsi_cmnd.h>
--- 31,39 ----
  #include <linux/slab.h>
  #include <linux/module.h>
  #include <linux/device.h>
! #include "include/linux/hyperv.h"
! #include <linux/mempool.h>
! #include <asm/bug.h>
  #include <linux/blkdev.h>
  #include <scsi/scsi.h>
  #include <scsi/scsi_cmnd.h>
***************
*** 164,169 ****
--- 165,187 ----
  static int vmstor_current_major;
  static int vmstor_current_minor;
  
+ #define STORVSC_LOGGING_NONE   0
+ #define STORVSC_LOGGING_ERROR  1
+ #define STORVSC_LOGGING_WARN   2
+ 
+ static int logging_level = STORVSC_LOGGING_ERROR;
+ module_param(logging_level, int, S_IRUGO|S_IWUSR);
+ MODULE_PARM_DESC(logging_level,
+ 	"Logging level, "
+ 	"0 - None, "
+ 	"1 - Error (default), "
+ 	"2 - Warning.");
+ 
+ inline static bool do_logging(int level)
+ {
+ 	return (logging_level >= level) ? true : false;
+ }
+ 
  struct vmscsi_win8_extension {
  	/*
  	 * The following were added in Windows 8
***************
*** 308,326 ****
   * This is the end of Protocol specific defines.
   */
  
! static int storvsc_ringbuffer_size = (20 * PAGE_SIZE);
  
  module_param(storvsc_ringbuffer_size, int, S_IRUGO);
  MODULE_PARM_DESC(storvsc_ringbuffer_size, "Ring buffer size (bytes)");
  
  /*
   * Timeout in seconds for all devices managed by this driver.
   */
  static int storvsc_timeout = 180;
  
- static int msft_blist_flags = BLIST_TRY_VPD_PAGES;
  
- #define STORVSC_MAX_IO_REQUESTS				200
  
  static void storvsc_on_channel_callback(void *context);
  
--- 326,355 ----
   * This is the end of Protocol specific defines.
   */
  
! 
! /*
!  * We setup a mempool to allocate request structures for this driver
!  * on a per-lun basis. The following define specifies the number of
!  * elements in the pool.
!  */
! 
! #define STORVSC_MIN_BUF_NR				64
! static int storvsc_ringbuffer_size = (256 * PAGE_SIZE);
! static u32 max_outstanding_req_per_channel;
! 
! static int storvsc_vcpus_per_sub_channel = 4;
  
  module_param(storvsc_ringbuffer_size, int, S_IRUGO);
  MODULE_PARM_DESC(storvsc_ringbuffer_size, "Ring buffer size (bytes)");
  
+ module_param(storvsc_vcpus_per_sub_channel, int, S_IRUGO);
+ MODULE_PARM_DESC(vcpus_per_sub_channel, "Ratio of VCPUs to subchannels");
  /*
   * Timeout in seconds for all devices managed by this driver.
   */
  static int storvsc_timeout = 180;
  
  
  
  static void storvsc_on_channel_callback(void *context);
  
***************
*** 337,342 ****
--- 366,372 ----
  #define STORVSC_IDE_MAX_CHANNELS			1
  
  struct storvsc_cmd_request {
+ 	struct list_head entry;
  	struct scsi_cmnd *cmd;
  
  	unsigned int bounce_sgl_count;
***************
*** 347,353 ****
  	/* Synchronize the request/response if needed */
  	struct completion wait_event;
  
! 	struct hv_multipage_buffer data_buffer;
  	struct vstor_packet vstor_packet;
  };
  
--- 377,388 ----
  	/* Synchronize the request/response if needed */
  	struct completion wait_event;
  
! 	unsigned char *sense_buffer;
! 
! 	struct vmbus_channel_packet_multipage_buffer mpb;
! 	struct vmbus_packet_mpb_array *payload;
! 	u32 payload_sz;
! 
  	struct vstor_packet vstor_packet;
  };
  
***************
*** 373,383 ****
--- 408,427 ----
  	unsigned char path_id;
  	unsigned char target_id;
  
+ 	/*
+ 	 * Max I/O, the device can support.
+ 	 */
+ 	u32   max_transfer_bytes;
  	/* Used for vsc/vsp channel reset process */
  	struct storvsc_cmd_request init_request;
  	struct storvsc_cmd_request reset_request;
  };
  
+ struct stor_mem_pools {
+ 	struct kmem_cache *request_pool;
+ 	mempool_t *request_mempool;
+ };
+ 
  struct hv_host_device {
  	struct hv_device *dev;
  	unsigned int port;
***************
*** 410,415 ****
--- 454,474 ----
  	kfree(wrk);
  }
  
+ static void storvsc_bus_scan(struct Scsi_Host *host)
+ {
+ 	int id, order_id;
+ 
+ 	for (id = 0; id < host->max_id; ++id) {
+ 		if (host->reverse_ordering)
+ 			order_id = host->max_id - id - 1;
+ 		else
+ 			order_id = id;
+ 
+ 		scsi_scan_target(&host->shost_gendev, 0,
+ 				 order_id, SCAN_WILD_CARD, 1);
+ 	}
+ }
+ 
  static void storvsc_host_scan(struct work_struct *work)
  {
  	struct storvsc_scan_work *wrk;
***************
*** 444,450 ****
  	/*
  	 * Now scan the host to discover LUNs that may have been added.
  	 */
! 	scsi_scan_host(host);
  
  	kfree(wrk);
  }
--- 503,509 ----
  	/*
  	 * Now scan the host to discover LUNs that may have been added.
  	 */
! 	storvsc_bus_scan(host);
  
  	kfree(wrk);
  }
***************
*** 619,628 ****
  }
  
  /* Disgusting wrapper functions */
! static inline unsigned long sg_kmap_atomic(struct scatterlist *sgl, int idx)
  {
! 	void *addr = kmap_atomic(sg_page(sgl + idx));
! 	return (unsigned long)addr;
  }
  
  static inline void sg_kunmap_atomic(unsigned long addr)
--- 678,686 ----
  }
  
  /* Disgusting wrapper functions */
! static inline unsigned long sg_kmap_atomic(struct scatterlist *sgl)
  {
! 	return (unsigned long)kmap_atomic(sg_page(sgl));
  }
  
  static inline void sg_kunmap_atomic(unsigned long addr)
***************
*** 645,674 ****
  	unsigned long bounce_addr = 0;
  	unsigned long dest_addr = 0;
  	unsigned long flags;
  
  	local_irq_save(flags);
! 
  	for (i = 0; i < orig_sgl_count; i++) {
! 		dest_addr = sg_kmap_atomic(orig_sgl,i) + orig_sgl[i].offset;
  		dest = dest_addr;
! 		destlen = orig_sgl[i].length;
  
  		if (bounce_addr == 0)
! 			bounce_addr = sg_kmap_atomic(bounce_sgl,j);
  
  		while (destlen) {
! 			src = bounce_addr + bounce_sgl[j].offset;
! 			srclen = bounce_sgl[j].length - bounce_sgl[j].offset;
  
  			copylen = min(srclen, destlen);
  			memcpy((void *)dest, (void *)src, copylen);
  
  			total_copied += copylen;
! 			bounce_sgl[j].offset += copylen;
  			destlen -= copylen;
  			dest += copylen;
  
! 			if (bounce_sgl[j].offset == bounce_sgl[j].length) {
  				/* full */
  				sg_kunmap_atomic(bounce_addr);
  				j++;
--- 703,735 ----
  	unsigned long bounce_addr = 0;
  	unsigned long dest_addr = 0;
  	unsigned long flags;
+ 	struct scatterlist *cur_dest_sgl;
+ 	struct scatterlist *cur_src_sgl;
  
  	local_irq_save(flags);
! 	cur_dest_sgl = orig_sgl;
! 	cur_src_sgl = bounce_sgl;
  	for (i = 0; i < orig_sgl_count; i++) {
! 		dest_addr = sg_kmap_atomic(cur_dest_sgl) + cur_dest_sgl->offset;
  		dest = dest_addr;
! 		destlen = cur_dest_sgl->length;
  
  		if (bounce_addr == 0)
! 			bounce_addr = sg_kmap_atomic(cur_src_sgl);
  
  		while (destlen) {
! 			src = bounce_addr + cur_src_sgl->offset;
! 			srclen = cur_src_sgl->length - cur_src_sgl->offset;
  
  			copylen = min(srclen, destlen);
  			memcpy((void *)dest, (void *)src, copylen);
  
  			total_copied += copylen;
! 			cur_src_sgl->offset += copylen;
  			destlen -= copylen;
  			dest += copylen;
  
! 			if (cur_src_sgl->offset == cur_src_sgl->length) {
  				/* full */
  				sg_kunmap_atomic(bounce_addr);
  				j++;
***************
*** 684,704 ****
  					/*
  					 * We are done; cleanup and return.
  					 */
! 					sg_kunmap_atomic(dest_addr - orig_sgl[i].offset);
  					local_irq_restore(flags);
  					return total_copied;
  				}
  
  				/* if we need to use another bounce buffer */
! 				if (destlen || i != orig_sgl_count - 1)
! 					bounce_addr = sg_kmap_atomic(bounce_sgl,j);
! 			} else if (destlen == 0 && i == orig_sgl_count - 1) {
  				/* unmap the last bounce that is < PAGE_SIZE */
  				sg_kunmap_atomic(bounce_addr);
  			}
  		}
  
! 		sg_kunmap_atomic(dest_addr - orig_sgl[i].offset);
  	}
  
  	local_irq_restore(flags);
--- 744,768 ----
  					/*
  					 * We are done; cleanup and return.
  					 */
! 					sg_kunmap_atomic(dest_addr -
! 						cur_dest_sgl->offset);
  					local_irq_restore(flags);
  					return total_copied;
  				}
  
  				/* if we need to use another bounce buffer */
! 				if (destlen || (i < orig_sgl_count)) {
! 					cur_src_sgl = sg_next(cur_src_sgl);
! 					bounce_addr = sg_kmap_atomic(cur_src_sgl);
! 				}
! 			} else if (destlen == 0 && (i == (orig_sgl_count - 1))) {
  				/* unmap the last bounce that is < PAGE_SIZE */
  				sg_kunmap_atomic(bounce_addr);
  			}
  		}
  
! 		sg_kunmap_atomic(dest_addr - cur_dest_sgl->offset);
! 		cur_dest_sgl = sg_next(cur_dest_sgl);
  	}
  
  	local_irq_restore(flags);
***************
*** 712,718 ****
  					  unsigned int orig_sgl_count)
  {
  	int i;
- 	int j = 0;
  	unsigned long src, dest;
  	unsigned int srclen, destlen, copylen;
  	unsigned int total_copied = 0;
--- 775,780 ----
***************
*** 720,766 ****
  	unsigned long src_addr = 0;
  	unsigned long flags;
  
  	local_irq_save(flags);
  
  	for (i = 0; i < orig_sgl_count; i++) {
! 		src_addr = sg_kmap_atomic(orig_sgl,i) + orig_sgl[i].offset;
  		src = src_addr;
! 		srclen = orig_sgl[i].length;
  
  		if (bounce_addr == 0)
! 			bounce_addr = sg_kmap_atomic(bounce_sgl,j);
  
  		while (srclen) {
  			/* assume bounce offset always == 0 */
! 			dest = bounce_addr + bounce_sgl[j].length;
! 			destlen = PAGE_SIZE - bounce_sgl[j].length;
  
  			copylen = min(srclen, destlen);
  			memcpy((void *)dest, (void *)src, copylen);
  
  			total_copied += copylen;
! 			bounce_sgl[j].length += copylen;
  			srclen -= copylen;
  			src += copylen;
  
! 			if (bounce_sgl[j].length == PAGE_SIZE) {
  				/* full..move to next entry */
  				sg_kunmap_atomic(bounce_addr);
! 				j++;
! 
! 				/* if we need to use another bounce buffer */
! 				if (srclen || i != orig_sgl_count - 1)
! 					bounce_addr = sg_kmap_atomic(bounce_sgl,j);
  
! 			} else if (srclen == 0 && i == orig_sgl_count - 1) {
! 				/* unmap the last bounce that is < PAGE_SIZE */
! 				sg_kunmap_atomic(bounce_addr);
  			}
  		}
  
! 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
  	}
  
  	local_irq_restore(flags);
  
  	return total_copied;
--- 782,836 ----
  	unsigned long src_addr = 0;
  	unsigned long flags;
  
+ 	struct scatterlist *cur_src_sgl;
+ 	struct scatterlist *cur_dest_sgl;
+ 
  	local_irq_save(flags);
  
+ 	cur_src_sgl = orig_sgl;
+ 	cur_dest_sgl = bounce_sgl;
+ 
  	for (i = 0; i < orig_sgl_count; i++) {
! 		src_addr = sg_kmap_atomic(cur_src_sgl) + cur_src_sgl->offset;
  		src = src_addr;
! 		srclen = cur_src_sgl->length;
  
  		if (bounce_addr == 0)
! 			bounce_addr = sg_kmap_atomic(cur_dest_sgl);
  
  		while (srclen) {
  			/* assume bounce offset always == 0 */
! 			dest = bounce_addr + cur_dest_sgl->length;
! 			destlen = PAGE_SIZE - cur_dest_sgl->length;
  
  			copylen = min(srclen, destlen);
  			memcpy((void *)dest, (void *)src, copylen);
  
  			total_copied += copylen;
! 			cur_dest_sgl->length += copylen;
  			srclen -= copylen;
  			src += copylen;
  
! 			if (cur_dest_sgl->length == PAGE_SIZE) {
  				/* full..move to next entry */
  				sg_kunmap_atomic(bounce_addr);
! 				bounce_addr = 0;
! 			}
  
! 			/* if we need to use another bounce buffer */
! 			if (srclen && bounce_addr == 0) {
! 				cur_dest_sgl = sg_next(cur_dest_sgl);
! 				bounce_addr = sg_kmap_atomic(cur_dest_sgl);
  			}
  		}
  
! 		sg_kunmap_atomic(src_addr - cur_src_sgl->offset);
! 		cur_src_sgl = sg_next(cur_src_sgl);
  	}
  
+ 	if (bounce_addr)
+ 		sg_kunmap_atomic(bounce_addr);
+ 
  	local_irq_restore(flags);
  
  	return total_copied;
***************
*** 970,975 ****
--- 1040,1047 ----
  		    STORAGE_CHANNEL_SUPPORTS_MULTI_CHANNEL)
  			process_sub_channels = true;
  	}
+ 	stor_device->max_transfer_bytes =
+ 		vstor_packet->storage_channel_properties.max_transfer_bytes;
  
  	memset(vstor_packet, 0, sizeof(struct vstor_packet));
  	vstor_packet->operation = VSTOR_OPERATION_END_INITIALIZATION;
***************
*** 1011,1016 ****
--- 1083,1091 ----
  	struct storvsc_scan_work *wrk;
  	void (*process_err_fn)(struct work_struct *work);
  	bool do_work = false;
+ 	struct hv_host_device *host_dev = shost_priv(scmnd->device->host);
+ 	int error_handling_cpu = host_dev->dev->channel->target_cpu;
+ 
  
  	switch (vm_srb->srb_status) {
  	case SRB_STATUS_ERROR:
***************
*** 1067,1073 ****
  	wrk->host = host;
  	wrk->lun = vm_srb->lun;
  	INIT_WORK(&wrk->work, process_err_fn);
! 	schedule_work(&wrk->work);
  }
  
  
--- 1142,1148 ----
  	wrk->host = host;
  	wrk->lun = vm_srb->lun;
  	INIT_WORK(&wrk->work, process_err_fn);
! 	schedule_work_on(error_handling_cpu, &wrk->work);
  }
  
  
***************
*** 1075,1085 ****
--- 1150,1164 ----
  {
  	struct scsi_cmnd *scmnd = cmd_request->cmd;
  	struct hv_host_device *host_dev = shost_priv(scmnd->device->host);
+ 	void (*scsi_done_fn)(struct scsi_cmnd *);
  	struct scsi_sense_hdr sense_hdr;
  	struct vmscsi_request *vm_srb;
+ 	struct stor_mem_pools *memp = scmnd->device->hostdata;
  	struct Scsi_Host *host;
  	struct storvsc_device *stor_dev;
  	struct hv_device *dev = host_dev->dev;
+ 	u32 payload_sz = cmd_request->payload_sz;
+ 	void *payload = cmd_request->payload;
  
  	stor_dev = get_in_stor_device(dev);
  	host = stor_dev->host;
***************
*** 1097,1107 ****
  
  	scmnd->result = vm_srb->scsi_status;
  
! 	if (scmnd->result) {
  		if (scsi_normalize_sense(scmnd->sense_buffer,
  				SCSI_SENSE_BUFFERSIZE, &sense_hdr))
! 			scsi_print_sense_hdr(scmnd->device, "storvsc",
! 					     &sense_hdr);
  	}
  
  	if (vm_srb->srb_status != SRB_STATUS_SUCCESS)
--- 1176,1185 ----
  
  	scmnd->result = vm_srb->scsi_status;
  
! 	if (scmnd->result && do_logging(STORVSC_LOGGING_ERROR)) {
  		if (scsi_normalize_sense(scmnd->sense_buffer,
  				SCSI_SENSE_BUFFERSIZE, &sense_hdr))
! 			scsi_print_sense_hdr("storvsc", &sense_hdr);
  	}
  
  	if (vm_srb->srb_status != SRB_STATUS_SUCCESS)
***************
*** 1109,1118 ****
  					 sense_hdr.ascq);
  
  	scsi_set_resid(scmnd,
! 		cmd_request->data_buffer.len -
  		vm_srb->data_transfer_length);
  
! 	scmnd->scsi_done(scmnd);
  }
  
  static void storvsc_on_io_completion(struct hv_device *device,
--- 1187,1207 ----
  					 sense_hdr.ascq);
  
  	scsi_set_resid(scmnd,
! 		cmd_request->payload->range.len -
  		vm_srb->data_transfer_length);
  
! 	scsi_done_fn = scmnd->scsi_done;
! 
! 	scmnd->host_scribble = NULL;
! 	scmnd->scsi_done = NULL;
! 
! 	scsi_done_fn(scmnd);
! 
! 	if (payload_sz >
! 		sizeof(struct vmbus_channel_packet_multipage_buffer))
! 		kfree(payload);
! 
! 	mempool_free(cmd_request, memp->request_mempool);
  }
  
  static void storvsc_on_io_completion(struct hv_device *device,
***************
*** 1149,1162 ****
  	stor_pkt->vm_srb.sense_info_length =
  	vstor_packet->vm_srb.sense_info_length;
  
  
  	if ((vstor_packet->vm_srb.scsi_status & 0xFF) == 0x02) {
  		/* CHECK_CONDITION */
  		if (vstor_packet->vm_srb.srb_status &
  			SRB_STATUS_AUTOSENSE_VALID) {
  			/* autosense data available */
  
! 			memcpy(request->cmd->sense_buffer,
  			       vstor_packet->vm_srb.sense_data,
  			       vstor_packet->vm_srb.sense_info_length);
  
--- 1238,1266 ----
  	stor_pkt->vm_srb.sense_info_length =
  	vstor_packet->vm_srb.sense_info_length;
  
+ 	if (vstor_packet->vm_srb.scsi_status != 0 ||
+ 		vstor_packet->vm_srb.srb_status != SRB_STATUS_SUCCESS)
+ 		if (do_logging(STORVSC_LOGGING_WARN))
+ 			dev_warn(&device->device,
+ 				"cmd 0x%x scsi status 0x%x srb status 0x%x\n",
+ 				stor_pkt->vm_srb.cdb[0],
+ 				vstor_packet->vm_srb.scsi_status,
+ 				vstor_packet->vm_srb.srb_status);
+ 
  
  	if ((vstor_packet->vm_srb.scsi_status & 0xFF) == 0x02) {
  		/* CHECK_CONDITION */
  		if (vstor_packet->vm_srb.srb_status &
  			SRB_STATUS_AUTOSENSE_VALID) {
  			/* autosense data available */
+ 			if (do_logging(STORVSC_LOGGING_WARN))
+ 				dev_warn(&device->device,
+ 					"stor pkt %p autosense data valid - len %d\n",
+ 					request,
+ 					vstor_packet->vm_srb.sense_info_length);
+ 
  
! 			memcpy(request->sense_buffer,
  			       vstor_packet->vm_srb.sense_data,
  			       vstor_packet->vm_srb.sense_info_length);
  
***************
*** 1314,1320 ****
  }
  
  static int storvsc_do_io(struct hv_device *device,
! 			      struct storvsc_cmd_request *request)
  {
  	struct storvsc_device *stor_device;
  	struct vstor_packet *vstor_packet;
--- 1418,1424 ----
  }
  
  static int storvsc_do_io(struct hv_device *device,
! 			 struct storvsc_cmd_request *request)
  {
  	struct storvsc_device *stor_device;
  	struct vstor_packet *vstor_packet;
***************
*** 1346,1364 ****
  
  
  	vstor_packet->vm_srb.data_transfer_length =
! 	request->data_buffer.len;
  
  	vstor_packet->operation = VSTOR_OPERATION_EXECUTE_SRB;
  
! 	if (request->data_buffer.len) {
! 		ret = vmbus_sendpacket_multipagebuffer(outgoing_channel,
! 				&request->data_buffer,
  				vstor_packet,
  				(sizeof(struct vstor_packet) -
  				vmscsi_size_delta),
  				(unsigned long)request);
  	} else {
! 		ret = vmbus_sendpacket(device->channel, vstor_packet,
  			       (sizeof(struct vstor_packet) -
  				vmscsi_size_delta),
  			       (unsigned long)request,
--- 1450,1469 ----
  
  
  	vstor_packet->vm_srb.data_transfer_length =
! 	request->payload->range.len;
  
  	vstor_packet->operation = VSTOR_OPERATION_EXECUTE_SRB;
  
! 	if (request->payload->range.len) {
! 
! 		ret = vmbus_sendpacket_mpb_desc(outgoing_channel,
! 				request->payload, request->payload_sz,
  				vstor_packet,
  				(sizeof(struct vstor_packet) -
  				vmscsi_size_delta),
  				(unsigned long)request);
  	} else {
! 		ret = vmbus_sendpacket(outgoing_channel, vstor_packet,
  			       (sizeof(struct vstor_packet) -
  				vmscsi_size_delta),
  			       (unsigned long)request,
***************
*** 1374,1382 ****
  	return ret;
  }
  
  static int storvsc_device_configure(struct scsi_device *sdevice)
  {
- 	scsi_change_queue_depth(sdevice, STORVSC_MAX_IO_REQUESTS);
  
  	blk_queue_max_segment_size(sdevice->request_queue, PAGE_SIZE);
  
--- 1479,1535 ----
  	return ret;
  }
  
+ static int storvsc_device_alloc(struct scsi_device *sdevice)
+ {
+ 	struct stor_mem_pools *memp;
+ 	int number = STORVSC_MIN_BUF_NR;
+ 
+ 	memp = kzalloc(sizeof(struct stor_mem_pools), GFP_KERNEL);
+ 	if (!memp)
+ 		return -ENOMEM;
+ 
+ 	memp->request_pool =
+ 		kmem_cache_create(dev_name(&sdevice->sdev_dev),
+ 				sizeof(struct storvsc_cmd_request), 0,
+ 				SLAB_HWCACHE_ALIGN, NULL);
+ 
+ 	if (!memp->request_pool)
+ 		goto err0;
+ 
+ 	memp->request_mempool = mempool_create(number, mempool_alloc_slab,
+ 						mempool_free_slab,
+ 						memp->request_pool);
+ 
+ 	if (!memp->request_mempool)
+ 		goto err1;
+ 
+ 	sdevice->hostdata = memp;
+ 
+ 	return 0;
+ 
+ err1:
+ 	kmem_cache_destroy(memp->request_pool);
+ 
+ err0:
+ 	kfree(memp);
+ 	return -ENOMEM;
+ }
+ 
+ static void storvsc_device_destroy(struct scsi_device *sdevice)
+ {
+ 	struct stor_mem_pools *memp = sdevice->hostdata;
+ 
+ 	if (!memp)
+ 		return;
+ 
+ 	mempool_destroy(memp->request_mempool);
+ 	kmem_cache_destroy(memp->request_pool);
+ 	kfree(memp);
+ 	sdevice->hostdata = NULL;
+ }
+ 
  static int storvsc_device_configure(struct scsi_device *sdevice)
  {
  
  	blk_queue_max_segment_size(sdevice->request_queue, PAGE_SIZE);
  
***************
*** 1384,1399 ****
  
  	blk_queue_rq_timeout(sdevice->request_queue, (storvsc_timeout * HZ));
  
- 	sdevice->no_write_same = 1;
- 
- 	/*
- 	 * Add blist flags to permit the reading of the VPD pages even when
- 	 * the target may claim SPC-2 compliance. MSFT targets currently
- 	 * claim SPC-2 compliance while they implement post SPC-2 features.
- 	 * With this patch we can correctly handle WRITE_SAME_16 issues.
- 	 */
- 	sdevice->sdev_bflags |= msft_blist_flags;
- 
  	/*
  	 * If the host is WIN8 or WIN8 R2, claim conformance to SPC-3
  	 * if the device is a MSFT virtual device.
--- 1537,1542 ----
***************
*** 1502,1513 ****
  	switch (scsi_op) {
  	/* the host does not handle WRITE_SAME, log accident usage */
  	case WRITE_SAME:
  	/*
  	 * smartd sends this command and the host does not handle
  	 * this. So, don't send it.
  	 */
  	case SET_WINDOW:
! 		scmnd->result = ILLEGAL_REQUEST << 16;
  		allowed = false;
  		break;
  	default:
--- 1645,1661 ----
  	switch (scsi_op) {
  	/* the host does not handle WRITE_SAME, log accident usage */
  	case WRITE_SAME:
+ 	case WRITE_SAME_16:
  	/*
  	 * smartd sends this command and the host does not handle
  	 * this. So, don't send it.
  	 */
  	case SET_WINDOW:
!                 scsi_build_sense_buffer(0, scmnd->sense_buffer, ILLEGAL_REQUEST,
!                     0x20, 0);
!                 scmnd->result = SAM_STAT_CHECK_CONDITION;
!                 set_driver_byte(scmnd, DRIVER_SENSE);
!                 set_host_byte(scmnd, DID_ABORT);
  		allowed = false;
  		break;
  	default:
***************
*** 1516,1531 ****
  	return allowed;
  }
  
  static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)
  {
  	int ret;
  	struct hv_host_device *host_dev = shost_priv(host);
  	struct hv_device *dev = host_dev->dev;
! 	struct storvsc_cmd_request *cmd_request = scsi_cmd_priv(scmnd);
  	int i;
  	struct scatterlist *sgl;
  	unsigned int sg_count = 0;
  	struct vmscsi_request *vm_srb;
  
  	if (vmstor_current_major <= VMSTOR_WIN8_MAJOR) {
  		/*
--- 1664,1697 ----
  	return allowed;
  }
  
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,32))
+ static int storvsc_queuecommand(struct scsi_cmnd *scmnd,
+ 	void (*done)(struct scsi_cmnd *scmnd))
+ {
+ 	struct Scsi_Host *host = scmnd->device->host;
+ 
+ #else
+ 
  static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)
  {
+ #endif
+ 
  	int ret;
  	struct hv_host_device *host_dev = shost_priv(host);
  	struct hv_device *dev = host_dev->dev;
! 	struct storvsc_cmd_request *cmd_request;
! 	unsigned int request_size = 0;
  	int i;
  	struct scatterlist *sgl;
  	unsigned int sg_count = 0;
  	struct vmscsi_request *vm_srb;
+ 	struct stor_mem_pools *memp = scmnd->device->hostdata;
+ 	struct scatterlist *cur_sgl;
+ 
+ 	struct vmbus_packet_mpb_array  *payload;
+ 	u32 payload_sz;
+ 	u32 length;
+ 
  
  	if (vmstor_current_major <= VMSTOR_WIN8_MAJOR) {
  		/*
***************
*** 1542,1550 ****
--- 1708,1732 ----
  		}
  	}
  
+ 	request_size = sizeof(struct storvsc_cmd_request);
+ 
+ 	cmd_request = mempool_alloc(memp->request_mempool,
+ 				       GFP_ATOMIC);
+ 
+ 	/*
+ 	 * We might be invoked in an interrupt context; hence
+ 	 * mempool_alloc() can fail.
+ 	 */
+ 	if (!cmd_request)
+ 		return SCSI_MLQUEUE_DEVICE_BUSY;
+ 
+ 	memset(cmd_request, 0, sizeof(struct storvsc_cmd_request));
+ 
  	/* Setup the cmd request */
  	cmd_request->cmd = scmnd;
  
+ 	scmnd->host_scribble = (unsigned char *)cmd_request;
+ 
  	vm_srb = &cmd_request->vstor_packet.vm_srb;
  	vm_srb->win8_extension.time_out_value = 60;
  
***************
*** 1579,1585 ****
  
  	memcpy(vm_srb->cdb, scmnd->cmnd, vm_srb->cdb_length);
  
! 	cmd_request->data_buffer.len = scsi_bufflen(scmnd);
  	if (scsi_sg_count(scmnd)) {
  		sgl = (struct scatterlist *)scsi_sglist(scmnd);
  		sg_count = scsi_sg_count(scmnd);
--- 1761,1774 ----
  
  	memcpy(vm_srb->cdb, scmnd->cmnd, vm_srb->cdb_length);
  
! 	cmd_request->sense_buffer = scmnd->sense_buffer;
! 
! 
! 	sgl = (struct scatterlist *)scsi_sglist(scmnd);
! 	length = scsi_bufflen(scmnd);
! 	payload = (struct vmbus_packet_mpb_array *)&cmd_request->mpb;
! 	payload_sz = sizeof(cmd_request->mpb);
! 
  	if (scsi_sg_count(scmnd)) {
  		sgl = (struct scatterlist *)scsi_sglist(scmnd);
  		sg_count = scsi_sg_count(scmnd);
***************
*** 1590,1597 ****
  				create_bounce_buffer(sgl, scsi_sg_count(scmnd),
  						     scsi_bufflen(scmnd),
  						     vm_srb->data_in);
! 			if (!cmd_request->bounce_sgl)
! 				return SCSI_MLQUEUE_HOST_BUSY;
  
  			cmd_request->bounce_sgl_count =
  				ALIGN(scsi_bufflen(scmnd), PAGE_SIZE) >>
--- 1779,1788 ----
  				create_bounce_buffer(sgl, scsi_sg_count(scmnd),
  						     scsi_bufflen(scmnd),
  						     vm_srb->data_in);
! 			if (!cmd_request->bounce_sgl) {
! 				ret = SCSI_MLQUEUE_HOST_BUSY;
! 				goto queue_error;
! 			}
  
  			cmd_request->bounce_sgl_count =
  				ALIGN(scsi_bufflen(scmnd), PAGE_SIZE) >>
***************
*** 1606,1624 ****
  			sg_count = cmd_request->bounce_sgl_count;
  		}
  
- 		cmd_request->data_buffer.offset = sgl[0].offset;
  
! 		for (i = 0; i < sg_count; i++)
! 			cmd_request->data_buffer.pfn_array[i] =
! 				page_to_pfn(sg_page((&sgl[i])));
  
  	} else if (scsi_sglist(scmnd)) {
! 		cmd_request->data_buffer.offset =
  			virt_to_phys(scsi_sglist(scmnd)) & (PAGE_SIZE-1);
! 		cmd_request->data_buffer.pfn_array[0] =
  			virt_to_phys(scsi_sglist(scmnd)) >> PAGE_SHIFT;
  	}
  
  	/* Invokes the vsc to start an IO */
  	ret = storvsc_do_io(dev, cmd_request);
  
--- 1797,1837 ----
  			sg_count = cmd_request->bounce_sgl_count;
  		}
  
  
! 		if (sg_count > MAX_PAGE_BUFFER_COUNT) {
! 
! 			payload_sz = (sg_count * sizeof(void *) +
! 				      sizeof(struct vmbus_packet_mpb_array));
! 			payload = kzalloc(payload_sz, GFP_ATOMIC);
! 			if (!payload) {
! 				if (cmd_request->bounce_sgl_count)
! 					destroy_bounce_buffer(
! 					cmd_request->bounce_sgl,
! 					cmd_request->bounce_sgl_count);
! 
! 				return SCSI_MLQUEUE_DEVICE_BUSY;
! 			}
! 		}
! 
! 		payload->range.len = length;
! 		payload->range.offset = sgl[0].offset;
! 		cur_sgl = sgl;
! 		for (i = 0; i < sg_count; i++) {
! 			payload->range.pfn_array[i] =
! 				page_to_pfn(sg_page((cur_sgl)));
! 			cur_sgl = sg_next(cur_sgl);
! 		}
  
  	} else if (scsi_sglist(scmnd)) {
! 		payload->range.len = length;
! 		payload->range.offset =
  			virt_to_phys(scsi_sglist(scmnd)) & (PAGE_SIZE-1);
! 		payload->range.pfn_array[0] =
  			virt_to_phys(scsi_sglist(scmnd)) >> PAGE_SHIFT;
  	}
  
+ 	cmd_request->payload = payload;
+ 	cmd_request->payload_sz = payload_sz;
  	/* Invokes the vsc to start an IO */
  	ret = storvsc_do_io(dev, cmd_request);
  
***************
*** 1629,1660 ****
  			destroy_bounce_buffer(cmd_request->bounce_sgl,
  					cmd_request->bounce_sgl_count);
  
! 		return SCSI_MLQUEUE_DEVICE_BUSY;
  	}
  
  	return 0;
  }
  
  static struct scsi_host_template scsi_driver = {
  	.module	=		THIS_MODULE,
  	.name =			"storvsc_host_t",
- 	.cmd_size =             sizeof(struct storvsc_cmd_request),
  	.bios_param =		storvsc_get_chs,
  	.queuecommand =		storvsc_queuecommand,
  	.eh_host_reset_handler =	storvsc_host_reset_handler,
- 	.proc_name =		"storvsc_host",
  	.eh_timed_out =		storvsc_eh_timed_out,
  	.slave_configure =	storvsc_device_configure,
  	.cmd_per_lun =		255,
- 	.can_queue =		STORVSC_MAX_IO_REQUESTS*STORVSC_MAX_TARGETS,
  	.this_id =		-1,
! 	/* no use setting to 0 since ll_blk_rw reset it to 1 */
! 	/* currently 32 */
! 	.sg_tablesize =		MAX_MULTIPAGE_BUFFER_COUNT,
! 	.use_clustering =	DISABLE_CLUSTERING,
  	/* Make sure we dont get a sg segment crosses a page boundary */
  	.dma_boundary =		PAGE_SIZE-1,
- 	.no_write_same =	1,
  };
  
  enum {
--- 1842,1881 ----
  			destroy_bounce_buffer(cmd_request->bounce_sgl,
  					cmd_request->bounce_sgl_count);
  
! 		ret = SCSI_MLQUEUE_DEVICE_BUSY;
! 		goto queue_error;
  	}
  
  	return 0;
+ 
+ queue_error:
+ 	mempool_free(cmd_request, memp->request_mempool);
+ 	scmnd->host_scribble = NULL;
+ 	return ret;
  }
  
+ #ifdef CONFIG_X86_64
+ #define STORVSC_TABLE_SEZE 512
+ #else
+ #define STORVSC_TABLE_SEZE 32
+ #endif
+ 
  static struct scsi_host_template scsi_driver = {
  	.module	=		THIS_MODULE,
  	.name =			"storvsc_host_t",
  	.bios_param =		storvsc_get_chs,
  	.queuecommand =		storvsc_queuecommand,
  	.eh_host_reset_handler =	storvsc_host_reset_handler,
  	.eh_timed_out =		storvsc_eh_timed_out,
+ 	.slave_alloc =		storvsc_device_alloc,
+ 	.slave_destroy =	storvsc_device_destroy,
  	.slave_configure =	storvsc_device_configure,
  	.cmd_per_lun =		255,
  	.this_id =		-1,
! 	.sg_tablesize = STORVSC_TABLE_SEZE,
! 	.use_clustering =	ENABLE_CLUSTERING,
  	/* Make sure we dont get a sg segment crosses a page boundary */
  	.dma_boundary =		PAGE_SIZE-1,
  };
  
  enum {
***************
*** 1686,1691 ****
--- 1907,1913 ----
  			const struct hv_vmbus_device_id *dev_id)
  {
  	int ret;
+ 	int num_cpus = num_online_cpus();
  	struct Scsi_Host *host;
  	struct hv_host_device *host_dev;
  	bool dev_is_ide = ((dev_id->driver_data == IDE_GUID) ? true : false);
***************
*** 1694,1699 ****
--- 1916,1922 ----
  	int max_luns_per_target;
  	int max_targets;
  	int max_channels;
+ 	int max_sub_channels = 0;
  
  	/*
  	 * Based on the windows host we are running on,
***************
*** 1719,1730 ****
  		max_luns_per_target = STORVSC_MAX_LUNS_PER_TARGET;
  		max_targets = STORVSC_MAX_TARGETS;
  		max_channels = STORVSC_MAX_CHANNELS;
  		break;
  	}
  
! 	if (dev_id->driver_data == SFC_GUID)
! 		scsi_driver.can_queue = (STORVSC_MAX_IO_REQUESTS *
! 					 STORVSC_FC_MAX_TARGETS);
  	host = scsi_host_alloc(&scsi_driver,
  			       sizeof(struct hv_host_device));
  	if (!host)
--- 1942,1959 ----
  		max_luns_per_target = STORVSC_MAX_LUNS_PER_TARGET;
  		max_targets = STORVSC_MAX_TARGETS;
  		max_channels = STORVSC_MAX_CHANNELS;
+ 		/*
+ 		 * On Windows8 and above, we support sub-channels for storage.
+ 		 * The number of sub-channels offerred is based on the number of
+ 		 * VCPUs in the guest.
+ 		 */
+ 		max_sub_channels = (num_cpus / storvsc_vcpus_per_sub_channel);
  		break;
  	}
  
! 	scsi_driver.can_queue = (max_outstanding_req_per_channel *
! 				 (max_sub_channels + 1));
! 
  	host = scsi_host_alloc(&scsi_driver,
  			       sizeof(struct hv_host_device));
  	if (!host)
***************
*** 1780,1785 ****
--- 2009,2022 ----
  	/* max cmd length */
  	host->max_cmd_len = STORVSC_MAX_CMD_LEN;
  
+ 	/*
+ 	 * set the table size based on the info we got
+ 	 * from the host; but only for 64 bit guests.
+ 	 */
+ #ifdef CONFIG_X86_64
+ 	host->sg_tablesize = (stor_device->max_transfer_bytes >> PAGE_SHIFT);
+ #endif
+ 
  	/* Register the HBA and start the scsi bus scan */
  	ret = scsi_add_host(host, &device->device);
  	if (ret != 0)
***************
*** 1837,1843 ****
  
  static int __init storvsc_drv_init(void)
  {
- 	u32 max_outstanding_req_per_channel;
  
  	/*
  	 * Divide the ring buffer data size (which is 1 page less
--- 2074,2079 ----
***************
*** 1852,1861 ****
  		vmscsi_size_delta,
  		sizeof(u64)));
  
- 	if (max_outstanding_req_per_channel <
- 	    STORVSC_MAX_IO_REQUESTS)
- 		return -EINVAL;
- 
  	return vmbus_driver_register(&storvsc_drv);
  }
  
--- 2088,2093 ----
***************
*** 1866,1870 ****
--- 2098,2107 ----
  
  MODULE_LICENSE("GPL");
  MODULE_DESCRIPTION("Microsoft Hyper-V virtual storage driver");
+ MODULE_VERSION(HV_DRV_VERSION);
+ MODULE_ALIAS("vmbus:d96361baa104294db60572e2ffb1dc7f");
+ MODULE_ALIAS("vmbus:32264132cb86a2449b5c50d1417354f5");
+ MODULE_ALIAS("vmbus:4acc9b2f6900f34ab76b6fd0be528cda");
+ 
  module_init(storvsc_drv_init);
  module_exit(storvsc_drv_exit);
diff -crB ln12Mar/hv/tools/hv_fcopy_daemon.c hv-rhel7.x/hv/tools/hv_fcopy_daemon.c
*** ln12Mar/hv/tools/hv_fcopy_daemon.c	2015-05-14 09:58:23.693919924 -0700
--- hv-rhel7.x/hv/tools/hv_fcopy_daemon.c	2015-05-14 07:05:22.423085200 -0700
***************
*** 28,34 ****
  #include <string.h>
  #include <ctype.h>
  #include <errno.h>
! #include <linux/hyperv.h>
  #include <syslog.h>
  #include <sys/stat.h>
  #include <fcntl.h>
--- 28,34 ----
  #include <string.h>
  #include <ctype.h>
  #include <errno.h>
! #include "../include/uapi/linux/hyperv.h"
  #include <syslog.h>
  #include <sys/stat.h>
  #include <fcntl.h>
Only in hv-rhel7.x/hv/tools: hv_get_dhcp_info
Only in hv-rhel7.x/hv/tools: hv_get_dns_info
diff -crB ln12Mar/hv/tools/hv_kvp_daemon.c hv-rhel7.x/hv/tools/hv_kvp_daemon.c
*** ln12Mar/hv/tools/hv_kvp_daemon.c	2015-05-14 09:58:26.543046622 -0700
--- hv-rhel7.x/hv/tools/hv_kvp_daemon.c	2015-05-14 07:05:22.424085245 -0700
***************
*** 34,40 ****
  #include <errno.h>
  #include <arpa/inet.h>
  #include <linux/connector.h>
! #include <linux/hyperv.h>
  #include <linux/netlink.h>
  #include <ifaddrs.h>
  #include <netdb.h>
--- 34,40 ----
  #include <errno.h>
  #include <arpa/inet.h>
  #include <linux/connector.h>
! #include "../include/uapi/linux/hyperv.h"
  #include <linux/netlink.h>
  #include <ifaddrs.h>
  #include <netdb.h>
Only in hv-rhel7.x/hv/tools: hv_set_ifconfig
diff -crB ln12Mar/hv/tools/hv_set_ifconfig.sh hv-rhel7.x/hv/tools/hv_set_ifconfig.sh
*** ln12Mar/hv/tools/hv_set_ifconfig.sh	2015-05-14 09:58:27.471087892 -0700
--- hv-rhel7.x/hv/tools/hv_set_ifconfig.sh	2015-05-14 07:05:22.424085245 -0700
***************
*** 54,59 ****
--- 54,61 ----
  echo "PEERDNS=yes" >> $1
  echo "ONBOOT=yes" >> $1
  
+ sed -i 's/IPADDR0/IPADDR/g' $1
+ sed -i 's/NETMASK0/NETMASK/g' $1
  
  cp $1 /etc/sysconfig/network-scripts/
  
diff -crB ln12Mar/hv/tools/hv_vss_daemon.c hv-rhel7.x/hv/tools/hv_vss_daemon.c
*** ln12Mar/hv/tools/hv_vss_daemon.c	2015-05-14 09:58:28.485132986 -0700
--- hv-rhel7.x/hv/tools/hv_vss_daemon.c	2015-05-14 07:05:22.424085245 -0700
***************
*** 33,39 ****
  #include <arpa/inet.h>
  #include <linux/fs.h>
  #include <linux/connector.h>
! #include <linux/hyperv.h>
  #include <linux/netlink.h>
  #include <syslog.h>
  #include <getopt.h>
--- 33,39 ----
  #include <arpa/inet.h>
  #include <linux/fs.h>
  #include <linux/connector.h>
! #include "../include/uapi/linux/hyperv.h"
  #include <linux/netlink.h>
  #include <syslog.h>
  #include <getopt.h>
diff -crB ln12Mar/hv/tools/Makefile hv-rhel7.x/hv/tools/Makefile
*** ln12Mar/hv/tools/Makefile	2015-05-14 09:58:28.486133030 -0700
--- hv-rhel7.x/hv/tools/Makefile	2015-05-14 07:05:22.423085200 -0700
***************
*** 1,4 ****
--- 1,6 ----
  # Makefile for Hyper-V tools
+ #include $(M)/overrides.mk
+ 
  
  CC = $(CROSS_COMPILE)gcc
  PTHREAD_LIBS = -lpthread
diff -crB ln12Mar/hv/vmbus_drv.c hv-rhel7.x/hv/vmbus_drv.c
*** ln12Mar/hv/vmbus_drv.c	2015-05-14 08:13:03.000000000 -0700
--- hv-rhel7.x/hv/vmbus_drv.c	2015-05-14 07:05:22.424085245 -0700
***************
*** 23,28 ****
--- 23,29 ----
  #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
  
  #include <linux/init.h>
+ #include <linux/version.h>
  #include <linux/module.h>
  #include <linux/device.h>
  #include <linux/interrupt.h>
***************
*** 30,41 ****
  #include <linux/slab.h>
  #include <linux/acpi.h>
  #include <linux/completion.h>
! #include <linux/hyperv.h>
  #include <linux/kernel_stat.h>
  #include <linux/clockchips.h>
! #include <asm/hyperv.h>
  #include <asm/hypervisor.h>
- #include <asm/mshyperv.h>
  #include "hyperv_vmbus.h"
  
  static struct acpi_device  *hv_acpi_dev;
--- 31,42 ----
  #include <linux/slab.h>
  #include <linux/acpi.h>
  #include <linux/completion.h>
! #include <asm/mshyperv.h>
! #include "include/linux/hyperv.h"
  #include <linux/kernel_stat.h>
  #include <linux/clockchips.h>
! #include "include/asm/hyperv.h"
  #include <asm/hypervisor.h>
  #include "hyperv_vmbus.h"
  
  static struct acpi_device  *hv_acpi_dev;
***************
*** 564,569 ****
--- 565,572 ----
  	.dev_groups =		vmbus_groups,
  };
  
+ static const char *driver_name = "hyperv";
+ 
  struct onmessage_work_context {
  	struct work_struct work;
  	struct hv_message msg;
***************
*** 650,656 ****
--- 653,663 ----
  	}
  }
  
+ #if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
  static void vmbus_isr(void)
+ #else
+ static irqreturn_t vmbus_isr(int irq, void *dev_id)
+ #endif
  {
  	int cpu = smp_processor_id();
  	void *page_addr;
***************
*** 660,666 ****
--- 667,677 ----
  
  	page_addr = hv_context.synic_event_page[cpu];
  	if (page_addr == NULL)
+ #if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
  		return;
+ #else
+ 		return IRQ_NONE;
+ #endif
  
  	event = (union hv_synic_event_flags *)page_addr +
  					 VMBUS_MESSAGE_SINT;
***************
*** 702,707 ****
--- 713,740 ----
  		else
  			tasklet_schedule(&msg_dpc);
  	}
+ #if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
+ 	return;
+ #else
+ 	if (handled)
+ 		return IRQ_HANDLED;
+ 	else
+ 		return IRQ_NONE;
+ 
+ #endif
+ }
+ 
+ /*
+  * vmbus interrupt flow handler:
+  * vmbus interrupts can concurrently occur on multiple CPUs and
+  * can be handled concurrently.
+  */
+ 
+ static void vmbus_flow_handler(unsigned int irq, struct irq_desc *desc)
+ {
+ 	kstat_incr_irqs_this_cpu(irq, desc);
+ 
+ 	desc->action->handler(irq, desc->action->dev_id);
  }
  
  /*
***************
*** 730,737 ****
--- 763,792 ----
  	if (ret)
  		goto err_cleanup;
  
+ 	ret = request_irq(irq, vmbus_isr, 0, driver_name, hv_acpi_dev);
+ 
+ 	if (ret != 0) {
+ 		pr_err("Unable to request IRQ %d\n",
+ 			irq);
+ 		goto err_unregister;
+ 	}
+ 
+ 	/*
+ 	 * Vmbus interrupts can be handled concurrently on
+ 	 * different CPUs. Establish an appropriate interrupt flow
+ 	 * handler that can support this model.
+ 	 */
+ 	irq_set_handler(irq, vmbus_flow_handler);
+ 
+ #if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
+ 
  	hv_setup_vmbus_irq(vmbus_isr);
  
+ #else
+ 
+ 	hv_register_vmbus_handler(irq, vmbus_isr);
+ #endif
+ 
  	ret = hv_synic_alloc();
  	if (ret)
  		goto err_alloc;
***************
*** 750,757 ****
--- 805,816 ----
  
  err_alloc:
  	hv_synic_free();
+ 	free_irq(irq, hv_acpi_dev);
+ #if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
  	hv_remove_vmbus_irq();
+ #endif
  
+ err_unregister:
  	bus_unregister(&hv_bus);
  
  err_cleanup:
***************
*** 894,901 ****
  		break;
  
  	case ACPI_RESOURCE_TYPE_ADDRESS64:
! 		hyperv_mmio.start = res->data.address64.address.minimum;
! 		hyperv_mmio.end = res->data.address64.address.maximum;
  		break;
  	}
  
--- 953,960 ----
  		break;
  
  	case ACPI_RESOURCE_TYPE_ADDRESS64:
! 		hyperv_mmio.start = res->data.address64.minimum;
! 		hyperv_mmio.end = res->data.address64.maximum;
  		break;
  	}
  
***************
*** 992,998 ****
--- 1051,1059 ----
  
  static void __exit vmbus_exit(void)
  {
+ #if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
  	hv_remove_vmbus_irq();
+ #endif
  	vmbus_free_channels();
  	bus_unregister(&hv_bus);
  	hv_cleanup();
***************
*** 1001,1006 ****
--- 1062,1068 ----
  
  
  MODULE_LICENSE("GPL");
+ MODULE_VERSION(HV_DRV_VERSION);
  
  subsys_initcall(hv_acpi_init);
  module_exit(vmbus_exit);
