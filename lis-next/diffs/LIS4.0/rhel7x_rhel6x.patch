Only in hv-rhel7.x/hv/: CHANGELOG
diff -ru hv-rhel7.x/hv/channel.c hv-rhel6.x/hv/channel.c
--- hv-rhel7.x/hv/channel.c	2015-12-01 16:53:22.715618821 -0800
+++ hv-rhel6.x/hv/channel.c	2015-12-01 16:53:22.518622187 -0800
@@ -61,6 +61,50 @@
 }
 
 /*
+ * vmbus_get_debug_info -Retrieve various channel debug info
+ */
+void vmbus_get_debug_info(struct vmbus_channel *channel,
+			struct vmbus_channel_debug_info *debuginfo)
+{
+	struct hv_monitor_page *monitorpage;
+	u8 monitor_group = (u8)channel->offermsg.monitorid / 32;
+	u8 monitor_offset = (u8)channel->offermsg.monitorid % 32;
+
+	debuginfo->relid = channel->offermsg.child_relid;
+	debuginfo->state = channel->state;
+	memcpy(&debuginfo->interfacetype,
+		&channel->offermsg.offer.if_type, sizeof(uuid_le));
+	memcpy(&debuginfo->interface_instance,
+		&channel->offermsg.offer.if_instance,
+		sizeof(uuid_le));
+
+	monitorpage = (struct hv_monitor_page *)vmbus_connection.monitor_pages;
+
+	debuginfo->monitorid = channel->offermsg.monitorid;
+
+	debuginfo->servermonitor_pending =
+			monitorpage->trigger_group[monitor_group].pending;
+	debuginfo->servermonitor_latency =
+			monitorpage->latency[monitor_group][monitor_offset];
+	debuginfo->servermonitor_connectionid =
+			monitorpage->parameter[monitor_group]
+				[monitor_offset].connectionid.u.id;
+
+	monitorpage++;
+
+	debuginfo->clientmonitor_pending =
+			monitorpage->trigger_group[monitor_group].pending;
+	debuginfo->clientmonitor_latency =
+			monitorpage->latency[monitor_group][monitor_offset];
+	debuginfo->clientmonitor_connectionid =
+			monitorpage->parameter[monitor_group]
+				[monitor_offset].connectionid.u.id;
+
+	hv_ringbuffer_get_debuginfo(&channel->inbound, &debuginfo->inbound);
+	hv_ringbuffer_get_debuginfo(&channel->outbound, &debuginfo->outbound);
+}
+
+/*
  * vmbus_open - Open the specified channel.
  */
 int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,
diff -ru hv-rhel7.x/hv/connection.c hv-rhel6.x/hv/connection.c
--- hv-rhel7.x/hv/connection.c	2015-12-01 16:53:22.716618804 -0800
+++ hv-rhel6.x/hv/connection.c	2015-12-01 16:53:22.537621863 -0800
@@ -30,8 +30,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include "include/linux/hyperv.h"
-#include <linux/export.h>
-#include "include/asm/hyperv.h"
+#include <asm/hyperv.h>
 #include "hyperv_vmbus.h"
 
 
@@ -235,7 +234,7 @@
 	vmbus_initiate_unload();
 
 	if (vmbus_connection.work_queue) {
-		drain_workqueue(vmbus_connection.work_queue);
+		flush_workqueue(vmbus_connection.work_queue);
 		destroy_workqueue(vmbus_connection.work_queue);
 	}
 
Only in hv-rhel7.x/hv/: hid-core.c
Only in hv-rhel7.x/hv/: hid-debug.c
diff -ru hv-rhel7.x/hv/hid-hyperv.c hv-rhel6.x/hv/hid-hyperv.c
--- hv-rhel7.x/hv/hid-hyperv.c	2015-09-03 18:03:00.739620387 -0700
+++ hv-rhel6.x/hv/hid-hyperv.c	2015-12-01 16:53:22.548621675 -0800
@@ -612,6 +612,6 @@
 
 MODULE_LICENSE("GPL");
 MODULE_VERSION(HV_DRV_VERSION);
-
+MODULE_ALIAS("vmbus:9eb6a8cf4a5bc04cb98b8ba1a1f3f95a");
 module_init(mousevsc_init);
 module_exit(mousevsc_exit);
Only in hv-rhel7.x/hv/: hid-ids.h
Only in hv-rhel7.x/hv/: hid-input.c
diff -ru hv-rhel7.x/hv/hv_balloon.c hv-rhel6.x/hv/hv_balloon.c
--- hv-rhel7.x/hv/hv_balloon.c	2015-12-01 16:53:22.717618787 -0800
+++ hv-rhel6.x/hv/hv_balloon.c	2015-12-01 16:53:22.573621248 -0800
@@ -1039,7 +1039,7 @@
 	 * asking us to balloon them out.
 	 */
 	status.num_avail = val.freeram;
-	status.num_committed = vm_memory_committed() +
+	status.num_committed = (val.totalram - val.freeram) +
 		dm->num_pages_ballooned +
 		(dm->num_pages_added > dm->num_pages_onlined ?
 		 dm->num_pages_added - dm->num_pages_onlined : 0) +
diff -ru hv-rhel7.x/hv/hv.c hv-rhel6.x/hv/hv.c
--- hv-rhel7.x/hv/hv.c	2015-09-25 15:20:03.180372855 -0700
+++ hv-rhel6.x/hv/hv.c	2015-12-01 16:53:22.556621538 -0800
@@ -28,7 +28,10 @@
 #include "include/linux/hyperv.h"
 #include <linux/version.h>
 #include <linux/interrupt.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
 #include <linux/clockchips.h>
+#endif
+#include "include/uapi/linux/hyperv.h"
 #include "include/asm/hyperv.h"
 #include "include/asm/mshyperv.h"
 #include "hyperv_vmbus.h"
@@ -43,6 +46,10 @@
 #define HV_MAX_MAX_DELTA_TICKS 0xffffffff
 #define HV_MIN_DELTA_TICKS 1
 
+#define HV_TIMER_FREQUENCY (10 * 1000 * 1000) /* 100ns period */
+#define HV_MAX_MAX_DELTA_TICKS 0xffffffff
+#define HV_MIN_DELTA_TICKS 1
+
 /*
  * query_hypervisor_info - Get version info of the windows hypervisor
  */
@@ -148,6 +155,7 @@
 }
 #endif
 
+#ifdef CONFIG_X86_64
 static cycle_t read_hv_clock_tsc(struct clocksource *arg)
 {
        cycle_t current_tick;
@@ -186,13 +194,21 @@
        rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
        return current_tick;
 }
+#endif
 
+#define HV_CLOCK_SHIFT  22
 static struct clocksource hyperv_cs_tsc = {
                .name           = "hyperv_clocksource_tsc_page",
                .rating         = 425,
+#ifdef CONFIG_X86_64
                .read           = read_hv_clock_tsc,
+#endif
                .mask           = CLOCKSOURCE_MASK(64),
                .flags          = CLOCK_SOURCE_IS_CONTINUOUS,
+#if (RHEL_RELEASE_CODE < 1539)
+	       .mult           = (100 << HV_CLOCK_SHIFT),
+	       .shift          = HV_CLOCK_SHIFT,
+#endif
 };
 
 
@@ -232,7 +248,12 @@
 	/* See if the hypercall page is already set */
 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
 
+#ifdef __x86_64__
 	virtaddr = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_EXEC);
+#else
+	virtaddr = __vmalloc(PAGE_SIZE, GFP_KERNEL,
+			     __pgprot(__PAGE_KERNEL & (~_PAGE_NX)));
+#endif
 
 	if (!virtaddr)
 		goto cleanup;
@@ -264,7 +285,12 @@
                tsc_msr.guest_physical_address = vmalloc_to_pfn(va_tsc);
 
                wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
+        #if  (RHEL_RELEASE_CODE < 1539)
+                clocksource_register(&hyperv_cs_tsc);
+        #else
                clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+        #endif
+
        }
 #else
        /*
@@ -272,7 +298,12 @@
         */
        if (ms_hyperv.features & HV_X64_MSR_TIME_REF_COUNT_AVAILABLE) {
                hyperv_cs_tsc.read = read_hv_clock_msr;
+	 #if  (RHEL_RELEASE_CODE < 1539)
+                clocksource_register(&hyperv_cs_tsc);
+        #else
                clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
+        #endif
+
        }
 #endif
 
@@ -374,6 +405,7 @@
 	return status;
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
 static int hv_ce_set_next_event(unsigned long delta,
 				struct clock_event_device *evt)
 {
@@ -426,16 +458,24 @@
 	 * result in clockevents_config_and_register() taking additional
 	 * references to the hv_vmbus module making it impossible to unload.
 	 */
+	dev->shift = 31;
+	dev->mult = 21474836;
+	dev->min_delta_ns = 1000;
+	dev->max_delta_ns = 0xffffffff;
+
 
 	dev->set_mode = hv_ce_setmode;
 	dev->set_next_event = hv_ce_set_next_event;
 }
 
+#endif
 
 int hv_synic_alloc(void)
 {
 	size_t size = sizeof(struct tasklet_struct);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
 	size_t ced_size = sizeof(struct clock_event_device);
+#endif
 	int cpu;
 
 	hv_context.hv_numa_map = kzalloc(sizeof(struct cpumask) * nr_node_ids,
@@ -453,12 +493,14 @@
 		}
 		tasklet_init(hv_context.event_dpc[cpu], vmbus_on_event, cpu);
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
 		hv_context.clk_evt[cpu] = kzalloc(ced_size, GFP_ATOMIC);
 		if (hv_context.clk_evt[cpu] == NULL) {
 			pr_err("Unable to allocate clock event device\n");
 			goto err;
 		}
 		hv_init_clockevent_device(hv_context.clk_evt[cpu], cpu);
+#endif
 
 		hv_context.synic_message_page[cpu] =
 			(void *)get_zeroed_page(GFP_ATOMIC);
@@ -511,6 +553,10 @@
 		hv_synic_free_cpu(cpu);
 }
 
+#ifndef HYPERVISOR_CALLBACK_VECTOR
+#define HYPERVISOR_CALLBACK_VECTOR (7 + IRQ0_VECTOR)
+#endif
+
 /*
  * hv_synic_init - Initialize the Synthethic Interrupt Controller.
  *
@@ -583,29 +629,31 @@
 	/*
 	 * Register the per-cpu clockevent source.
 	 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
 	if (ms_hyperv.features & HV_X64_MSR_SYNTIMER_AVAILABLE)
-		clockevents_config_and_register(hv_context.clk_evt[cpu],
-						HV_TIMER_FREQUENCY,
-						HV_MIN_DELTA_TICKS,
-						HV_MAX_MAX_DELTA_TICKS);
+		clockevents_register_device(hv_context.clk_evt[cpu]);
+#endif
 #endif
 	return;
 }
 
 /*
  * hv_synic_clockevents_cleanup - Cleanup clockevent devices
- *  will comment this for time being till clockevents_unbind showed up in distro code
-*void hv_synic_clockevents_cleanup(void)
-*{
-*	int cpu;
-*
-*	if (!(ms_hyperv.features & HV_X64_MSR_SYNTIMER_AVAILABLE))
-*		return;
-*
-*	for_each_online_cpu(cpu)
-*		clockevents_unbind_device(hv_context.clk_evt[cpu], cpu);
-*}
-*/
+ */
+void hv_synic_clockevents_cleanup(void)
+{
+// Will comment this for time being till clockevents_unbind showed up in distro code
+#ifdef NOTYET
+	int cpu;
+
+	if (!(ms_hyperv.features & HV_X64_MSR_SYNTIMER_AVAILABLE))
+		return;
+
+	for_each_online_cpu(cpu)
+		clockevents_unbind_device(hv_context.clk_evt[cpu], cpu);
+#endif
+}
+
 /*
  * hv_synic_cleanup - Cleanup routine for hv_synic_init().
  */
@@ -620,10 +668,12 @@
 	if (!hv_context.synic_initialized)
 		return;
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
 	/* Turn off clockevent device */
 	if (ms_hyperv.features & HV_X64_MSR_SYNTIMER_AVAILABLE)
 		hv_ce_setmode(CLOCK_EVT_MODE_SHUTDOWN,
 			      hv_context.clk_evt[cpu]);
+#endif
 
 	rdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);
 
Only in hv-rhel7.x/hv/: hv_compat.c
diff -ru hv-rhel7.x/hv/hv_fcopy.c hv-rhel6.x/hv/hv_fcopy.c
--- hv-rhel7.x/hv/hv_fcopy.c	2015-12-01 16:53:22.725618650 -0800
+++ hv-rhel6.x/hv/hv_fcopy.c	2015-12-01 16:53:22.584621060 -0800
@@ -19,8 +19,8 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include <linux/nls.h>
 #include <linux/workqueue.h>
+#include <linux/nls.h>
 #include "include/linux/hyperv.h"
 #include <linux/sched.h>
 
@@ -59,7 +59,7 @@
 static void fcopy_timeout_func(struct work_struct *dummy);
 static DECLARE_DELAYED_WORK(fcopy_timeout_work, fcopy_timeout_func);
 static DECLARE_WORK(fcopy_send_work, fcopy_send_data);
-static const char fcopy_devname[] = "vmbus/hv_fcopy";
+static char fcopy_devname[] = "vmbus/hv_fcopy";
 static u8 *recv_buffer;
 static struct hvutil_transport *hvt;
 /*
diff -ru hv-rhel7.x/hv/hv_kvp.c hv-rhel6.x/hv/hv_kvp.c
--- hv-rhel7.x/hv/hv_kvp.c	2015-12-01 16:53:22.735618479 -0800
+++ hv-rhel6.x/hv/hv_kvp.c	2015-12-08 14:58:52.273635771 -0800
@@ -84,7 +84,7 @@
 static DECLARE_DELAYED_WORK(kvp_timeout_work, kvp_timeout_func);
 static DECLARE_WORK(kvp_sendkey_work, kvp_send_key);
 
-static const char kvp_devname[] = "vmbus/hv_kvp";
+static char kvp_devname[] = "vmbus/hv_kvp";
 static u8 *recv_buffer;
 static struct hvutil_transport *hvt;
 /*
@@ -238,43 +238,80 @@
 		/*
 		 * Transform all parameters into utf16 encoding.
 		 */
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))		
+		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.ip_addr,
+				strlen((char *)in->body.kvp_ip_val.ip_addr),
+				(wchar_t *)out->kvp_ip_val.ip_addr);
+#else
 		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.ip_addr,
 				strlen((char *)in->body.kvp_ip_val.ip_addr),
 				UTF16_HOST_ENDIAN,
 				(wchar_t *)out->kvp_ip_val.ip_addr,
 				MAX_IP_ADDR_SIZE);
+#endif
+
 		if (len < 0)
 			return len;
 
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.sub_net,
+				strlen((char *)in->body.kvp_ip_val.sub_net),
+				(wchar_t *)out->kvp_ip_val.sub_net);
+#else
 		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.sub_net,
 				strlen((char *)in->body.kvp_ip_val.sub_net),
 				UTF16_HOST_ENDIAN,
 				(wchar_t *)out->kvp_ip_val.sub_net,
 				MAX_IP_ADDR_SIZE);
+#endif
 		if (len < 0)
 			return len;
 
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.gate_way,
+				strlen((char *)in->body.kvp_ip_val.gate_way),
+				(wchar_t *)out->kvp_ip_val.gate_way);
+#else
 		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.gate_way,
 				strlen((char *)in->body.kvp_ip_val.gate_way),
 				UTF16_HOST_ENDIAN,
 				(wchar_t *)out->kvp_ip_val.gate_way,
 				MAX_GATEWAY_SIZE);
+#endif
+
 		if (len < 0)
 			return len;
 
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.dns_addr,
+				strlen((char *)in->body.kvp_ip_val.dns_addr),
+				(wchar_t *)out->kvp_ip_val.dns_addr);
+#else
 		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.dns_addr,
 				strlen((char *)in->body.kvp_ip_val.dns_addr),
 				UTF16_HOST_ENDIAN,
 				(wchar_t *)out->kvp_ip_val.dns_addr,
 				MAX_IP_ADDR_SIZE);
+#endif
 		if (len < 0)
 			return len;
 
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.adapter_id,
+				strlen((char *)in->body.kvp_ip_val.adapter_id),
+				(wchar_t *)out->kvp_ip_val.adapter_id);
+#else
 		len = utf8s_to_utf16s((char *)in->body.kvp_ip_val.adapter_id,
 				strlen((char *)in->body.kvp_ip_val.adapter_id),
 				UTF16_HOST_ENDIAN,
 				(wchar_t *)out->kvp_ip_val.adapter_id,
 				MAX_IP_ADDR_SIZE);
+#endif
 		if (len < 0)
 			return len;
 
@@ -545,16 +582,28 @@
 	 * will be less than or equal to the MAX size (including the
 	 * terminating character).
 	 */
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+	keylen = utf8s_to_utf16s(key_name, strlen(key_name),
+				(wchar_t *) kvp_data->key);
+#else
 	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
 				(wchar_t *) kvp_data->key,
 				(HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2);
+#endif
 	kvp_data->key_size = 2*(keylen + 1); /* utf16 encoding */
 
 copy_value:
 	value = msg_to_host->body.kvp_enum_data.data.value;
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+	valuelen = utf8s_to_utf16s(value, strlen(value),
+				(wchar_t *) kvp_data->value);
+#else
 	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
 				(wchar_t *) kvp_data->value,
 				(HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2);
+#endif
 	kvp_data->value_size = 2*(valuelen + 1); /* utf16 encoding */
 
 	/*
diff -ru hv-rhel7.x/hv/hv_snapshot.c hv-rhel6.x/hv/hv_snapshot.c
--- hv-rhel7.x/hv/hv_snapshot.c	2015-12-01 16:53:22.742618360 -0800
+++ hv-rhel6.x/hv/hv_snapshot.c	2015-12-01 16:53:22.593620906 -0800
@@ -64,7 +64,7 @@
  */
 static int dm_reg_value;
 
-static const char vss_devname[] = "vmbus/hv_vss";
+static char vss_devname[] = "vmbus/hv_vss";
 static __u8 *recv_buffer;
 static struct hvutil_transport *hvt;
 
diff -ru hv-rhel7.x/hv/hv_util.c hv-rhel6.x/hv/hv_util.c
--- hv-rhel7.x/hv/hv_util.c	2015-12-01 16:53:22.742618360 -0800
+++ hv-rhel6.x/hv/hv_util.c	2015-09-03 18:03:00.722577306 -0700
@@ -446,3 +446,9 @@
 MODULE_DESCRIPTION("Hyper-V Utilities");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(HV_DRV_VERSION);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("vmbus:31600b0e13523449818b38d90ced39db");
+MODULE_ALIAS("vmbus:30e62795aed07b49adcee80ab0175caf");
+MODULE_ALIAS("vmbus:394f16571591784eab55382f3bd5422d");
+MODULE_ALIAS("vmbus:e7f4a0a9455a964db8278a841e8c03e6");
+MODULE_ALIAS("vmbus:292efa3523ea364296ae3a6ebacba440");
diff -ru hv-rhel7.x/hv/hv_utils_transport.c hv-rhel6.x/hv/hv_utils_transport.c
--- hv-rhel7.x/hv/hv_utils_transport.c	2015-12-01 16:53:22.749618240 -0800
+++ hv-rhel6.x/hv/hv_utils_transport.c	2015-12-01 16:53:22.605620701 -0800
@@ -212,7 +212,7 @@
 	return ret;
 }
 
-struct hvutil_transport *hvutil_transport_init(const char *name,
+struct hvutil_transport *hvutil_transport_init(char *name,
 					       u32 cn_idx, u32 cn_val,
 					       int (*on_msg)(void *, int),
 					       void (*on_reset)(void))
diff -ru hv-rhel7.x/hv/hv_utils_transport.h hv-rhel6.x/hv/hv_utils_transport.h
--- hv-rhel7.x/hv/hv_utils_transport.h	2015-12-01 16:53:22.755618137 -0800
+++ hv-rhel6.x/hv/hv_utils_transport.h	2015-12-01 16:53:22.606620684 -0800
@@ -41,7 +41,7 @@
 	struct mutex outmsg_lock;           /* protects outmsg */
 };
 
-struct hvutil_transport *hvutil_transport_init(const char *name,
+struct hvutil_transport *hvutil_transport_init(char *name,
 					       u32 cn_idx, u32 cn_val,
 					       int (*on_msg)(void *, int),
 					       void (*on_reset)(void));
diff -ru hv-rhel7.x/hv/hyperv_fb.c hv-rhel6.x/hv/hyperv_fb.c
--- hv-rhel7.x/hv/hyperv_fb.c	2015-12-01 16:53:22.756618120 -0800
+++ hv-rhel6.x/hv/hyperv_fb.c	2015-12-01 16:53:22.607620667 -0800
@@ -682,7 +682,7 @@
 	struct hvfb_par *par = info->par;
 	struct pci_dev *pdev  = NULL;
 	void __iomem *fb_virt;
-	int gen2vm = efi_enabled(EFI_BOOT);
+	int gen2vm = using_null_legacy_pic;
 	resource_size_t pot_start, pot_end;
 	int ret;
 
@@ -716,18 +716,13 @@
 	if (!fb_virt)
 		goto err2;
 
-	info->apertures = alloc_apertures(1);
-	if (!info->apertures)
-		goto err3;
 
 	if (gen2vm) {
-		info->apertures->ranges[0].base = screen_info.lfb_base;
-		info->apertures->ranges[0].size = screen_info.lfb_size;
-		remove_conflicting_framebuffers(info->apertures,
-						KBUILD_MODNAME, false);
+		info->aperture_base = screen_info.lfb_base;
+		info->aperture_size = screen_info.lfb_size;
 	} else {
-		info->apertures->ranges[0].base = pci_resource_start(pdev, 0);
-		info->apertures->ranges[0].size = pci_resource_len(pdev, 0);
+		info->aperture_base = pci_resource_start(pdev, 0);
+		info->aperture_size = pci_resource_len(pdev, 0);
 	}
 
 	info->fix.smem_start = par->mem->start;
@@ -740,8 +735,6 @@
 
 	return 0;
 
-err3:
-	iounmap(fb_virt);
 err2:
 	release_mem_region(par->mem->start, screen_fb_size);
 	par->mem = NULL;
@@ -960,3 +953,4 @@
 MODULE_LICENSE("GPL");
 MODULE_VERSION(HV_DRV_VERSION);
 MODULE_DESCRIPTION("Microsoft Hyper-V Synthetic Video Frame Buffer Driver");
+MODULE_ALIAS("vmbus:02780ada77e3ac4a8e770558eb1073f8");
diff -ru hv-rhel7.x/hv/hyperv-keyboard.c hv-rhel6.x/hv/hyperv-keyboard.c
--- hv-rhel7.x/hv/hyperv-keyboard.c	2015-09-03 18:03:00.742627989 -0700
+++ hv-rhel6.x/hv/hyperv-keyboard.c	2015-09-03 18:03:00.723579840 -0700
@@ -449,6 +449,6 @@
 
 MODULE_LICENSE("GPL");
 MODULE_VERSION(HV_DRV_VERSION);
-
+MODULE_ALIAS("vmbus:6dad12f9172bea48bd65f927a61c7684");
 module_init(hv_kbd_init);
 module_exit(hv_kbd_exit);
diff -ru hv-rhel7.x/hv/hyperv_net.h hv-rhel6.x/hv/hyperv_net.h
--- hv-rhel7.x/hv/hyperv_net.h	2015-12-01 16:53:22.768617915 -0800
+++ hv-rhel6.x/hv/hyperv_net.h	2015-12-01 16:53:22.608620650 -0800
@@ -26,7 +26,7 @@
 
 #include <linux/list.h>
 #include "include/linux/hyperv.h"
-#include "include/linux/rndis.h"
+#include <linux/rndis.h>
 
 /* RSS related */
 #define OID_GEN_RECEIVE_SCALE_CAPABILITIES 0x00010203  /* query only */
@@ -652,8 +652,13 @@
 	struct work_struct work;
 	u32 msg_enable; /* debug level */
 
+#if defined(RHEL_RELEASE_VERSION) && RHEL_RELEASE_CODE > 1536
 	struct netvsc_stats __percpu *tx_stats;
 	struct netvsc_stats __percpu *rx_stats;
+#else
+	struct netvsc_stats *tx_stats;
+	struct netvsc_stats *rx_stats;
+#endif
 };
 
 /* Per netvsc device */
diff -ru hv-rhel7.x/hv/hyperv_vmbus.h hv-rhel6.x/hv/hyperv_vmbus.h
--- hv-rhel7.x/hv/hyperv_vmbus.h	2015-12-01 16:53:22.769617898 -0800
+++ hv-rhel6.x/hv/hyperv_vmbus.h	2015-12-01 16:53:22.609620632 -0800
@@ -576,14 +576,6 @@
        u64 reserved2[509];
 };
 
-struct hv_ring_buffer_debug_info {
-	u32 current_interrupt_mask;
-	u32 current_read_index;
-	u32 current_write_index;
-	u32 bytes_avail_toread;
-	u32 bytes_avail_towrite;
-};
-
 /* Hv Interface */
 
 extern int hv_init(void);
diff -ru hv-rhel7.x/hv/include/asm/mshyperv.h hv-rhel6.x/hv/include/asm/mshyperv.h
--- hv-rhel7.x/hv/include/asm/mshyperv.h	2015-09-03 18:03:00.743630523 -0700
+++ hv-rhel6.x/hv/include/asm/mshyperv.h	2015-09-03 18:03:00.724582374 -0700
@@ -16,6 +16,8 @@
 #ifdef CONFIG_TRACING
 #define trace_hyperv_callback_vector hyperv_callback_vector
 #endif
+void hv_register_vmbus_handler(int irq, irq_handler_t handler);
+
 void hyperv_vector_handler(struct pt_regs *regs);
 void hv_setup_vmbus_irq(void (*handler)(void));
 void hv_remove_vmbus_irq(void);
diff -ru hv-rhel7.x/hv/include/linux/atomic.h hv-rhel6.x/hv/include/linux/atomic.h
--- hv-rhel7.x/hv/include/linux/atomic.h	2015-09-03 18:03:00.743630523 -0700
+++ hv-rhel6.x/hv/include/linux/atomic.h	2015-09-03 18:03:00.724582374 -0700
@@ -1,131 +1,6 @@
-/* Atomic operations usable in machine independent code */
 #ifndef _LINUX_ATOMIC_H
 #define _LINUX_ATOMIC_H
-#include <asm-generic/atomic.h>
 
-/**
- * atomic_add_unless - add unless the number is already a given value
- * @v: pointer of type atomic_t
- * @a: the amount to add to v...
- * @u: ...unless v is equal to u.
- *
- * Atomically adds @a to @v, so long as @v was not already @u.
- * Returns non-zero if @v was not @u, and zero otherwise.
- */
-static inline int atomic_add_unless(atomic_t *v, int a, int u)
-{
-	return __atomic_add_unless(v, a, u) != u;
-}
+#include <asm/atomic.h>
 
-/**
- * atomic_inc_not_zero - increment unless the number is zero
- * @v: pointer of type atomic_t
- *
- * Atomically increments @v by 1, so long as @v is non-zero.
- * Returns non-zero if @v was non-zero, and zero otherwise.
- */
-#ifndef atomic_inc_not_zero
-#define atomic_inc_not_zero(v)		atomic_add_unless((v), 1, 0)
-#endif
-
-/**
- * atomic_inc_not_zero_hint - increment if not null
- * @v: pointer of type atomic_t
- * @hint: probable value of the atomic before the increment
- *
- * This version of atomic_inc_not_zero() gives a hint of probable
- * value of the atomic. This helps processor to not read the memory
- * before doing the atomic read/modify/write cycle, lowering
- * number of bus transactions on some arches.
- *
- * Returns: 0 if increment was not done, 1 otherwise.
- */
-#ifndef atomic_inc_not_zero_hint
-static inline int atomic_inc_not_zero_hint(atomic_t *v, int hint)
-{
-	int val, c = hint;
-
-	/* sanity test, should be removed by compiler if hint is a constant */
-	if (!hint)
-		return atomic_inc_not_zero(v);
-
-	do {
-		val = atomic_cmpxchg(v, c, c + 1);
-		if (val == c)
-			return 1;
-		c = val;
-	} while (c);
-
-	return 0;
-}
-#endif
-
-#ifndef atomic_inc_unless_negative
-static inline int atomic_inc_unless_negative(atomic_t *p)
-{
-	int v, v1;
-	for (v = 0; v >= 0; v = v1) {
-		v1 = atomic_cmpxchg(p, v, v + 1);
-		if (likely(v1 == v))
-			return 1;
-	}
-	return 0;
-}
-#endif
-
-#ifndef atomic_dec_unless_positive
-static inline int atomic_dec_unless_positive(atomic_t *p)
-{
-	int v, v1;
-	for (v = 0; v <= 0; v = v1) {
-		v1 = atomic_cmpxchg(p, v, v - 1);
-		if (likely(v1 == v))
-			return 1;
-	}
-	return 0;
-}
-#endif
-
-/*
- * atomic_dec_if_positive - decrement by 1 if old value positive
- * @v: pointer of type atomic_t
- *
- * The function returns the old value of *v minus 1, even if
- * the atomic variable, v, was not decremented.
- */
-#ifndef atomic_dec_if_positive
-static inline int atomic_dec_if_positive(atomic_t *v)
-{
-	int c, old, dec;
-	c = atomic_read(v);
-	for (;;) {
-		dec = c - 1;
-		if (unlikely(dec < 0))
-			break;
-		old = atomic_cmpxchg((v), c, dec);
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return dec;
-}
-#endif
-
-#ifndef CONFIG_ARCH_HAS_ATOMIC_OR
-static inline void atomic_or(int i, atomic_t *v)
-{
-	int old;
-	int new;
-
-	do {
-		old = atomic_read(v);
-		new = old | i;
-	} while (atomic_cmpxchg(v, old, new) != old);
-}
-#endif /* #ifndef CONFIG_ARCH_HAS_ATOMIC_OR */
-
-#include <asm-generic/atomic-long.h>
-#ifdef CONFIG_GENERIC_ATOMIC64
-#include <asm-generic/atomic64.h>
-#endif
 #endif /* _LINUX_ATOMIC_H */
Only in hv-rhel7.x/hv/include/linux: hid-debug.h
Only in hv-rhel7.x/hv/include/linux: hid.h
Only in hv-rhel7.x/hv/include/linux: hidraw.h
diff -ru hv-rhel7.x/hv/include/linux/hv_compat.h hv-rhel6.x/hv/include/linux/hv_compat.h
--- hv-rhel7.x/hv/include/linux/hv_compat.h	2015-12-08 16:14:55.517922734 -0800
+++ hv-rhel6.x/hv/include/linux/hv_compat.h	2015-12-10 15:21:29.376179197 -0800
@@ -4,8 +4,25 @@
 
 #include <linux/version.h>
 
-//#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 10, 0)
+/*
+ * Helpers for determining EXTRAVERSION info on RHEL/CentOS update kernels
+ */
+#if defined(RHEL_RELEASE_VERSION)
+#define KERNEL_EXTRAVERSION(a,b) (((a) << 16) + (b))
+
+#define RHEL_RELEASE_UPDATE_VERSION(a,b,c,d) \
+	(((RHEL_RELEASE_VERSION(a,b)) << 32) + (KERNEL_EXTRAVERSION(c,d)))
+
+#if defined(EXTRAVERSION1) && defined (EXTRAVERSION2)
+#define RHEL_RELEASE_UPDATE_CODE \
+	RHEL_RELEASE_UPDATE_VERSION(RHEL_MAJOR,RHEL_MINOR,EXTRAVERSION1,EXTRAVERSION2)
+#else
+#define RHEL_RELEASE_UPDATE_CODE \
+	RHEL_RELEASE_UPDATE_VERSION(RHEL_MAJOR,RHEL_MINOR,0,0)
+#endif
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)
 
 #define CN_KVP_IDX	0x9
 #define CN_KVP_VAL	0x1
@@ -30,13 +47,16 @@
 #include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1542)
+#include <linux/u64_stats_sync.h>
+#endif
 
 #define CN_KVP_IDX	0x9
 
 #define CN_VSS_IDX	0xA
 #define CN_VSS_VAL	0x1
 
-#define HV_DRV_VERSION	"4.0.7"
+#define HV_DRV_VERSION	"4.0.11"
 
 #if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE <= 1540)
 #ifdef CONFIG_MEMORY_HOTPLUG
@@ -109,13 +129,10 @@
 #endif
 
 bool netvsc_set_hash(u32 *hash, struct sk_buff *skb);
-
-
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1793) // 1542)
 static inline __u32
 skb_get_hash(struct sk_buff *skb)
 {
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1792) // 1542)
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1543)
         return skb->hash;
 #else
 	__u32 hash;
@@ -124,13 +141,10 @@
 	return 0;
 #endif
 }
-#endif
 
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1792)
 static inline void pm_wakeup_event(struct device *dev, unsigned int msec)
 {
 }
-#endif
 
 #if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1540)
 static inline int kstrtouint(const char *s, unsigned int base, unsigned int *res)
@@ -146,36 +160,27 @@
 
 #define PTE_SHIFT ilog2(PTRS_PER_PTE)
 
-#if defined (RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1793)
 static inline void reinit_completion(struct completion *x)
 {
 	x->done = 0;
 }
-#endif
 
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1792)
+
 static inline int page_level_shift(int level)
 {
         return (PAGE_SHIFT - PTE_SHIFT) + level * PTE_SHIFT;
 }
-#endif
 
-
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1792)
 static inline unsigned long page_level_size(int level)
 {
 	return 1UL << page_level_shift(level);
 }
-#endif
 
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1792)
 static inline unsigned long page_level_mask(int level)
 {
 	return ~(page_level_size(level) - 1);
 }
-#endif
 
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1792)
 static inline phys_addr_t slow_virt_to_phys(void *__virt_addr)
 {
 	unsigned long virt_addr = (unsigned long)__virt_addr;
@@ -194,7 +199,6 @@
 	phys_addr = (phys_addr_t)pte_pfn(*pte) << PAGE_SHIFT;
 	return (phys_addr | offset);
 }
-#endif
 
 #if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1540)
 /*
@@ -261,6 +265,27 @@
  *    * - UP 32bit must disable irqs.
  *     * - 64bit have no problem atomically reading u64 values, irq safe.
  *      */
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1542)
+struct u64_stats_sync {
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	seqcount_t	seq;
+#endif
+};
+
+static inline void u64_stats_update_begin(struct u64_stats_sync *syncp)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	write_seqcount_begin(&syncp->seq);
+#endif
+}
+
+static inline void u64_stats_update_end(struct u64_stats_sync *syncp)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	write_seqcount_end(&syncp->seq);
+#endif
+}
+
 static inline unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync *syncp)
 {
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
@@ -286,7 +311,6 @@
 #endif
 }
 
-#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE <= 1792)
 static inline void u64_stats_init(struct u64_stats_sync *syncp)
 {
 #if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
@@ -309,6 +333,11 @@
 })
 #endif
 
+#if defined(RHEL_RELEASE_VERSION) && RHEL_RELEASE_CODE <= 1536
+#define this_cpu_ptr(ptr) SHIFT_PERCPU_PTR((ptr), my_cpu_offset)
+#endif
+
+
 /*
  * Define Infiniband MLX4 dependencies for RDMA driver
  */
@@ -334,6 +363,7 @@
 	__u32	cqe_size;
 };
 
-#endif //#ifdef __KERNEL__
-#endif //#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 10, 0)
-#endif //#ifndef _HV_COMPAT_H
+
+#endif
+#endif
+#endif
diff -ru hv-rhel7.x/hv/include/linux/hyperv.h hv-rhel6.x/hv/include/linux/hyperv.h
--- hv-rhel7.x/hv/include/linux/hyperv.h	2015-12-01 16:53:22.780617710 -0800
+++ hv-rhel6.x/hv/include/linux/hyperv.h	2015-12-01 16:53:22.627620325 -0800
@@ -26,6 +26,7 @@
 #define _HYPERV_H
 
 #include "../uapi/linux/hyperv.h"
+#include "../asm/hyperv.h"
 
 #include <linux/types.h>
 #include <linux/scatterlist.h>
@@ -127,6 +128,14 @@
 	u32 ring_data_startoffset;
 };
 
+struct hv_ring_buffer_debug_info {
+	u32 current_interrupt_mask;
+	u32 current_read_index;
+	u32 current_write_index;
+	u32 bytes_avail_toread;
+	u32 bytes_avail_towrite;
+};
+
 /*
  *
  * hv_get_ringbuffer_availbytes()
@@ -575,6 +584,23 @@
 	CHANNEL_OPENED_STATE,
 };
 
+struct vmbus_channel_debug_info {
+	u32 relid;
+	enum vmbus_channel_state state;
+	uuid_le interfacetype;
+	uuid_le interface_instance;
+	u32 monitorid;
+	u32 servermonitor_pending;
+	u32 servermonitor_latency;
+	u32 servermonitor_connectionid;
+	u32 clientmonitor_pending;
+	u32 clientmonitor_latency;
+	u32 clientmonitor_connectionid;
+
+	struct hv_ring_buffer_debug_info inbound;
+	struct hv_ring_buffer_debug_info outbound;
+};
+
 /*
  * Represents each channel msg on the vmbus connection This is a
  * variable-size data structure depending on the msg type itself
@@ -921,6 +947,18 @@
 
 extern void vmbus_ontimer(unsigned long data);
 
+extern void vmbus_get_debug_info(struct vmbus_channel *channel,
+				struct vmbus_channel_debug_info *debug);
+
+struct hv_dev_port_info {
+	u32 int_mask;
+	u32 read_idx;
+	u32 write_idx;
+	u32 bytes_avail_toread;
+	u32 bytes_avail_towrite;
+};
+
+
 /* Base driver object */
 struct hv_driver {
 	const char *name;
diff -ru hv-rhel7.x/hv/include/uapi/linux/hyperv.h hv-rhel6.x/hv/include/uapi/linux/hyperv.h
--- hv-rhel7.x/hv/include/uapi/linux/hyperv.h	2015-12-01 16:53:22.791617522 -0800
+++ hv-rhel6.x/hv/include/uapi/linux/hyperv.h	2015-12-01 16:53:22.632620239 -0800
@@ -25,10 +25,10 @@
 #ifndef _UAPI_HYPERV_H
 #define _UAPI_HYPERV_H
 
-#include <linux/uuid.h>
-
+#include "uuid.h"
 #include <linux/version.h>
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,10,0)
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)
 #include "../../linux/hv_compat.h"
 #endif
 
diff -ru hv-rhel7.x/hv/include/uapi/linux/uuid.h hv-rhel6.x/hv/include/uapi/linux/uuid.h
--- hv-rhel7.x/hv/include/uapi/linux/uuid.h	2015-09-03 18:03:00.747640660 -0700
+++ hv-rhel6.x/hv/include/uapi/linux/uuid.h	2015-09-03 18:03:00.727589977 -0700
@@ -18,8 +18,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifndef _UAPI_LINUX_UUID_H_
-#define _UAPI_LINUX_UUID_H_
+#ifndef _LINUX_UUID_H_
+#define _LINUX_UUID_H_
 
 #include <linux/types.h>
 #include <linux/string.h>
@@ -54,5 +54,21 @@
 	UUID_BE(0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00,	\
 		0x00, 0x00, 0x00, 0x00)
 
+#ifdef __KERNEL__
 
-#endif /* _UAPI_LINUX_UUID_H_ */
+static inline int uuid_le_cmp(const uuid_le u1, const uuid_le u2)
+{
+	return memcmp(&u1, &u2, sizeof(uuid_le));
+}
+
+static inline int uuid_be_cmp(const uuid_be u1, const uuid_be u2)
+{
+	return memcmp(&u1, &u2, sizeof(uuid_be));
+}
+
+extern void uuid_le_gen(uuid_le *u);
+extern void uuid_be_gen(uuid_be *u);
+
+#endif /* __KERNEL__ */
+
+#endif
diff -ru hv-rhel7.x/hv/Makefile hv-rhel6.x/hv/Makefile
--- hv-rhel7.x/hv/Makefile	2015-12-10 15:28:27.983834151 -0800
+++ hv-rhel6.x/hv/Makefile	2015-12-10 15:21:29.374179243 -0800
@@ -10,6 +10,23 @@
 
 ccflags-y += -I$(M)/include/ -DMLX_ND_5
 
+# Get extra kernel version information beyond LINUX_VERSION_CODE or RHEL_RELEASE_CODE.
+# This is used to identify RHEL/CentOS kernel update versions.
+extraversioninfo = $(shell uname -r | awk -F'-' '{print $$2}')
+extraversion1 = $(shell echo $(extraversioninfo) | awk -F'.' '{print $$1}' | grep -E '^[0-9]+$$')
+ifneq ($(extraversion1),)
+	ccflags-y += -DEXTRAVERSION1=$(extraversion1)
+else
+	ccflags-y += -DEXTRAVERSION1=0
+endif
+
+extraversion2 = $(shell echo $(extraversioninfo) | awk -F'.' '{print $$2}' | grep -E '^[0-9]+$$')
+ifneq ($(extraversion2),)
+	ccflags-y += -DEXTRAVERSION2=$(extraversion2)
+else
+	ccflags-y += -DEXTRAVERSION2=0
+endif
+
 hv_vmbus-y := vmbus_drv.o \
 		 hv.o connection.o channel.o \
 		 channel_mgmt.o ring_buffer.o
Only in hv-rhel7.x/hv/: Module.markers
Only in hv-rhel7.x/hv/: modules.order
Only in hv-rhel7.x/hv/: Module.symvers
diff -ru hv-rhel7.x/hv/netvsc.c hv-rhel6.x/hv/netvsc.c
--- hv-rhel7.x/hv/netvsc.c	2015-12-01 16:53:22.792617505 -0800
+++ hv-rhel6.x/hv/netvsc.c	2015-12-01 16:53:22.644620034 -0800
@@ -227,17 +227,23 @@
 	struct netvsc_device *net_device;
 	struct nvsp_message *init_packet;
 	struct net_device *ndev;
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1536)
 	int node;
+#endif
 
 	net_device = get_outbound_net_device(device);
 	if (!net_device)
 		return -ENODEV;
 	ndev = net_device->ndev;
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1536)
 	node = cpu_to_node(device->channel->target_cpu);
 	net_device->recv_buf = vzalloc_node(net_device->recv_buf_size, node);
 	if (!net_device->recv_buf)
 		net_device->recv_buf = vzalloc(net_device->recv_buf_size);
+#else
+	net_device->recv_buf = vzalloc(net_device->recv_buf_size);
+#endif
 
 	if (!net_device->recv_buf) {
 		netdev_err(ndev, "unable to allocate receive "
@@ -326,10 +332,14 @@
 
 	/* Now setup the send buffer.
 	 */
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE > 1536)
 	net_device->send_buf = vzalloc_node(net_device->send_buf_size, node);
 	if (!net_device->send_buf)
 		net_device->send_buf = vzalloc(net_device->send_buf_size);
-
+#else
+	net_device->send_buf = vzalloc(net_device->send_buf_size);
+#endif
+	
 	if (!net_device->send_buf) {
 		netdev_err(ndev, "unable to allocate send "
 			   "buffer of size %d\n", net_device->send_buf_size);
diff -ru hv-rhel7.x/hv/netvsc_drv.c hv-rhel6.x/hv/netvsc_drv.c
--- hv-rhel7.x/hv/netvsc_drv.c	2015-12-01 16:53:22.793617488 -0800
+++ hv-rhel6.x/hv/netvsc_drv.c	2015-12-01 16:53:22.651619915 -0800
@@ -33,11 +33,13 @@
 #include <linux/if_vlan.h>
 #include <linux/in.h>
 #include <linux/slab.h>
+#include <linux/ipv6.h>
 #include <net/arp.h>
 #include <net/route.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 
+#include "include/linux/hyperv.h"
 #include "hyperv_net.h"
 
 
@@ -236,35 +238,28 @@
 
 bool netvsc_set_hash(u32 *hash, struct sk_buff *skb)
 {
-	struct flow_keys flow;
+	struct iphdr *iphdr;
 	int data_len;
+	bool ret = false;
 
-#ifdef NOTYET
-	/* Divergence from upstream commits:
-	 * 06635a35d13d42b95422bba6633f175245cc644e
-	 * cd79a2382aa5dcefa6e21a7c59bb1bb19e53b74d
-	 */
-	if (!skb_flow_dissect_flow_keys(skb, &flow, 0) ||
-	    !(flow.basic.n_proto == htons(ETH_P_IP) ||
-	      flow.basic.n_proto == htons(ETH_P_IPV6)))
-#endif
-	if (!skb_flow_dissect(skb, &flow))
+	skb_reset_mac_header(skb);
+
+	if (eth_hdr(skb)->h_proto != htons(ETH_P_IP))
 		return false;
 
-#ifdef NOTYET
-	/* Divergence from upstream commit:
-	 * 06635a35d13d42b95422bba6633f175245cc644e
-	 */
-	if (flow.basic.ip_proto == IPPROTO_TCP)
-#endif
-	if (flow.ip_proto == IPPROTO_TCP)
-		data_len = 12;
-	else
-		data_len = 8;
+	iphdr = ip_hdr(skb);
 
-	*hash = comp_hash(netvsc_hash_key, HASH_KEYLEN, &flow, data_len);
+	if (iphdr->version == 4) {
+		if (iphdr->protocol == IPPROTO_TCP)
+			data_len = 12;
+		else
+			data_len = 8;
+		*hash = comp_hash(netvsc_hash_key, HASH_KEYLEN,
+				  (u8 *)&iphdr->saddr, data_len);
+		ret = true;
+	}
 
-	return true;
+	return ret;
 }
 
 #ifdef NOTYET
@@ -287,7 +282,8 @@
 	if (netvsc_set_hash(&hash, skb)) {
 		q_idx = nvsc_dev->send_table[hash % VRSS_SEND_TAB_SIZE] %
 			ndev->real_num_tx_queues;
-		skb_set_hash(skb, hash, PKT_HASH_TYPE_L3);
+
+		skb_set_hash(skb, hash, 0);
 	}
 
 	return q_idx;
@@ -407,6 +403,8 @@
 {
 	u32 ret_val = TRANSPORT_INFO_NOT_IP;
 
+	skb_reset_mac_header(skb);
+
 	if ((eth_hdr(skb)->h_proto != htons(ETH_P_IP)) &&
 		(eth_hdr(skb)->h_proto != htons(ETH_P_IPV6))) {
 		goto not_ip;
@@ -464,13 +462,13 @@
 	skb_length = skb->len;
 	num_data_pgs = netvsc_get_slots(skb) + 2;
 	if (num_data_pgs > MAX_PAGE_BUFFER_COUNT && linear) {
-		net_alert_ratelimited("packet too big: %u pages (%u bytes)\n",
+		netdev_err(net, "packet too big: %u pages (%u bytes)\n",
 				      num_data_pgs, skb->len);
 		ret = -EFAULT;
 		goto drop;
 	} else if (num_data_pgs > MAX_PAGE_BUFFER_COUNT) {
 		if (skb_linearize(skb)) {
-			net_alert_ratelimited("failed to linearize skb\n");
+			netdev_err(net, "failed to linearize skb\n");
 			ret = -ENOMEM;
 			goto drop;
 		}
@@ -756,8 +754,7 @@
 	}
 
 	if (packet->vlan_tci & VLAN_TAG_PRESENT)
-		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
-				       packet->vlan_tci);
+		__vlan_hwaccel_put_tag(skb, packet->vlan_tci);
 
 	skb_record_rx_queue(skb, packet->channel->
 			    offermsg.offer.sub_channel_index);
@@ -784,6 +781,7 @@
 	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
 }
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 static void netvsc_get_channels(struct net_device *net,
 				struct ethtool_channels *channel)
 {
@@ -894,6 +892,7 @@
 	channels->combined_count = num_chn;
 	goto do_set;
 }
+#endif
 
 static int netvsc_change_mtu(struct net_device *ndev, int mtu)
 {
@@ -937,6 +936,7 @@
 	return ret;
 }
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 static struct rtnl_link_stats64 *netvsc_get_stats64(struct net_device *net,
 						    struct rtnl_link_stats64 *t)
 {
@@ -977,6 +977,7 @@
 
 	return t;
 }
+#endif
 
 static int netvsc_set_mac_addr(struct net_device *ndev, void *p)
 {
@@ -1016,8 +1017,10 @@
 static const struct ethtool_ops ethtool_ops = {
 	.get_drvinfo	= netvsc_get_drvinfo,
 	.get_link	= ethtool_op_get_link,
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 	.get_channels   = netvsc_get_channels,
 	.set_channels   = netvsc_set_channels,
+#endif
 };
 
 static const struct net_device_ops device_ops = {
@@ -1029,7 +1032,9 @@
 	.ndo_validate_addr =		eth_validate_addr,
 	.ndo_set_mac_address =		netvsc_set_mac_addr,
 	.ndo_select_queue =		netvsc_select_queue,
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 	.ndo_get_stats64 =		netvsc_get_stats64,
+#endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller =		netvsc_poll_controller,
 #endif
@@ -1078,7 +1083,7 @@
 		call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
 
 	if (notify)
-		netdev_notify_peers(net);
+		netif_notify_peers(net);
 }
 
 static void netvsc_free_netdev(struct net_device *netdev)
@@ -1116,6 +1121,7 @@
 		netdev_dbg(net, "netvsc msg_enable: %d\n",
 			net_device_ctx->msg_enable);
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 	net_device_ctx->tx_stats = netdev_alloc_pcpu_stats(struct netvsc_stats);
 	if (!net_device_ctx->tx_stats) {
 		free_netdev(net);
@@ -1127,6 +1133,7 @@
 		free_netdev(net);
 		return -ENOMEM;
 	}
+#endif
 
 	hv_set_drvdata(dev, net);
 	INIT_DELAYED_WORK(&net_device_ctx->dwork, netvsc_link_change);
@@ -1134,8 +1141,10 @@
 
 	net->netdev_ops = &device_ops;
 
+#ifdef NOTYET
 	net->hw_features = NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_IP_CSUM |
 				NETIF_F_TSO;
+#endif
 	net->features = NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_SG | NETIF_F_RXCSUM |
 			NETIF_F_IP_CSUM | NETIF_F_TSO;
 
@@ -1164,7 +1173,13 @@
 
 	nvdev = hv_get_drvdata(dev);
 	netif_set_real_num_tx_queues(net, nvdev->num_chn);
+#ifdef NOTYET
 	netif_set_real_num_rx_queues(net, nvdev->num_chn);
+#endif
+
+	dev_info(&dev->device, "real num tx,rx queues:%u, %u\n",
+		 net->real_num_tx_queues, nvdev->num_chn);
+
 
 	ret = register_netdev(net);
 	if (ret != 0) {
@@ -1247,6 +1262,7 @@
 MODULE_LICENSE("GPL");
 MODULE_VERSION(HV_DRV_VERSION);
 MODULE_DESCRIPTION("Microsoft Hyper-V network driver");
+MODULE_ALIAS("vmbus:635161f83edfc546913ff2d2f965ed0e");
 
 module_init(netvsc_drv_init);
 module_exit(netvsc_drv_exit);
diff -ru hv-rhel7.x/hv/README hv-rhel6.x/hv/README
--- hv-rhel7.x/hv/README	2015-12-01 16:53:22.704619009 -0800
+++ hv-rhel6.x/hv/README	2015-09-03 18:03:00.720572238 -0700
@@ -1,9 +1,9 @@
 After unpacking the tar file; as root:
 
-	Execute the script ./rhel7-hv-driver-install to build and install
-	Hyper-V drivers on a rhel7.x installation. Once the script completes,
-	reboot the machine to bringup RHEL7.X enlightened on Hyper-V.
+	Execute the script ./rhel6-hv-driver-install to build and install
+	Hyper-V drivers on a rhel6 installation. Once the script completes,
+	reboot the machine to bringup RHEL6 enlightened on Hyper-V.
 
 	To uninstall the Hyper-V drivers, execute the script
-	./rhel7-hv-driver-uninstall. Once the script completes, reboot the machine
-	to bringup RHEL7 in fully emulated mode.
+	./rhel6-hv-driver-uninstall. Once the script completes, reboot the machine
+	to bringup RHEL6 in fully emulated mode.
Only in hv-rhel6.x/hv/: rhel6-hv-driver-install
Only in hv-rhel6.x/hv/: rhel6-hv-driver-uninstall
Only in hv-rhel7.x/hv/: rhel7-hv-driver-install
diff -ru hv-rhel7.x/hv/rndis_filter.c hv-rhel6.x/hv/rndis_filter.c
--- hv-rhel7.x/hv/rndis_filter.c	2015-12-01 16:53:22.793617488 -0800
+++ hv-rhel6.x/hv/rndis_filter.c	2015-12-08 14:58:52.286635550 -0800
@@ -590,13 +590,24 @@
 
 	cfg_nwadr = (wchar_t *)((ulong)cpi + cpi->parameter_name_offset);
 	cfg_mac = (wchar_t *)((ulong)cpi + cpi->parameter_value_offset);
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))
+	ret = utf8s_to_utf16s(NWADR_STR, NWADR_STRLEN, cfg_nwadr);
+#else
 	ret = utf8s_to_utf16s(NWADR_STR, NWADR_STRLEN, UTF16_HOST_ENDIAN,
 			      cfg_nwadr, NWADR_STRLEN);
+#endif
 	if (ret < 0)
 		goto cleanup;
 	snprintf(macstr, 2*ETH_ALEN+1, "%pm", mac);
+#if defined(RHEL_RELEASE_UPDATE_CODE) && \
+(RHEL_RELEASE_UPDATE_CODE < RHEL_RELEASE_UPDATE_VERSION(6, 4, 358, 18))	
+	ret = utf8s_to_utf16s(macstr, 2*ETH_ALEN, cfg_mac);
+#else
 	ret = utf8s_to_utf16s(macstr, 2*ETH_ALEN, UTF16_HOST_ENDIAN,
 			      cfg_mac, 2*ETH_ALEN);
+#endif
+
 	if (ret < 0)
 		goto cleanup;
 
diff -ru hv-rhel7.x/hv/storvsc_drv.c hv-rhel6.x/hv/storvsc_drv.c
--- hv-rhel7.x/hv/storvsc_drv.c	2015-12-08 14:58:52.335634718 -0800
+++ hv-rhel6.x/hv/storvsc_drv.c	2015-12-08 14:58:52.288635516 -0800
@@ -736,6 +736,17 @@
 	return NULL;
 }
 
+/* Disgusting wrapper functions */
+static inline unsigned long sg_kmap_atomic(struct scatterlist *sgl)
+{
+	return (unsigned long)kmap_atomic(sg_page(sgl), KM_IRQ0);
+}
+
+static inline void sg_kunmap_atomic(unsigned long addr)
+{
+	kunmap_atomic((void *)addr, KM_IRQ0);
+}
+
 /* Assume the original sgl has enough room */
 static unsigned int copy_from_bounce_buffer(struct scatterlist *orig_sgl,
 					    struct scatterlist *bounce_sgl,
@@ -757,15 +768,12 @@
 	cur_dest_sgl = orig_sgl;
 	cur_src_sgl = bounce_sgl;
 	for (i = 0; i < orig_sgl_count; i++) {
-		dest_addr = (unsigned long)
-				kmap_atomic(sg_page(cur_dest_sgl)) +
-				cur_dest_sgl->offset;
+		dest_addr = sg_kmap_atomic(cur_dest_sgl) + cur_dest_sgl->offset;
 		dest = dest_addr;
 		destlen = cur_dest_sgl->length;
 
 		if (bounce_addr == 0)
-			bounce_addr = (unsigned long)kmap_atomic(
-							sg_page(cur_src_sgl));
+			bounce_addr = sg_kmap_atomic(cur_src_sgl);
 
 		while (destlen) {
 			src = bounce_addr + cur_src_sgl->offset;
@@ -781,7 +789,7 @@
 
 			if (cur_src_sgl->offset == cur_src_sgl->length) {
 				/* full */
-				kunmap_atomic((void *)bounce_addr);
+				sg_kunmap_atomic(bounce_addr);
 				j++;
 				/*
 				 * It is possible that the number of elements
@@ -794,8 +802,8 @@
 					/*
 					 * We are done; cleanup and return.
 					 */
-					kunmap_atomic((void *)(dest_addr -
-						cur_dest_sgl->offset));
+					sg_kunmap_atomic(dest_addr -
+						cur_dest_sgl->offset);
 					local_irq_restore(flags);
 					return total_copied;
 				}
@@ -803,17 +811,15 @@
 				/* if we need to use another bounce buffer */
 				if (destlen || i != orig_sgl_count - 1) {
 					cur_src_sgl = sg_next(cur_src_sgl);
-					bounce_addr = (unsigned long)
-							kmap_atomic(
-							sg_page(cur_src_sgl));
+					bounce_addr = sg_kmap_atomic(cur_src_sgl);
 				}
 			} else if (destlen == 0 && i == orig_sgl_count - 1) {
 				/* unmap the last bounce that is < PAGE_SIZE */
-				kunmap_atomic((void *)bounce_addr);
+				sg_kunmap_atomic(bounce_addr);
 			}
 		}
 
-		kunmap_atomic((void *)(dest_addr - cur_dest_sgl->offset));
+		sg_kunmap_atomic(dest_addr - cur_dest_sgl->offset);
 		cur_dest_sgl = sg_next(cur_dest_sgl);
 	}
 
@@ -843,15 +849,12 @@
 	cur_dest_sgl = bounce_sgl;
 
 	for (i = 0; i < orig_sgl_count; i++) {
-		src_addr = (unsigned long)
-				kmap_atomic(sg_page(cur_src_sgl)) +
-				cur_src_sgl->offset;
+		src_addr = sg_kmap_atomic(cur_src_sgl) + cur_src_sgl->offset;
 		src = src_addr;
 		srclen = cur_src_sgl->length;
 
 		if (bounce_addr == 0)
-			bounce_addr = (unsigned long)
-					kmap_atomic(sg_page(cur_dest_sgl));
+			bounce_addr = sg_kmap_atomic(cur_dest_sgl);
 
 		while (srclen) {
 			/* assume bounce offset always == 0 */
@@ -868,25 +871,23 @@
 
 			if (cur_dest_sgl->length == PAGE_SIZE) {
 				/* full..move to next entry */
-				kunmap_atomic((void *)bounce_addr);
+				sg_kunmap_atomic(bounce_addr);
 				bounce_addr = 0;
 			}
 
 			/* if we need to use another bounce buffer */
 			if (srclen && bounce_addr == 0) {
 				cur_dest_sgl = sg_next(cur_dest_sgl);
-				bounce_addr = (unsigned long)
-						kmap_atomic(
-						sg_page(cur_dest_sgl));
+				bounce_addr = sg_kmap_atomic(cur_dest_sgl);
 			}
 		}
 
-		kunmap_atomic((void *)(src_addr - cur_src_sgl->offset));
+		sg_kunmap_atomic(src_addr - cur_src_sgl->offset);
 		cur_src_sgl = sg_next(cur_src_sgl);
 	}
 
 	if (bounce_addr)
-		kunmap_atomic((void *)bounce_addr);
+		sg_kunmap_atomic(bounce_addr);
 
 	local_irq_restore(flags);
 
@@ -1616,7 +1617,9 @@
 
 	blk_queue_rq_timeout(sdevice->request_queue, (storvsc_timeout * HZ));
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 	sdevice->no_write_same = 1;
+#endif
 
 #ifdef NOTYET
 	// Divergence from upstream commit:
@@ -1643,8 +1646,10 @@
 			break;
 		}
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1792)
 		if (vmstor_proto_version >= VMSTOR_PROTO_VERSION_WIN10)
 			sdevice->no_write_same = 0;
+#endif
 	}
 
 	return 0;
@@ -1748,15 +1753,10 @@
 	 * this. So, don't send it.
 	 */
 	case SET_WINDOW:
-		/*
-		 * This returned result is an expected divergence from
-		 * upstream code.
-		 */
-                scsi_build_sense_buffer(0, scmnd->sense_buffer, ILLEGAL_REQUEST,
-                    0x20, 0);
-                scmnd->result = SAM_STAT_CHECK_CONDITION;
-                set_driver_byte(scmnd, DRIVER_SENSE);
-                set_host_byte(scmnd, DID_ABORT);
+		scsi_build_sense_buffer(0, scmnd->sense_buffer,
+					ILLEGAL_REQUEST, 0, 0);
+
+		scmnd->result = (DRIVER_SENSE << 24) | SAM_STAT_CHECK_CONDITION;
 		allowed = false;
 		break;
 	default:
@@ -1793,6 +1793,9 @@
 	u32 payload_sz;
 	u32 length;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,32))
+	scmnd->scsi_done = done;
+#endif
 
 	if (vmstor_proto_version <= VMSTOR_PROTO_VERSION_WIN8) {
 		/*
Only in hv-rhel7.x/hv/tools: hv_get_dhcp_info
Only in hv-rhel7.x/hv/tools: hv_get_dns_info
diff -ru hv-rhel7.x/hv/tools/hv_kvp_daemon.c hv-rhel6.x/hv/tools/hv_kvp_daemon.c
--- hv-rhel7.x/hv/tools/hv_kvp_daemon.c	2015-12-01 16:53:22.795617454 -0800
+++ hv-rhel6.x/hv/tools/hv_kvp_daemon.c	2015-12-01 16:53:22.680619419 -0800
@@ -34,6 +34,7 @@
 #include <errno.h>
 #include <arpa/inet.h>
 #include "../include/uapi/linux/hyperv.h"
+#include "../include/linux/hv_compat.h"
 #include <linux/netlink.h>
 #include <ifaddrs.h>
 #include <netdb.h>
Only in hv-rhel7.x/hv/tools: hv_set_ifconfig
Only in hv-rhel7.x/hv/tools: lsvmbus
diff -ru hv-rhel7.x/hv/vmbus_drv.c hv-rhel6.x/hv/vmbus_drv.c
--- hv-rhel7.x/hv/vmbus_drv.c	2015-12-01 16:53:22.805617283 -0800
+++ hv-rhel6.x/hv/vmbus_drv.c	2015-12-01 16:53:22.688619282 -0800
@@ -31,7 +31,6 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/completion.h>
-#include <asm/mshyperv.h>
 #include "include/linux/hyperv.h"
 #include <linux/kernel_stat.h>
 #include <linux/clockchips.h>
@@ -39,14 +38,58 @@
 #include "include/asm/hyperv.h"
 #include <asm/hypervisor.h>
 #include <linux/screen_info.h>
+#include "include/asm/mshyperv.h"
+#include <linux/notifier.h>
+#include <linux/ptrace.h>
 #include "hyperv_vmbus.h"
 
+#if (RHEL_RELEASE_CODE <= 1541)
+bool using_null_legacy_pic = false;
+EXPORT_SYMBOL(using_null_legacy_pic);
+#endif
+
+#if (RHEL_RELEASE_CODE < 1540)
+#include <asm/mshyperv.h>
+
+int x86_hyper_ms_hyperv;
+EXPORT_SYMBOL(x86_hyper_ms_hyperv);
+
+void *x86_hyper = &x86_hyper_ms_hyperv;
+EXPORT_SYMBOL(x86_hyper);
+
+struct ms_hyperv_info ms_hyperv = {
+	.features = HV_X64_MSR_TIME_REF_COUNT_AVAILABLE |
+		    HV_X64_MSR_SYNTIMER_AVAILABLE,
+};
+EXPORT_SYMBOL(ms_hyperv);
+
+#endif
+
 static struct acpi_device  *hv_acpi_dev;
 
 static struct tasklet_struct msg_dpc;
 static struct completion probe_event;
 static int irq;
 
+struct hv_device_info {
+	u32 chn_id;
+	u32 chn_state;
+	uuid_le chn_type;
+	uuid_le chn_instance;
+
+	u32 monitor_id;
+	u32 server_monitor_pending;
+	u32 server_monitor_latency;
+	u32 server_monitor_conn_id;
+	u32 client_monitor_pending;
+	u32 client_monitor_latency;
+	u32 client_monitor_conn_id;
+
+	struct hv_dev_port_info inbound;
+	struct hv_dev_port_info outbound;
+};
+
+
 
 int hyperv_panic_event(struct notifier_block *nb,
                         unsigned long event, void *ptr)
@@ -91,326 +134,162 @@
 		sprintf(&alias_name[i], "%02x", hv_dev->dev_type.b[i/2]);
 }
 
-static u8 channel_monitor_group(struct vmbus_channel *channel)
-{
-	return (u8)channel->offermsg.monitorid / 32;
-}
-
-static u8 channel_monitor_offset(struct vmbus_channel *channel)
-{
-	return (u8)channel->offermsg.monitorid % 32;
-}
-
-static u32 channel_pending(struct vmbus_channel *channel,
-			   struct hv_monitor_page *monitor_page)
-{
-	u8 monitor_group = channel_monitor_group(channel);
-	return monitor_page->trigger_group[monitor_group].pending;
-}
-
-static u32 channel_latency(struct vmbus_channel *channel,
-			   struct hv_monitor_page *monitor_page)
-{
-	u8 monitor_group = channel_monitor_group(channel);
-	u8 monitor_offset = channel_monitor_offset(channel);
-	return monitor_page->latency[monitor_group][monitor_offset];
-}
-
-static u32 channel_conn_id(struct vmbus_channel *channel,
-			   struct hv_monitor_page *monitor_page)
-{
-	u8 monitor_group = channel_monitor_group(channel);
-	u8 monitor_offset = channel_monitor_offset(channel);
-	return monitor_page->parameter[monitor_group][monitor_offset].connectionid.u.id;
-}
-
-static ssize_t id_show(struct device *dev, struct device_attribute *dev_attr,
-		       char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n", hv_dev->channel->offermsg.child_relid);
-}
-static DEVICE_ATTR_RO(id);
-
-static ssize_t state_show(struct device *dev, struct device_attribute *dev_attr,
-			  char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n", hv_dev->channel->state);
-}
-static DEVICE_ATTR_RO(state);
-
-static ssize_t monitor_id_show(struct device *dev,
-			       struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n", hv_dev->channel->offermsg.monitorid);
-}
-static DEVICE_ATTR_RO(monitor_id);
-
-static ssize_t class_id_show(struct device *dev,
-			       struct device_attribute *dev_attr, char *buf)
+static void get_channel_info(struct hv_device *device,
+				struct hv_device_info *info)
 {
-	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel_debug_info debug_info;
 
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "{%pUl}\n",
-		       hv_dev->channel->offermsg.offer.if_type.b);
-}
-static DEVICE_ATTR_RO(class_id);
+	if (!device->channel)
+		return;
 
-static ssize_t device_id_show(struct device *dev,
-			      struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
+	vmbus_get_debug_info(device->channel, &debug_info);
 
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "{%pUl}\n",
-		       hv_dev->channel->offermsg.offer.if_instance.b);
+	info->chn_id = debug_info.relid;
+	info->chn_state = debug_info.state;
+	memcpy(&info->chn_type, &debug_info.interfacetype,
+		sizeof(uuid_le));
+	memcpy(&info->chn_instance, &debug_info.interface_instance,
+		sizeof(uuid_le));
+
+	info->monitor_id = debug_info.monitorid;
+
+	info->server_monitor_pending = debug_info.servermonitor_pending;
+	info->server_monitor_latency = debug_info.servermonitor_latency;
+	info->server_monitor_conn_id = debug_info.servermonitor_connectionid;
+
+	info->client_monitor_pending = debug_info.clientmonitor_pending;
+	info->client_monitor_latency = debug_info.clientmonitor_latency;
+	info->client_monitor_conn_id = debug_info.clientmonitor_connectionid;
+
+	info->inbound.int_mask = debug_info.inbound.current_interrupt_mask;
+	info->inbound.read_idx = debug_info.inbound.current_read_index;
+	info->inbound.write_idx = debug_info.inbound.current_write_index;
+	info->inbound.bytes_avail_toread =
+		debug_info.inbound.bytes_avail_toread;
+	info->inbound.bytes_avail_towrite =
+		debug_info.inbound.bytes_avail_towrite;
+
+	info->outbound.int_mask =
+		debug_info.outbound.current_interrupt_mask;
+	info->outbound.read_idx = debug_info.outbound.current_read_index;
+	info->outbound.write_idx = debug_info.outbound.current_write_index;
+	info->outbound.bytes_avail_toread =
+		debug_info.outbound.bytes_avail_toread;
+	info->outbound.bytes_avail_towrite =
+		debug_info.outbound.bytes_avail_towrite;
 }
-static DEVICE_ATTR_RO(device_id);
 
-static ssize_t modalias_show(struct device *dev,
-			     struct device_attribute *dev_attr, char *buf)
+/*
+ * vmbus_show_device_attr - Show the device attribute in sysfs.
+ *
+ * This is invoked when user does a
+ * "cat /sys/bus/vmbus/devices/<busdevice>/<attr name>"
+ */
+static ssize_t vmbus_show_device_attr(struct device *dev,
+				      struct device_attribute *dev_attr,
+				      char *buf)
 {
 	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct hv_device_info *device_info;
 	char alias_name[VMBUS_ALIAS_LEN + 1];
+	int ret = 0;
 
-	print_alias_name(hv_dev, alias_name);
-	return sprintf(buf, "vmbus:%s\n", alias_name);
-}
-static DEVICE_ATTR_RO(modalias);
-
-static ssize_t server_monitor_pending_show(struct device *dev,
-					   struct device_attribute *dev_attr,
-					   char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n",
-		       channel_pending(hv_dev->channel,
-				       vmbus_connection.monitor_pages[1]));
-}
-static DEVICE_ATTR_RO(server_monitor_pending);
-
-static ssize_t client_monitor_pending_show(struct device *dev,
-					   struct device_attribute *dev_attr,
-					   char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n",
-		       channel_pending(hv_dev->channel,
-				       vmbus_connection.monitor_pages[1]));
-}
-static DEVICE_ATTR_RO(client_monitor_pending);
-
-static ssize_t server_monitor_latency_show(struct device *dev,
-					   struct device_attribute *dev_attr,
-					   char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n",
-		       channel_latency(hv_dev->channel,
-				       vmbus_connection.monitor_pages[0]));
-}
-static DEVICE_ATTR_RO(server_monitor_latency);
-
-static ssize_t client_monitor_latency_show(struct device *dev,
-					   struct device_attribute *dev_attr,
-					   char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n",
-		       channel_latency(hv_dev->channel,
-				       vmbus_connection.monitor_pages[1]));
-}
-static DEVICE_ATTR_RO(client_monitor_latency);
-
-static ssize_t server_monitor_conn_id_show(struct device *dev,
-					   struct device_attribute *dev_attr,
-					   char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n",
-		       channel_conn_id(hv_dev->channel,
-				       vmbus_connection.monitor_pages[0]));
-}
-static DEVICE_ATTR_RO(server_monitor_conn_id);
-
-static ssize_t client_monitor_conn_id_show(struct device *dev,
-					   struct device_attribute *dev_attr,
-					   char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	return sprintf(buf, "%d\n",
-		       channel_conn_id(hv_dev->channel,
-				       vmbus_connection.monitor_pages[1]));
-}
-static DEVICE_ATTR_RO(client_monitor_conn_id);
-
-static ssize_t out_intr_mask_show(struct device *dev,
-				  struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info outbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);
-	return sprintf(buf, "%d\n", outbound.current_interrupt_mask);
-}
-static DEVICE_ATTR_RO(out_intr_mask);
-
-static ssize_t out_read_index_show(struct device *dev,
-				   struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info outbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);
-	return sprintf(buf, "%d\n", outbound.current_read_index);
-}
-static DEVICE_ATTR_RO(out_read_index);
-
-static ssize_t out_write_index_show(struct device *dev,
-				    struct device_attribute *dev_attr,
-				    char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info outbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);
-	return sprintf(buf, "%d\n", outbound.current_write_index);
-}
-static DEVICE_ATTR_RO(out_write_index);
-
-static ssize_t out_read_bytes_avail_show(struct device *dev,
-					 struct device_attribute *dev_attr,
-					 char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info outbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);
-	return sprintf(buf, "%d\n", outbound.bytes_avail_toread);
-}
-static DEVICE_ATTR_RO(out_read_bytes_avail);
-
-static ssize_t out_write_bytes_avail_show(struct device *dev,
-					  struct device_attribute *dev_attr,
-					  char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info outbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->outbound, &outbound);
-	return sprintf(buf, "%d\n", outbound.bytes_avail_towrite);
-}
-static DEVICE_ATTR_RO(out_write_bytes_avail);
-
-static ssize_t in_intr_mask_show(struct device *dev,
-				 struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info inbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);
-	return sprintf(buf, "%d\n", inbound.current_interrupt_mask);
-}
-static DEVICE_ATTR_RO(in_intr_mask);
-
-static ssize_t in_read_index_show(struct device *dev,
-				  struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info inbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);
-	return sprintf(buf, "%d\n", inbound.current_read_index);
-}
-static DEVICE_ATTR_RO(in_read_index);
-
-static ssize_t in_write_index_show(struct device *dev,
-				   struct device_attribute *dev_attr, char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info inbound;
-
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);
-	return sprintf(buf, "%d\n", inbound.current_write_index);
-}
-static DEVICE_ATTR_RO(in_write_index);
-
-static ssize_t in_read_bytes_avail_show(struct device *dev,
-					struct device_attribute *dev_attr,
-					char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info inbound;
+	device_info = kzalloc(sizeof(struct hv_device_info), GFP_KERNEL);
+	if (!device_info)
+		return ret;
 
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);
-	return sprintf(buf, "%d\n", inbound.bytes_avail_toread);
-}
-static DEVICE_ATTR_RO(in_read_bytes_avail);
+	get_channel_info(hv_dev, device_info);
 
-static ssize_t in_write_bytes_avail_show(struct device *dev,
-					 struct device_attribute *dev_attr,
-					 char *buf)
-{
-	struct hv_device *hv_dev = device_to_hv_device(dev);
-	struct hv_ring_buffer_debug_info inbound;
+	if (!strcmp(dev_attr->attr.name, "class_id")) {
+		ret = sprintf(buf, "{%02x%02x%02x%02x-%02x%02x-%02x%02x-"
+				"%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
+				device_info->chn_type.b[3],
+				device_info->chn_type.b[2],
+				device_info->chn_type.b[1],
+				device_info->chn_type.b[0],
+				device_info->chn_type.b[5],
+				device_info->chn_type.b[4],
+				device_info->chn_type.b[7],
+				device_info->chn_type.b[6],
+				device_info->chn_type.b[8],
+				device_info->chn_type.b[9],
+				device_info->chn_type.b[10],
+				device_info->chn_type.b[11],
+				device_info->chn_type.b[12],
+				device_info->chn_type.b[13],
+				device_info->chn_type.b[14],
+				device_info->chn_type.b[15]);
+	} else if (!strcmp(dev_attr->attr.name, "device_id")) {
+		ret = sprintf(buf, "{%02x%02x%02x%02x-%02x%02x-%02x%02x-"
+				"%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
+				device_info->chn_instance.b[3],
+				device_info->chn_instance.b[2],
+				device_info->chn_instance.b[1],
+				device_info->chn_instance.b[0],
+				device_info->chn_instance.b[5],
+				device_info->chn_instance.b[4],
+				device_info->chn_instance.b[7],
+				device_info->chn_instance.b[6],
+				device_info->chn_instance.b[8],
+				device_info->chn_instance.b[9],
+				device_info->chn_instance.b[10],
+				device_info->chn_instance.b[11],
+				device_info->chn_instance.b[12],
+				device_info->chn_instance.b[13],
+				device_info->chn_instance.b[14],
+				device_info->chn_instance.b[15]);
+	} else if (!strcmp(dev_attr->attr.name, "modalias")) {
+		print_alias_name(hv_dev, alias_name);
+		ret = sprintf(buf, "vmbus:%s\n", alias_name);
+	} else if (!strcmp(dev_attr->attr.name, "state")) {
+		ret = sprintf(buf, "%d\n", device_info->chn_state);
+	} else if (!strcmp(dev_attr->attr.name, "id")) {
+		ret = sprintf(buf, "%d\n", device_info->chn_id);
+	} else if (!strcmp(dev_attr->attr.name, "out_intr_mask")) {
+		ret = sprintf(buf, "%d\n", device_info->outbound.int_mask);
+	} else if (!strcmp(dev_attr->attr.name, "out_read_index")) {
+		ret = sprintf(buf, "%d\n", device_info->outbound.read_idx);
+	} else if (!strcmp(dev_attr->attr.name, "out_write_index")) {
+		ret = sprintf(buf, "%d\n", device_info->outbound.write_idx);
+	} else if (!strcmp(dev_attr->attr.name, "out_read_bytes_avail")) {
+		ret = sprintf(buf, "%d\n",
+			       device_info->outbound.bytes_avail_toread);
+	} else if (!strcmp(dev_attr->attr.name, "out_write_bytes_avail")) {
+		ret = sprintf(buf, "%d\n",
+			       device_info->outbound.bytes_avail_towrite);
+	} else if (!strcmp(dev_attr->attr.name, "in_intr_mask")) {
+		ret = sprintf(buf, "%d\n", device_info->inbound.int_mask);
+	} else if (!strcmp(dev_attr->attr.name, "in_read_index")) {
+		ret = sprintf(buf, "%d\n", device_info->inbound.read_idx);
+	} else if (!strcmp(dev_attr->attr.name, "in_write_index")) {
+		ret = sprintf(buf, "%d\n", device_info->inbound.write_idx);
+	} else if (!strcmp(dev_attr->attr.name, "in_read_bytes_avail")) {
+		ret = sprintf(buf, "%d\n",
+			       device_info->inbound.bytes_avail_toread);
+	} else if (!strcmp(dev_attr->attr.name, "in_write_bytes_avail")) {
+		ret = sprintf(buf, "%d\n",
+			       device_info->inbound.bytes_avail_towrite);
+	} else if (!strcmp(dev_attr->attr.name, "monitor_id")) {
+		ret = sprintf(buf, "%d\n", device_info->monitor_id);
+	} else if (!strcmp(dev_attr->attr.name, "server_monitor_pending")) {
+		ret = sprintf(buf, "%d\n", device_info->server_monitor_pending);
+	} else if (!strcmp(dev_attr->attr.name, "server_monitor_latency")) {
+		ret = sprintf(buf, "%d\n", device_info->server_monitor_latency);
+	} else if (!strcmp(dev_attr->attr.name, "server_monitor_conn_id")) {
+		ret = sprintf(buf, "%d\n",
+			       device_info->server_monitor_conn_id);
+	} else if (!strcmp(dev_attr->attr.name, "client_monitor_pending")) {
+		ret = sprintf(buf, "%d\n", device_info->client_monitor_pending);
+	} else if (!strcmp(dev_attr->attr.name, "client_monitor_latency")) {
+		ret = sprintf(buf, "%d\n", device_info->client_monitor_latency);
+	} else if (!strcmp(dev_attr->attr.name, "client_monitor_conn_id")) {
+		ret = sprintf(buf, "%d\n",
+			       device_info->client_monitor_conn_id);
+	}
 
-	if (!hv_dev->channel)
-		return -ENODEV;
-	hv_ringbuffer_get_debuginfo(&hv_dev->channel->inbound, &inbound);
-	return sprintf(buf, "%d\n", inbound.bytes_avail_towrite);
+	kfree(device_info);
+	return ret;
 }
-static DEVICE_ATTR_RO(in_write_bytes_avail);
-
 static ssize_t channel_vp_mapping_show(struct device *dev,
 				       struct device_attribute *dev_attr,
 				       char *buf)
@@ -446,7 +325,7 @@
 
 	return tot_written;
 }
-static DEVICE_ATTR_RO(channel_vp_mapping);
+/* static DEVICE_ATTR_RO(channel_vp_mapping); */
 
 /*
  * Divergence from upstream.
@@ -459,7 +338,7 @@
 	struct hv_device *hv_dev = device_to_hv_device(dev);
 	return sprintf(buf, "0x%x\n", hv_dev->vendor_id);
 }
-static DEVICE_ATTR_RO(vendor);
+/* static DEVICE_ATTR_RO(vendor); */
 
 static ssize_t device_show(struct device *dev,
 			  struct device_attribute *dev_attr,
@@ -468,38 +347,42 @@
 	struct hv_device *hv_dev = device_to_hv_device(dev);
 	return sprintf(buf, "0x%x\n", hv_dev->device_id);
 }
-static DEVICE_ATTR_RO(device);
+/* static DEVICE_ATTR_RO(device); */
 
 /* Set up per device attributes in /sys/bus/vmbus/devices/<bus device> */
-static struct attribute *vmbus_attrs[] = {
-	&dev_attr_id.attr,
-	&dev_attr_state.attr,
-	&dev_attr_monitor_id.attr,
-	&dev_attr_class_id.attr,
-	&dev_attr_device_id.attr,
-	&dev_attr_modalias.attr,
-	&dev_attr_server_monitor_pending.attr,
-	&dev_attr_client_monitor_pending.attr,
-	&dev_attr_server_monitor_latency.attr,
-	&dev_attr_client_monitor_latency.attr,
-	&dev_attr_server_monitor_conn_id.attr,
-	&dev_attr_client_monitor_conn_id.attr,
-	&dev_attr_out_intr_mask.attr,
-	&dev_attr_out_read_index.attr,
-	&dev_attr_out_write_index.attr,
-	&dev_attr_out_read_bytes_avail.attr,
-	&dev_attr_out_write_bytes_avail.attr,
-	&dev_attr_in_intr_mask.attr,
-	&dev_attr_in_read_index.attr,
-	&dev_attr_in_write_index.attr,
-	&dev_attr_in_read_bytes_avail.attr,
-	&dev_attr_in_write_bytes_avail.attr,
-	&dev_attr_vendor.attr,
-	&dev_attr_device.attr,
-	&dev_attr_channel_vp_mapping.attr,
-	NULL,
+static struct device_attribute vmbus_device_attrs[] = {
+	__ATTR(id, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(state, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(class_id, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(device_id, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(monitor_id, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(modalias, S_IRUGO, vmbus_show_device_attr, NULL),
+
+	__ATTR(server_monitor_pending, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(server_monitor_latency, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(server_monitor_conn_id, S_IRUGO, vmbus_show_device_attr, NULL),
+
+	__ATTR(client_monitor_pending, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(client_monitor_latency, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(client_monitor_conn_id, S_IRUGO, vmbus_show_device_attr, NULL),
+
+	__ATTR(out_intr_mask, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(out_read_index, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(out_write_index, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(out_read_bytes_avail, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(out_write_bytes_avail, S_IRUGO, vmbus_show_device_attr, NULL),
+
+	__ATTR(in_intr_mask, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(in_read_index, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(in_write_index, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(in_read_bytes_avail, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(in_write_bytes_avail, S_IRUGO, vmbus_show_device_attr, NULL),
+	__ATTR(vendor, S_IRUGO, vendor_show, NULL),
+	__ATTR(device, S_IRUGO, device_show, NULL),
+	__ATTR(channel_vp_mapping, S_IRUGO, channel_vp_mapping_show, NULL),
+	__ATTR_NULL
 };
-ATTRIBUTE_GROUPS(vmbus);
+
 
 /*
  * vmbus_uevent - add uevent for our device
@@ -660,10 +543,12 @@
 	.remove =		vmbus_remove,
 	.probe =		vmbus_probe,
 	.uevent =		vmbus_uevent,
-	.dev_groups =		vmbus_groups,
+	.dev_attrs =    	vmbus_device_attrs,
 };
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 static const char *driver_name = "hyperv";
+#endif
 
 struct onmessage_work_context {
 	struct work_struct work;
@@ -766,10 +651,10 @@
 	}
 }
 
-#if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
-static void vmbus_isr(void)
-#else
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 static irqreturn_t vmbus_isr(int irq, void *dev_id)
+#else
+static void vmbus_isr(void)
 #endif
 {
 	int cpu = smp_processor_id();
@@ -780,10 +665,10 @@
 
 	page_addr = hv_context.synic_event_page[cpu];
 	if (page_addr == NULL)
-#if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
-		return;
-#else
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 		return IRQ_NONE;
+#else
+		return;
 #endif
 
 	event = (union hv_synic_event_flags *)page_addr +
@@ -826,14 +711,11 @@
 		else
 			tasklet_schedule(&msg_dpc);
 	}
-#if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
-	return;
-#else
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 	if (handled)
 		return IRQ_HANDLED;
 	else
 		return IRQ_NONE;
-
 #endif
 }
 
@@ -871,18 +753,15 @@
 #endif
 
 
-/*
- * vmbus interrupt flow handler:
- * vmbus interrupts can concurrently occur on multiple CPUs and
- * can be handled concurrently.
- */
-
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 static void vmbus_flow_handler(unsigned int irq, struct irq_desc *desc)
 {
 	kstat_incr_irqs_this_cpu(irq, desc);
 
 	desc->action->handler(irq, desc->action->dev_id);
 }
+#endif
+
 
 /*
  * vmbus_bus_init -Main vmbus driver initialization routine.
@@ -910,6 +789,7 @@
 	if (ret)
 		goto err_cleanup;
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 	ret = request_irq(irq, vmbus_isr, 0, driver_name, hv_acpi_dev);
 
 	if (ret != 0) {
@@ -923,16 +803,20 @@
 	 * different CPUs. Establish an appropriate interrupt flow
 	 * handler that can support this model.
 	 */
-	irq_set_handler(irq, vmbus_flow_handler);
-
-#if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
+	set_irq_handler(irq, vmbus_flow_handler);
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE >= 1541)
+	/*
+	 * Register our interrupt handler.
+	 */
+	hv_register_vmbus_handler(irq, vmbus_isr);
+#endif
+#else
 	hv_setup_vmbus_irq(vmbus_isr);
+#endif
+	
 
-#else
 
-	hv_register_vmbus_handler(irq, vmbus_isr);
-#endif
 
 	ret = hv_synic_alloc();
 	if (ret)
@@ -946,28 +830,32 @@
 	if (ret)
 		goto err_alloc;
 
-	/*
-         * Only register if the crash MSRs are available
-         */
-        if (ms_hyperv.features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {
-                atomic_notifier_chain_register(&panic_notifier_list,
-                                               &hyperv_panic_block);
-        }
-	
 	hv_cpu_hotplug_quirk(true);
+
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1540)
+	ms_hyperv.features |= HV_X64_MSR_TIME_REF_COUNT_AVAILABLE;
+#endif
+
+	/*
+	 * Only register if the crash MSRs are available
+	 */
+	if (ms_hyperv.features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {
+		atomic_notifier_chain_register(&panic_notifier_list,
+					       &hyperv_panic_block);
+	}
+
 	vmbus_request_offers();
 
 	return 0;
 
 err_alloc:
-	hv_synic_free();
 	free_irq(irq, hv_acpi_dev);
-#if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
-	hv_remove_vmbus_irq();
-#endif
+	hv_synic_free();
 
+#if defined(RHEL_RELEASE_VERSION) && (RHEL_RELEASE_CODE < 1543)
 err_unregister:
 	bus_unregister(&hv_bus);
+#endif
 
 err_cleanup:
 	hv_cleanup();
@@ -1175,7 +1063,7 @@
 	return AE_OK;
 }
 
-static int vmbus_acpi_remove(struct acpi_device *device)
+static int vmbus_acpi_remove(struct acpi_device *device, int type)
 {
 	struct resource *cur_res;
 	struct resource *next_res;
@@ -1300,7 +1188,7 @@
 acpi_walk_err:
 	complete(&probe_event);
 	if (ret_val)
-		vmbus_acpi_remove(device);
+		vmbus_acpi_remove(device, 0);
 	return ret_val;
 }
 
@@ -1364,11 +1252,9 @@
 {
 	int cpu;
 	vmbus_connection.conn_state = DISCONNECTED;
-//	hv_synic_clockevents_cleanup();  will comment this for time being till clockevents_unbind showed up in distro code
+	hv_synic_clockevents_cleanup();
 	vmbus_disconnect();
-#if (RHEL_RELEASE_CODE >=1800 ) /* KYS; we may have to tweak this */
-	hv_remove_vmbus_irq();
-#endif
+	free_irq(irq, hv_acpi_dev);
 	tasklet_kill(&msg_dpc);
 	vmbus_free_channels();
 	if (ms_hyperv.features & HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {
Only in hv-rhel7.x/hv/: xorg.conf
